# 服务器的基本概念与初识Ajax

---

## 客户端与服务器

- 客户端：客户也就是你，客服端也就是你这一端可以接触到的程序，手机app,web网页等，我们可以在客户端的界面上向服务器发送请求以及数据，交给服务器处理
- 服务端：也就是提供为客户端提供“服务”，接收并储存客户端发送过来的数据或请求，并且对请求进行响应，发送数据给客户端

![image-20221031101810812](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031101810812.png)

---

### 1.IP地址与端口号

- IP地址：用于找到主机，由网络地址与主机地址组成，网络地址表示互联网的哪一个网络，主机地址表示其属于网络下的哪一台主机。
- 端口号：用于找到主机下的特定进程提供的服务，每一个服务器都有独一无二的端口号

---

### 2.客户端与服务器的通信过程

---

客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤。

- 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象。

- `XMLHttpRequest（简称 xhr）是浏览器提供的 js 成员，通过它，可以请求服务器上的数据资源。`

- 最简单的用法 var xhrObj = new XMLHttpRequest() 

![image-20221031102754128](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031102754128.png)

基于浏览器的开发者工具分析通信过程

![image-20221031102904229](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031102904229.png)

### 3.服务器对外提供的资源

![image-20221031103443028](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031103443028.png)

数据是网页的灵魂

![image-20221031103501722](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031103501722.png)

### 4.资源的请求方式

- get 请求通常用于获取服务端资源（向服务器要资源）

- post 请求通常用于向服务器提交数据（往服务器发送资源）

![image-20221031110116083](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031110116083.png)

## URL地址

- URL（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。
- 常见的URL举例：http://www.baidu.comhttp

---

1.URL 地址的组成

![image-20221031101842607](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031101842607.png)

## 了解Ajax

- Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。

- `通俗的理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。`

- Ajax能让我们轻松实现网页与服务器之间的数据交互。

![image-20221031110727412](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031110727412.png)

### 1.Ajax的典型应用场景

---

用户名检测：注册用户时，通过 ajax 的形式，动态检测用户名是否被占用

 ![image-20221031150003287](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031150003287.png)

搜索提示：当输入搜索关键字时，通过 ajax 的形式，动态加载搜索提示列表

![image-20221031150025822](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031150025822.png)

数据分页显示：当点击页码值的时候，通过 ajax 的形式，根据页码值动态刷新表格的数据

![image-20221031150046999](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031150046999.png)

数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过 ajax 的形式，来实现数据的交互

![image-20221031150107030](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031150107030.png)

## JQuery中的Ajax

- 浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。

- jQuery 中发起 Ajax 请求最常用的三个方法如下：` $.get()  、$.post()  、$.ajax() `

---

### 1.$.get()函数的语法

- jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。

- `$.get(url, [data], [callback])   `  中括号代表可选参数

其中，三个参数各自代表的含义如下：

| **参数名** | **参数类型** | **是否必选** | **说明**                 |
| ---------- | ------------ | ------------ | ------------------------ |
| url        | string       | 是           | 要请求的资源地址         |
| data       | object       | 否           | 请求资源期间要携带的参数 |
| callback   | function     | 否           | 请求成功时的回调函数     |

$.get()发起不带参数的请求

- 回调函数中的 参数用来接受服务端响应的数据
- `XHR 中可以拦截 Ajax 请求`

![image-20221031153723365](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031153723365.png)

```js
 <button id="btnGET">发起不带参数的GET请求</button>
---------------------------------------------------------------------------------------------
// 在页面加载事件中 绑定单击事件
    $(function () {
      $('#btnGET').on('click', function () {
        $.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
          // 服务器返回数据 都在 res中
          console.log(res) 
        })
      })
    })
```

$.get()发起带参数的请求

- 参数类型 为对象

![image-20221031153742416](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031153742416.png)

```js
 <button id="btnGETINFO">发起单参数的GET请求</button>
-----------------------------------------------------------------------------------------------------
<script>
    $(function () {
      $('#btnGETINFO').on('click', function () {
        $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function (res) {
          console.log(res)
        })
      })
    })
  </script>
```

### 2.$.post()函数的语法

- jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，从而向服务器提交数据。

- $.post() 函数的语法如下：$.post(url, [data], [callback])

其中，三个参数各自代表的含义如下：

| **参数名** | **参数类型** | **是否必选** | **说明**                 |
| ---------- | ------------ | ------------ | ------------------------ |
| url        | string       | 是           | 提交数据的地址           |
| data       | object       | 否           | 要提交的数据             |
| callback   | function     | 否           | 数据提交成功时的回调函数 |

$.post()向服务器提交数据

![image-20221031154324003](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031154324003.png)

```js
 <button id="btnPOST">发起POST请求</button>
----------------------------------------------------------------------------------
<script>
    $(function () {
      $('#btnPOST').on('click', function () {
        $.post('http://www.liulongbin.top:3006/api/addbook', { bookname: '水浒传', author: '施耐庵', publisher: '天津图书出版社' }, function (res) {
          console.log(res)
        })
      })
```

###  3.$.ajax()函数的语法

- 相比于 $.get() 和 $.post() 函数，jQuery 中提供的 $.ajax() 函数，是一个功能比较综合的函数，`它允许我们对 Ajax 请求进行更详细的配置。`

![image-20221031154943960](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031154943960.png)

使用$.ajax()发起GET请求

- 使用 $.ajax() 发起 GET 请求时，只需要将 type 属性的值设置为 'GET' 即可：

![image-20221031155242747](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031155242747.png)

```js
 <button id="btnGET">发起GET请求</button>
---------------------------------------------------------------------------------------------
$(function () {
      $('#btnGET').on('click', function () {
        $.ajax({
          type: 'GET',
          url: 'http://www.liulongbin.top:3006/api/getbooks',
          data: {
            id: 1
          },
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
```

使用$.ajax()发起POST请求

- 使用 $.ajax() 发起 POST 请求时，只需要将 type 属性的值设置为 'POST' 即可：

![image-20221031155419914](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031155419914.png)

```js
   <button id="btnPOST">发起POST请求</button>
   ----------------------------------------------------------------
 $(function () {
      $('#btnPOST').on('click', function () {
        $.ajax({
          type: 'POST',
          url: 'http://www.liulongbin.top:3006/api/addbook',
          data: {
            bookname: '史记',
            author: '司马迁',
            publisher: '上海图书出版社'
          },
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
```

## PostMan 测试接口

- 使用 Ajax 请求数据时，`被请求的 URL 地址，就叫做数据接口（简称接口`）。同时，每个接口必须有请求方式。
- 例如：
  - http://www.liulongbin.top:3006/api/getbooks  获取图书列表的接口(GET请求)
  - http://www.liulongbin.top:3006/api/addbook   添加图书的接口（POST请求）

1.接口测试工具

---

使用PostMan测试GET接口

![image-20221031163949595](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031163949595.png)

使用PostMan测试POST接口

![image-20221031164140173](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031164140173.png)

2.接口文档

- `接口文档，顾名思义就是接口的说明文档，它是我们调用接口的依据。`好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用

接口文档的组成部分

![image-20221031164615275](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031164615275.png)

接口文档示例

![image-20221031164800906](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031164800906.png)

![image-20221031164816633](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031164816633.png)

![image-20221031164850364](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221031164850364.png)

# form表单与模板引擎

---

## form表单的基本使用

- 表单在网页中主要负责数据采集功能。HTML中的<form>标签，就是用于采集用户输入的信息，并通过<form>标签的提交操作，把采集到的信息提交到服务器端进行处理。

![image-20221102092736435](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221102092736435.png)

### 1.表单的组成部分

- 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。

![image-20221102092952494](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221102092952494.png)

### 2. < form > 标签的属性

- < form >标签用来采集数据，`< form >标签的属性则是用来规定如何把采集到的数据发送到服务器。`
- action 属性的值应该是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。`当 <form> 表单在未指定 action 属性值的情况下，action 的默认值为当前页面的 URL 地址`。

| **属性** | **值**                                                       | **描述**                                  |
| -------- | ------------------------------------------------------------ | ----------------------------------------- |
| action   | URL地址                                                      | 规定当提交表单时，向何处发送表单数据      |
| method   | get或post                                                    | 规定以何种方式把表单数据提交到 action URL |
| enctype  | application/x-www-form-urlencodedmultipart/form-datatext/plain | 规定在发送表单数据之前如何对其进行编码    |
| target   | _blank_self_parent_top*framename*                            | 规定在何处打开 action URL                 |

- target 属性用来规定在何处打开 action URL。

| _blank      | 在新窗口中打开。               |
| ----------- | ------------------------------ |
| _self       | 默认。在相同的框架中打开。     |
| _parent     | 在父框架集中打开。（很少用）   |
| _top        | 在整个窗口中打开。（很少用）   |
| *framename* | 在指定的框架中打开。（很少用） |

- method 属性用来规定以何种方式把表单数据提交到 action URL。
  1. 它的可选值有两个，分别是 get 和 post。
  2. 默认情况下，method 的值为 get，表示通过URL地址的形式，把表单数据提交到 action URL。

> 注意：get 方式适合用来提交少量的、简单的数据。`post 方式适合用来提交大量的、复杂的、或包含文件上传的数据。（提交用户名、密码时必须用post保证数据的隐秘性）`
>
> 在实际开发中，<form> 表单的 post 提交方式用的最多，很少用 get。例如登录、注册、添加数据等表单操作，都需要使用 post 方式来提交表单。

- enctype 属性用来规定在发送表单数据之前如何对数据进行编码。
  1. 它的可选值有三个，默认情况下，enctype 的值为 application/x-www-form-urlencoded，表示在发送前编码所有的字符。

| application/x-www-form-urlencoded | 在发送前编码所有字符（默认）                                 |
| --------------------------------- | ------------------------------------------------------------ |
| multipart/form-data               | 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 |
| text/plain                        | 空格转换为 “+” 加号，但不对特殊字符编码。（很少用）          |

> 注意：`在涉及到文件上传的操作时，必须将 enctype 的值设置为 multipart/form-data`
>
> 如果表单的提交不涉及到文件上传操作，则直接将 enctype 的值设置为 application/x-www-form-urlencoded 即可！

### 3.表单的同步提交及缺点

- 通过点击 submit 按钮，触发表单提交的操作，从而使页面跳转到 action URL 的行为，叫做表单的同步提交。

- 表单同步提交的缺点

  1. < form >表单同步提交后，整个页面会发生跳转，跳转到 action URL 所指向的地址，用户体验很差。

  2. < form >表单同步提交后，页面之前的状态和数据会丢失。
  3. 解决方案: `表单只负责采集数据，Ajax 负责将数据提交到服务器。`

## 通过Ajax提交表单数据

- 监听表单提交事件
  1. 在 jQuery 中，可以使用如下两种方式，监听到表单的提交事件

![image-20221102100930838](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221102100930838.png)

- 阻止表单默认提交行为
  1. 当监听到表单的提交事件以后，可以调用事件对象的 event.preventDefault() 函数，来阻止表单的提交和页面的跳转

![image-20221102101102180](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221102101102180.png)

- 快速获取表单中的数据
  1. 为了简化表单中数据的获取操作，jQuery 提供了 serialize() 函数，可以一次性获得所有数据
  2. `在使用 serialize() 函数快速获取表单数据时，必须为每个表单元素添加 name 属性！`返回的数据字符串 需要通过name属性的值拼接
  3. serialize() 函数  必须通过表单标签的 jq 对象调用

![image-20221102101351771](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221102101351771.png)

## 模板引擎

- 模板引擎，顾名思义，它可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML页面。


- 模板引擎的好处: 减少了字符串的拼接操作 ；使代码结构更清晰 ；使代码更下次易于阅读与维护

---

### art-template模板引擎

- art-template 是一个简约、超快的模板引擎。中文官网首页为 http://aui.github.io/art-template/zh-cn/index.html

- art-template的安装
  1. 在浏览器中访问 http://aui.github.io/art-template/zh-cn/docs/installation.html 页面，找到下载链接后，鼠标右键，选择“链接另存为”，将 art-template 下载到本地，然后，通过 <script> 标签加载到网页上进行使用。

![image-20221103111215010](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103111215010.png)

#### 1.模板引擎的基本使用

- [案例演示：模板引擎](D:\Java code\6. ajax\day02\08.演示模板引擎的使用.html)

- 导入 art-template；
  1. 导入完成后，多一个函数，叫做  `template('模板的Id', 需要渲染的数据对象)`

```js
<!-- 1. 导入模板引擎 -->
  <!-- 在 window 全局，多一个函数，叫做 template('模板的Id', 需要渲染的数据对象) -->
<script src="./lib/template-web.js"></script>
```

- 定义模板； 
  1. 模板的 HTML 结构，必须定义到 script 中 ,定义 type="text/html

```js
 <!-- 3. 定义模板 -->
  <!-- 3.1 模板的 HTML 结构，必须定义到 script 中 ,定义 type="text/html"-->
  <!-- script 不添加type属性，默认 text/javascript,是指将所有的文本当js处理 -->
  <script type="text/html" id="tpl-user">
    <h1>{{name}}    ------    {{age}}</h1>
    {{@ test}}
// 条件输出
    <div>
      {{if flag === 0}}
      flag的值是0
      {{else if flag === 1}}
      flag的值是1
      {{/if}}
    </div>
// 循环输出
    <ul>
      {{each hobby}}
      <li>索引是:{{$index}}，循环项是:{{$value}}</li>
      {{/each}}
    </ul>
// 过滤输出，对日期进行格式化处理
    <h3>{{regTime | dateFormat}}</h3>
  </script>
```

- 定义数据；调用 template 函数；渲染HTML结构

```js
<script>
    // 定义处理时间的过滤器
    template.defaults.imports.dateFormat = function (date) {
      var y = date.getFullYear()
      var m = date.getMonth() + 1
      var d = date.getDate()

      return y + '-' + m + '-' + d
    }
    // 2. 定义需要渲染的数据
    var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }

    // 4. 调用 template 函数， 第一个参数为id 字符串
    var htmlStr = template('tpl-user', data)
    console.log(htmlStr)
    // 5. 渲染HTML结构
    $('#container').html(htmlStr)
  </script>
```

#### 2.标准语法

- art-template 提供了 {{ }} 这种语法格式，在 {{ }} 内可以进行变量输出，或循环数组等操作，这种 {{ }} 语法在 art-template 中被称为标准语法。

```js
 <h1>{{name}}    ------    {{age}}</h1>
```

- 在 {{ }} 语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。

![image-20221103121121973](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103121121973.png)

##### 原文输出

1. 如果要输出的 value 值中，`包含了 HTML 标签结构，则需要使用原文输出语法，才能保证 HTML 标签被正常渲染。 `
2. ![image-20221103121240826](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103121240826.png)

```js
var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }
------------------------------------------------------------------------
//  渲染的数据带有 html标签时，需要 加@
{{@ test}}
```

##### 条件输出

1. 如果要实现条件输出，则可以在 {{ }} 中使用 if … else if … /if 的方式，进行按需输出。

2. ![image-20221103122021191](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103122021191.png)

3. ```js
   var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }
   ------------------------------------------------------------------------
   <div>
         {{if flag === 0}}
         flag的值是0
         {{else if flag === 1}}
         flag的值是1
         {{/if}}
       </div>
   
   ```

##### 循环输出

1. 如果要实现循环输出，则可以在 {{ }} 内，通过 each 语法循环数组，当前循环的索引使用 $index 进行访问，当前的循环项使用 $value 进行访问。

2. ![image-20221103122413029](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103122413029.png)

3. ​    {{each hobby}} 。。。   {{/each}}   循环语句中间的标签会进行多次渲染

   ```js
   var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }
   ------------------------------------------------------------------------
      <ul>
         {{each hobby}}
         // 遍历后， li 标签会进行多次渲染
         <li>索引是:{{$index}}，循环项是:{{$value}}</li>
         {{/each}}
       </ul>
   ```

##### 标准语法 – 过滤器

1. 过滤器的本质，就是一个 function 处理函数

2. ![image-20221103123310285](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103123310285.png)

3. 过滤器语法类似管道操作符，它的上一个输出作为下一个输入。返回的结果会被直接渲染

   - 过滤器的名字可以自定义，value值 作为 过滤函数的实参进行传递

   - ![image-20221103124014934](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103124014934.png)

   - 定义一个格式化时间的过滤器 dateFormat 如下：

     ```js
     var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }
     ------------------------------------------------------------------------
     // 调用过滤函数，并对return 结果进行渲染
     <h3>{{regTime | dateFormat}}</h3>
     
      // 定义处理时间的过滤器，该函数在页面渲染时调用
         template.defaults.imports.dateFormat = function (date) {
           var y = date.getFullYear()
           var m = date.getMonth() + 1
           var d = date.getDate()
     
           return y + '-' + m + '-' + d
         }
     
     ```

# AJax 进阶

---

## XMLHttpRequest的基本使用

- XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源。之前所学的 jQuery 中的 Ajax 函数，就是基于 xhr 对象封装出来的。

  ![image-20221104165435847](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221104165435847.png)

### 使用xhr发起GET请求

- ```js
  xhr.readyState === 4 && xhr.status === 200   固定写法
  ```

  ![image-20221105120821140](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105120821140.png)

- 了解xhr对象的readyState属性

  XMLHttpRequest 对象的 readyState 属性，`用来表示当前 Ajax 请求所处的状态`。每个 Ajax 请求必然处于以下状态中的一个：

  ![image-20221105121536692](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105121536692.png)

- 使用xhr发起带参数的GET请求

  1.使用 xhr 对象发起带参数的 GET 请求时，只需在调用 xhr.open 期间，为 URL 地址指定参数即可

  ![image-20221105122002318](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105122002318.png)

  2.查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）

  ![image-20221105123125914](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105123125914.png)

  - 无论使用 $.ajax()，还是使用 $.get()，又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，`本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。`

  ![image-20221105123554914](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105123554914.png)

### URL编码与解码

- URL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，`在 URL 地址中不允许出现中文字符。`

- 如果 URL 中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。

- URL编码原则的通俗理解：`使用英文字符去表示非英文字符。`

  ![image-20221105124232293](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105124232293.png)

- 如何对URL进行编码与解码

  1.由于浏览器会自动对 URL 地址进行编码操作，因此，大多数情况下，程序员不需要关心 URL 地址的编码与解码操作。

  ![image-20221105124555728](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221105124555728.png)

  2.更多关于 URL 编码的知识，请参考如下博客：https://blog.csdn.net/Lxd_0111/article/details/78028889

### 使用xhr发起POST请求

![image-20221106082428954](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106082428954.png)

## 数据交换格式

- 数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。

- 前端领域，经常提及的两种数据交换格式分别是 XML 和 JSON。其中 XML 用的非常少，所以，我们重点要学习的数据交换格式就是 JSON。

  ![image-20221106082735857](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106082735857.png)

### XML 格式

- XML 的英文全称是 EXtensible Markup Language，即可扩展标记语言。因此，XML 和 HTML 类似，也是一种标记语言。

  ![image-20221106082906369](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106082906369.png)

- HTML 被设计用来描述网页上的内容，是网页内容的载体 ；XML 被设计用来传输和存储数据，是数据的载体

  ![image-20221106083053452](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106083053452.png)

- 缺点：`XML 格式臃肿，和数据无关的代码多，体积大，传输效率低 `；在 Javascript 中解析 XML 比较麻烦

### JSON 格式

- 概念：JSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象表示法”。简单来讲，JSON 就是 Javascript 对象和数组的字符串表示法，它使用文本表示一个 `JS 对象或数组的信息`，因此，`JSON 的本质是字符串。`

- JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析。

- JSON 中包含对象和数组两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。

  ![image-20221106090051554](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106090051554.png)

  ![image-20221106090113259](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106090113259.png)

- JSON语法注意事项

  ![image-20221106090354570](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106090354570.png)

#### JSON和JS对象的互转

- 要实现从 JSON 字符串转换为 JS 对象，使用 JSON.parse() 方法；`字符串转换为数据对象的过程，叫做JSON 反序列化`

  ```js
  var obj = JSON.parse('{"a": "Hello", "b": "World"}')
  //结果是 {a: 'Hello', b: 'World'}
  ```

- 要实现从 JS 对象转换为 JSON 字符串，使用 JSON.stringify() 方法；`数据对象转换为字符串的过程，叫做JSON 序列化`

  ```js
  var json = JSON.stringify({a: 'Hello', b: 'World'})
  //结果是 '{"a": "Hello", "b": "World"}'
  ```

## 封装自己的Ajax函数

- 实现的效果

  ![image-20221106093911583](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106093911583.png)

  ```js
    itheima({
        method: 'post',
        url: 'http://www.liulongbin.top:3006/api/addbook',
        data: {
          bookname: '水浒传',
          author: '施耐庵',
          publisher: '北京图书出版社'
        },
        success: function (res) {
          console.log(res)
        }
      })
  ```

- 定义options参数选项

  ![image-20221106094013085](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106094013085.png)

- 处理data参数

  需要把 data 对象，转化成查询字符串的格式，从而提交给服务器，因此提前定义 resolveData 函数如下

  ```js
  // 将js 对象转为 查询字符串的格式
  function resolveData(data) {
    var arr = []
    for (var k in data) {
      var str = k + '=' + data[k]
      arr.push(str)
    }
  
    return arr.join('&')
  }
  ```

- 定义itheima函数

  在 itheima() 函数中，需要创建 xhr 对象，并监听 onreadystatechange 事件

  ```js
  function itheima(options) {
    var xhr = new XMLHttpRequest()
  
    // 把外界传递过来的参数对象，转换为 查询字符串
    var qs = resolveData(options.data)
  
    // toUpperCase() 转为大写
    if (options.method.toUpperCase() === 'GET') {
      // 发起GET请求
      xhr.open(options.method, options.url + '?' + qs)
      xhr.send()
    } else if (options.method.toUpperCase() === 'POST') {
      // 发起POST请求
      xhr.open(options.method, options.url)
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
      xhr.send(qs)
    }
  
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4 && xhr.status === 200) {
        var result = JSON.parse(xhr.responseText)
        options.success(result)
      }
    }
  ```


## XMLHttpRequest Level2的新特性

- 旧版XMLHttpRequest的缺点:  只支持文本数据的传输，无法用来读取和上传文件；传送和接收数据时，没有进度信息，只能提示有没有完成

- XMLHttpRequest Level2的新功能 ：

  1.可以设置 HTTP 请求的时限

  `2.可以使用 FormData 对象管理表单数据`

  3.可以上传文件

  4.可以获得数据传输的进度信息

### 设置HTTP请求时限

- Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限：

  ![image-20221106170620358](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106170620358.png)

### FormData对象管理表单数据

- Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作：

  ![image-20221106171306370](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106171306370.png)

- FormData对象也可以用来获取网页表单的值，示例代码如下：

  ![image-20221106172205298](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106172205298.png)

  ```html
   <form id="form1">
      <input type="text" name="uname" autocomplete="off" />
      <input type="password" name="upwd" />
      <button type="submit">提交</button>
    </form>
    
    ---------------------------------------------------------------------
      <script>
      // 1. 通过 DOM 操作，获取到 form 表单元素
      var form = document.querySelector('#form1')
  
      form.addEventListener('submit', function (e) {
        // 阻止表单的默认提交行为
        e.preventDefault()
  
        // 创建 FormData，快速获取到 form 表单中的数据
        var fd = new FormData(form)
  
        var xhr = new XMLHttpRequest()
        xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
        xhr.send(fd)
  
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4 && xhr.status === 200) {
            console.log(JSON.parse(xhr.responseText))
          }
        }
      })
    </script>
  ```

### 上传文件

- 新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。
- [案例演示：文件上传服务器，并显示进度条](D:\Java code\6. ajax\day03\13.计算文件的上传进度.html)
- 基于Bootstrap渲染进度条

---

- 定义页面结构

  ```html
   <!-- 1. 文件选择框 -->
    <input type="file" id="file1" />
    <!-- 2. 上传文件的按钮 -->
    <button id="btnUpload">上传文件</button>
    <br />
    <!-- 3. img 标签，来显示上传成功以后的图片 -->
    <img src="" alt="" id="img" width="800" />
  
  ```

-  实现文件上传

  1.获取到用户选择的文件列表  document.querySelector('#file1').files ， 

  2.将用户选择的文件，添加到 FormData 中 。 数据存储在 files[0]  中

  ```js
   <script>
      // 1. 获取到文件上传按钮
      var btnUpload = document.querySelector('#btnUpload')
      // 2. 为按钮绑定单击事件处理函数
      btnUpload.addEventListener('click', function () {
        // 3. 获取到用户选择的文件列表
        var files = document.querySelector('#file1').files
        if (files.length <= 0) {
          return alert('请选择要上传的文件！')
        }
        console.log(files)
        console.log(typeof files)
        var fd = new FormData()
        // 将用户选择的文件，添加到 FormData 中
        fd.append('avatar', files[0])
  
        var xhr = new XMLHttpRequest()
        xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
        xhr.send(fd)
  
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4 && xhr.status === 200) {
             // json字符串 反序列化，转为 js对象 
            var data = JSON.parse(xhr.responseText)
            if (data.status === 200) {
              // 上传成功
              document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
            } else {
              // 上传失败
              console.log('图片上传失败！' + data.message)
            }
          }
        }
      })
    </script>
  ```

- 显示文件上传进度

  1.基于Bootstrap渲染进度条 

  - 通过 style 的 width 属性控制进度条的长短，长度单位为 %

  ```html
  <!-- bootstrap 中的进度条 -->
    <div class="progress" style="width: 500px; margin: 15px 10px;">
      <div class="progress-bar progress-bar-striped active" style="width: 0%" id="percent">
        0%
      </div>
    </div>
  
  ```

  2.新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下

  - xhr.upload.onprogress 事件在文件传输过程中，系统会多次调用

  ![image-20221106202213463](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106202213463.png)

  ```js
  // 监听文件上传的进度
        xhr.upload.onprogress = function (e) {
          if (e.lengthComputable) {
            // 计算出上传的进度， 向上取整
            var procentComplete = Math.ceil((e.loaded / e.total) * 100)
            console.log(procentComplete)
            // 动态设置进度条
            $('#percent').attr('style', 'width: ' + procentComplete + '%;').html(procentComplete + '%')
          }
        }
  ```

  3.监听上传完成的事件，更改进度条样式

  ![image-20221106211027505](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221106211027505.png)

  ```js
  // 监听上传完成的事件
        xhr.upload.onload = function () {
          $('#percent').removeClass().addClass('progress-bar progress-bar-success')
        }
  ```

## jQuery高级用法

---

###  jQuery实现文件上传

1.定义UI结构

![image-20221107162855024](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107162855024.png)

2.验证是否选择了文件

![image-20221107162934331](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107162934331.png)

3.向FormData中追加文件

![image-20221107163138041](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107163138041.png)

4.使用jQuery发起上传文件的请求

- 必须使用 ajax方法，发送请求

![image-20221107163310516](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107163310516.png)

### 监听到Ajax请求的事件

---

1.调用 ajaxStart(callback) 函数，当发起上传请求时，显示 加载图片

![image-20221107164256702](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107164256702.png)

2.ajaxStop(callback)，上传完成后隐藏图片

![image-20221107164334734](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107164334734.png)

## axios

- Axios 是专注于网络数据请求的库。相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。（使用需要导入 axios.js ）
- [案例演示：axios 发送请求](D:\Java code\6. ajax\day03\15.axios的基本使用.html)

---

### axios发起GET请求

![image-20221107165500225](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107165500225.png)

### axios发起POST请求

![image-20221107165611260](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107165611260.png)

### 直接使用axios发起请求

![image-20221107165702315](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221107165702315.png)

- 直接使用axios发起GET请求

```js
document.querySelector('#btn3').addEventListener('click', function () {
      var url = 'http://www.liulongbin.top:3006/api/get'
      var paramsData = { name: '钢铁侠', age: 35 }
      axios({
        method: 'GET',
        url: url,
        params: paramsData
      }).then(function (res) {
        console.log(res.data)
      })
    })
```

- 直接使用axios发起POST请求

```js
 document.querySelector('#btn4').addEventListener('click', function () {
      axios({
        method: 'POST',
        url: 'http://www.liulongbin.top:3006/api/post',
        data: {
          name: '娃哈哈',
          age: 18,
          gender: '女'
        }
      }).then(function (res) {
        console.log(res.data)
      })
    })
```

# 跨域和JSONP

---

## 了解同源策略和跨域

### 同源策略

- 同源是指如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源

  ![image-20221108104445733](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221108104445733.png)

- 同源策略（英文全称 Same origin policy）是浏览器提供的一个安全功能。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

  ![image-20221108104615845](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221108104615845.png)

### 跨域

- 同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域。
- 出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互。

---

浏览器对跨域请求的拦截

![image-20221108105440338](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221108105440338.png)

 如何实现跨域数据请求

![image-20221108105658249](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221108105658249.png)

## JSONP

---

### JSONP的实现原理

- JSONP 的实现原理，就是通过 <script> 标签的 src 属性，请求跨域的数据接口，`并通过函数调用的形式，接收跨域接口响应回来的数据。`

- 自己实现一个简单的JSONP；callback 后面跟上请求函数的名称，也可以传递参数

  ![image-20221109121619170](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221109121619170.png)

  通过 往 script 标签里添加 src属性后，导入的 js 里的代码会立即执行，添加 callback 属性明确具体需要回调的函数

  ```js
  <body>
    <script>
      function abc(data) {
        console.log('拿到了Data数据：')
        console.log(data)
      }
    </script>
  
    <script src="./js/getdata.js?callback=abc"></script>
  </body>
  
  ```

  ./js/getdata.js  里面写需要回调的函数

  ```js
  abc({ name: 'ls', age: 30 })
  ```

### jQuery中的JSONP

- jQuery 提供的 $.ajax() 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求

  1.默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。

  2.dataType: 'jsonp',   `代表我们要发起JSONP的数据请求, 请求的是服务端的js文件`； 当默认发送ajax请求时，不需要设置

  ![image-20221109123504546](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221109123504546.png)

  ```js
  <body>
    <script>
      $(function () {
        // 发起JSONP的请求
        $.ajax({
          url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
          // 代表我们要发起JSONP的数据请求
          dataType: 'jsonp',
          jsonp: 'callback',
          jsonpCallback: 'abc',
          success: function (res) {
            console.log(res)
          }
        })
      })
    </script>
  </body>
  ```

- 发送JSONP 请求时，可以自定义参数及回调函数名称

  ![image-20221109124044283](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221109124044283.png)

-  jQuery中JSONP的实现过程

  1.jQuery 中的 JSONP，也是通过 <script> 标签的 src 属性实现跨域数据访问的，只不过，`jQuery 采用的是动态创建和移除 <script> 标签的方式，来发起 JSONP 数据请求。`

  2.`在发起 JSONP 请求的时候，动态向 <header> 中 append 一个 <script> 标签；`

  3.在 JSONP 请求成功以后，动态从 <header> 中移除刚才 append 进去的 <script> 标签；

## 防抖和节流

- 防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
- 防抖的应用场景：用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源；
- 节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。
- 节流的应用场景：鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源；

---

### 节流案例 – 鼠标跟随效果

- 节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。

- 当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。每次执行操作前，必须先判断节流阀是否为空。

---

- [案例展示：减少事件触发频率](D:\Java code\6. ajax\day04\07.鼠标跟随效果.html)

  1.图片跟随鼠标移动时，减少 移动鼠标触发的事件次数

  2.开启定时器，开启前判断当前定时器是否在执行任务（定时器是否为null），并且每次执行完毕后清空定时器；在当前定时器执行完成后，不会开启新的定时器，从而减少事件的触发 

  ```html
  <body>
    <img src="./angel.gif" alt="" id="angel" />
  
    <script>
      $(function () {
        // 1. 获取到图片
        var angel = $('#angel')
        // 步骤1. 定义节流阀，默认打开
        var timer = null
        // 2. 绑定 mousemove 事件
        $(document).on('mousemove', function (e) {
          // 步骤3：当定时器正在执行任务时，不会重复开启任务，表示节流阀关闭
          //  定时器不为 null 时，结束函数
          if (timer) { return }
          // 3. 设置图片的位置
          // 步骤2：开启延时器、
          timer = setTimeout(function () {
            $(angel).css('top', e.pageY + 'px').css('left', e.pageX + 'px').css('display','block')
            console.log('ok')
            // 任务执行完成后，定时器清空，表示重新打开节流阀
            timer = null
          }, 16)
  
        })
      })
    </script>
  </body>
  ```

### 防抖和节流的区别

- 如果事件被频繁触发，`防抖能保证只有最有一次触发生效！前面 N 多次的触发都会被忽略！`；防抖是在任务开启前清空定时器，保证只执行最后一次任务

- 如果事件被频繁触发，`节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！`；节流是在任务执行完成后，清空定时器，只有当前任务完成后，才能再次开启定时器

# HTTP 协议加强

---

## HTTP协议简介

- 通信，就是信息的传递和交换。通信三要素：通信的主体、通信的内容、通信的方式。

- 通信协议（Communication Protocol）是指通信的双方完成通信所必须遵守的规则和约定。通俗的理解：`通信双方采用约定好的格式来发送和接收消息`，这种事先约定好的通信格式，就叫做通信协议。

- HTTP 协议即超文本传送协议 (HyperText Transfer Protocol) ，它`规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式`。( 网页内容又叫做超文本，因此网页内容的传输协议又叫做超文本传输协议，简称 HTTP 协议。)

- HTTP 协议采用了 请求/响应 的交互模型。

  ![image-20221111103111735](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111103111735.png)

## HTTP请求消息

- 由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做 HTTP 请求，客户端发送到服务器的消息，叫做 HTTP 请求消息。

- HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。

  ![image-20221111103527386](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111103527386.png)

  1.请求行

  - 请求行由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。

   ![image-20221111103717341](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111103717341.png)

  - HTTP请求方法

    1.请求方法的作用是：用来表明要对服务器上的资源执行的操作。
  
  ![image-20221112172855819](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112172855819.png)

  

  2.请求头部

  - `请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器`。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。
  - 请求头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。
  - 关于更多请求头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

  ![image-20221111104114514](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111104114514.png)

  ![image-20221111104135558](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111104135558.png)

  3.空行
  
  - 最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。请求消息中的空行，用来分隔请求头部与请求体。
  
   ![image-20221111104414207](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111104414207.png)
  
  4.请求体
  
  - 请求体中存放的，是要通过 POST 方式提交到服务器的数据。
  - 只有 POST 请求才有请求体，GET 请求没有请求体！

## HTTP响应消息

- 响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。

- HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成，如下图所示：

  ![image-20221111105426565](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111105426565.png)

  1.状态行

  - 状态行由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;

   ![image-20221111105608475](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221111105608475.png)

  2.响应头部

  - 响应头部用来描述服务器的基本信息。响应头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。
  - 关于更多响应头字段的描述，可以查看 MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

   ![image-20221112170441989](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112170441989.png)

  ![image-20221112170520318](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112170520318.png)

  3.响应体

  - 响应体中存放的，是服务器响应给客户端的资源内容。

   ![image-20221112170649377](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112170649377.png)

## HTTP响应状态码

- 响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。

![image-20221112173350916](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112173350916.png)

- HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。

  ![image-20221112173807637](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112173807637.png)

  2** 成功相关的响应状态码

  ![image-20221112174359098](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112174359098.png)

  3** 重定向相关的响应状态码

  ![image-20221112174421204](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112174421204.png)

  4** 客户端错误相关的响应状态码

  ![image-20221112174437390](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112174437390.png)

  5** 服务端错误相关的响应状态码

  ![image-20221112174500093](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221112174500093.png)

​	3.完整的 HTTP 响应状态码，可以参考 MDN 官方文档 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status



# AJax 案例

---

## 图书管理

- 从服务端读取数据，并进行页面渲染；实现数据的添加和删除

- 需要根据接口文档获得数据  `D:\Java code\6. ajax\day01\图书管理 - 接口文档.md`

![image-20221101162309878](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221101162309878.png)

### 1.用bootstrap框架 搭建静态页面

- 添加图书的Panel面板 

```html
<!-- 添加图书的Panel面板 -->
  <div class="panel panel-primary">
      
    <div class="panel-heading">
      <h3 class="panel-title">添加新图书</h3>
    </div>
     <!-- 所有输入框的父盒子  --> 
    <div class="panel-body form-inline">
        
      <div class="input-group">
        <div class="input-group-addon">书名</div>
        <input type="text" class="form-control" id="iptBookname" placeholder="请输入书名">
      </div>

      <div class="input-group">
        <div class="input-group-addon">作者</div>
        <input type="text" class="form-control" id="iptAuthor" placeholder="请输入作者">
      </div>

      <div class="input-group">
        <div class="input-group-addon">出版社</div>
        <input type="text" class="form-control" id="iptPublisher" placeholder="请输入出版社">
      </div>
        
	<!--btnAdd 需要绑定点击事件-->	
      <button id="btnAdd" class="btn btn-primary">添加</button>
        
    </div>
  </div>



```

- 图书的表格


```html
 <table class="table table-bordered table-hover">
    <thead>
      <tr>
        <th>Id</th>
        <th>书名</th>
        <th>作者</th>
        <th>出版社</th>
        <th>操作</th>
      </tr>
    </thead>
    <tbody id="tb">
     <!--获得服务端数据后进行渲染   -->
          <!-- 
	<tr>
           <td>' + item.id + '</td>
           <td>' + item.bookname + '</td>
           <td>' + item.author + '</td>
           <td>' + item.publisher + '</td>
           <td><a href="javascript:;" class="del" data-id="' + item.id + '">删除</a></td>
        </tr>
	-->
     </tbody>
  </table>
```

### 2.从服务端获取数据，进行页面渲染

- 定义getBookList 函数，根据接口文档向服务器请求数据，并进行页面渲染

```js

function getBookList() {
        $.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
          if (res.status !== 200) return alert('获取数据失败！')
	// 可以将数组改为 字符串
          var rows = []
          $.each(res.data, function (i, item) {
             //  可以改为 拼接模板字符串 
            rows.push('<tr><td>' + item.id + '</td><td>' + item.bookname + '</td><td>' + item.author + '</td><td>' + item.publisher + '</td><td><a href="javascript:;" class="del" data-id="' + item.id + '">删除</a></td></tr>')
          })
          //  join方法 将数组拼接为字符串
          $('#tb').empty().append(rows.join(''))
        })
      }
```

- 通过事件委托的方式为动态添加的元素绑定点击 删除事件

```js
 $('tbody').on('click', '.del', function () {
     // 获取自定义属性，属性里存入的是从后端获取的id值
        var id = $(this).attr('data-id')
        $.get('http://www.liulongbin.top:3006/api/delbook', { id: id }, function (res) {
          if (res.status !== 200) return alert('删除图书失败！')
           //  删除成功重新渲染 页面 
          getBookList()
        })
      })
```

### 3.绑定 添加数据的点击事件

```js
 $('#btnAdd').on('click', function () {
        // 去除输入栏中两端的空格
        var bookname = $('#iptBookname').val().trim()
        var author = $('#iptAuthor').val().trim()
        var publisher = $('#iptPublisher').val().trim()
        if (bookname.length <= 0 || author.length <= 0 || publisher.length <= 0) {
          return alert('请填写完整的图书信息！')
        }

        $.post('http://www.liulongbin.top:3006/api/addbook', { bookname: bookname, author: author, publisher: publisher }, function (res) {
          if (res.status !== 201) return alert('添加图书失败！')
          getBookList()
          //数据添加成功后，将输入栏清空
          $('#iptBookname').val('')
          $('#iptAuthor').val('')
          $('#iptPublisher').val('')
        })
      })
```

[网页特效：图书管理](D:\Java code\6. ajax\day01\06.图书管理.html)

---

## 聊天机器人

- 只要是将用户输入的文字发送给服务端，服务端处理信息后再发送给客户端
- 服务端 聊天接口 http://www.liulongbin.top:3006/api/robot
- 服务端 音频接口 http://www.liulongbin.top:3006/api/synthesize

![image-20221101192955457](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221101192955457.png)

[网页特效：聊天机器人](D:\Java code\6. ajax\day01\聊天机器人\聊天机器人.html)

---

## 案例 – 新闻列表

- 使用模板引擎进行页面渲染

- [案例演示：新闻列表](D:\Java code\6. ajax\day02\案例-新闻列表\案例-新闻列表.html)

![image-20221103163149606](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221103163149606.png)

### 新闻评论的接口数据列表

- 接口URL：  /api/news

- 调用方式： GET

- 参数格式：无

- 响应格式：

| 数据名称  | 数据类型 | 说明                                         |
| --------- | -------- | -------------------------------------------- |
| status    | Number   | 200 获取新闻列表成功；500 获取新闻列表失败！ |
| msg       | String   | 对 status 字段的详细说明                     |
| data      | Array    | 新闻列表数组                                 |
| +id       | Number   | 新闻Id                                       |
| +title    | String   | 新闻标题                                     |
| +source   | String   | 新闻来源                                     |
| +cmtcount | Number   | 评论数量                                     |
| +tags     | String   | 标签                                         |
| +img      | String   | 图片地址                                     |
| +time     | String   | 发表时间                                     |

+ 返回示例：

```json
{
    "status": 200,
    "msg": "获取新闻列表成功",
    "data": [
        {
            "id": 1,
            "title": "5G商用在即，三大运营商营收持续下降",
            "source": "新京报经济新闻",
            "cmtcount": 58,
            "tags": "三大运营商,中国移动,5G商用",
            "img": "/images/0.webp",
            "time": "2019-10-28T03:50:28.000Z"
        }
        ......
    ]
}
```

### 获取新闻数据,并进行页面渲染

-  把每一项的 tags 属性，从字符串改造成字符串的数组

```js
// 获取新闻列表的函数
  function getNewsList() {
    $.get('http://www.liulongbin.top:3006/api/news', function (res) {
      if (res.status !== 200) {
        return alert('获取新闻列表数据失败！')
      }
      for (var i = 0; i < res.data.length; i++) {
        // 把每一项的 tags 属性，从字符串改造成字符串的数组，并重新赋值
         // 改为数据后，可以进行遍历 
        res.data[i].tags = res.data[i].tags.split(',')
      }
      console.log(res)
      //   调用template 函数，并进行html页面渲染
      var htmlStr = template('tpl-news', res)
      $('#news-list').html(htmlStr)
    })
  }
```

### 定义 template 模板

-  模板定义在 script 里，并修改script 标签的type 属性 ， type="text/html"
- 新闻数据 存储在 data 对象数组中，遍历该数组拿到数据；$value 表示数组中的每一个对象
-  src="{{'http://www.liulongbin.top:3006' + $value.img}}"   图片资源地址前需要添加根路径
- tags 的值需要转为数组，再遍历渲染
- 定义时间过滤器，修改日期格式

```js
<body>
    // 新闻列表内容显示区
  <div id="news-list"></div>

  <!-- 定义模板 -->
  <script type="text/html" id="tpl-news">
      {{each data}}
      <div class="news-item">
         // 图片资源地址前需要添加根路径 ，$value 表示数组中的每一个对象
        <img class="thumb" src="{{'http://www.liulongbin.top:3006' + $value.img}}" alt="" />
        <div class="right-box">
          <h1 class="title">{{$value.title}}</h1>
	//  tags 的值需要转为数组，再遍历渲染
          <div class="tags">
            {{each $value.tags}}
            <span>{{$value}}</span>
            {{/each}}
              
          </div>
          <div class="footer">
            <div>
              <span>{{$value.source}}</span>&nbsp;&nbsp;
             //定义时间过滤器，修改日期格式
              <span>{{$value.time | dateFormat}}</span>
            </div>
            <span>评论数：{{$value.cmtcount}}</span>
          </div>
        </div>
      </div>
      {{/each}}
    </script>

</body>
```

### 定义时间过滤器、补零函数

- 给时间补零的函数， 月 、日 、小时、分钟、秒 都需要补零
- 定义时间格式 ：yyyy-mm-dd hh:mm:ss

```js
// 给时间补零的函数， 月 、日 、小时、分钟、秒 都需要补零
  function padZero(n) {
    if (n < 10) {
      return '0' + n
    } else {
      return n
    }
  }

  // 定义格式化时间的过滤器
  template.defaults.imports.dateFormat = function (dtStr) {
    var dt = new Date(dtStr)

    var y = dt.getFullYear()
    var m = padZero(dt.getMonth() + 1)
    var d = padZero(dt.getDate())

    var hh = padZero(dt.getHours())
    var mm = padZero(dt.getMinutes())
    var ss = padZero(dt.getSeconds())

    //  yyyy-mm-dd hh:mm:ss
    return y + '-' + m + '-' + d + ' ' + hh + ':' + mm + ':' + ss
  }

```

## 淘宝搜索

- [案例展示：淘宝搜索](D:\Java code\6. ajax\day04\淘宝搜索案例\index.html)

- 需要发送跨域请求 （JSONP 请求），获得建议列表的数据，并使用模板引擎进行页面渲染

  ![image-20221109164947713](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221109164947713.png)

### 1.页面结构

```html
<div class="container">
    <!-- Logo -->
    <img src="./images/taobao_logo.png" alt="" class="logo" />

    <div class="box">
      <!-- tab 栏 -->
      <div class="tabs">
        <div class="tab-active">宝贝</div>
        <div>店铺</div>
      </div>
      <!-- 搜索区域（搜索框和搜索按钮） -->
      <div class="search-box">
        <input id="ipt" type="text" class="ipt" placeholder="请输入要搜索的内容" /><button class="btnSearch">
          搜索
        </button>
      </div>
      <!-- 搜索建议列表 -->
      <div id="suggest-list"></div>
    </div>
```

### 2.用户输入关键字后，发送跨域请求，获得建议列表的数据并进行页面渲染

- 为输入框绑定 keyup 事件，获取用户输入的搜索关键词

  1.先判断用户是否重复搜索，是则直接从缓存中取数据，并进行页面渲染

  2.用户键盘输入为高频操作，每次按下都会触发，需要开启定时器，延迟发送请求，减少发送无效请求

  ```js
    $('#ipt').on('keyup', function () {
          // 3. 每次按下键盘都会，清空上个定时器 timer
          clearTimeout(timer)
          var keywords = $(this).val().trim()
          // 如果关键词为空，则清空建议列表
          if (keywords.length <= 0) {
            return $('#suggest-list').empty().hide()
          }
  
          // 先判断缓存中是否有数据
          if (cacheObj[keywords]) {
             // 有数据则直接进行渲染
            return renderSuggestList(cacheObj[keywords])
          }
  
          // 延迟发送请求，并进行页面渲染 
          debounceSearch(keywords)
        })
  ----------------------------------------------------------------------------
  //  定义延时器的Id
        var timer = null
  //  定义防抖的函数，延迟发送请求
        function debounceSearch(kw) {
          timer = setTimeout(function () {
            getSuggestList(kw)
          }, 500)
        }
  
  
  ```

- 定义模板结构，发送跨域请求，进行页面渲染

  1.在渲染后，对数据进行缓存，定义全局缓存对象；当用户重复搜索时，不用发送重复的请求

  ```js
   <!-- 模板结构 -->
    <script type="text/html" id="tpl-suggestList">
      {{each result}}
        <!--搜索建议项-->
        <div class="suggest-item">{{$value[0]}}</div>
      {{/each}}
    </script>
  --------------------------------------------------------------------------------------
    // 发送 jsonp请求
         function getSuggestList(kw) {
          $.ajax({
            url: 'https://suggest.taobao.com/sug?q=' + kw,
            dataType: 'jsonp',
            success: function (res) {
              // console.log(res)
              renderSuggestList(res)
            }
          })
        }
        
        // 定义全局缓存对象
        var cacheObj = {}
        
        // 渲染UI结构
        function renderSuggestList(res) {
          // 判断是否获得数据  
          if (res.result.length <= 0) {
            return $('#suggest-list').empty().hide()
          }
          // 拿到数据后进行 页面渲染
          var htmlStr = template('tpl-suggestList', res)
          $('#suggest-list').html(htmlStr).show()
  
          // 1. 获取到用户输入的内容，当做键
          var k = $('#ipt').val().trim()
          // 2. 需要将数据作为值，进行缓存
          cacheObj[k] = res
        }
      })    
  ```

  

