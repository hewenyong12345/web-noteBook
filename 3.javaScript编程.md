# JavaScript 基础 

> 了解变量、数据类型、运算符等基础概念，能够实现数据类型的转换，结合四则运算体会如何编程。

- 体会现实世界中的事物与计算机的关系
- 理解什么是数据并知道数据的分类
- 理解变量存储数据的“容器”
- 掌握常见运算符的使用，了解优先级关系
- 知道 JavaScript 数据类型隐式转换的特征

![image-20220909102937730](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220909102937730.png)

![image-20220909103124652](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220909103124652.png)

[javaScript 官网 (mozilla.org)](https://developer.mozilla.org/zh-CN/)

## 介绍

> 掌握 JavaScript 的引入方式，初步认识 JavaScript 的作用

###  引入方式

JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 `script` 标签将 JavaScript 代码引入到 HTML 中，有两种方式：

#### 1. 内部形式

通过 `script` 标签包裹 JavaScript 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 引入方式</title>
</head>
<body>
  <!-- 内联形式：通过 script 标签包裹 JavaScript 代码 -->
  <script>
    alert('嗨，欢迎来传智播学习前端技术！');
  </script>
</body>
</html>
```

#### 2. 外部形式

一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 `script` 标签的 `src` 属性引入

```javascript
// demo.js
document.write('嗨，欢迎来传智播学习前端技术！');
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 引入方式</title>
</head>
<body>
  <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 -->
  <script src="demo.js"></script>
</body>
</html>
```

如果 script 标签使用 src 属性引入了某 .js 文件，那么 标签的代码会被忽略！！！如下代码所示：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 引入方式</title>
</head>
<body>
  <!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 -->
  <script src="demo.js">
    // 此处的代码会被忽略掉！！！！
  	alert(666);  
  </script>
</body>
</html>
```

> 我们将 <script> 放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML。
>
> 如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。
>
> 因此，将 JavaScript 代码放在 HTML页面的底部附近通常是最好的策略。

###  注释和结束符

通过注释可以屏蔽代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法：

#### 1. 单行注释

使用 `// ` 注释单行代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 注释</title>
</head>
<body>
  
  <script>
    // 这种是单行注释的语法
    // 一次只能注释一行
    // 可以重复注释
    document.write('嗨，欢迎来传智播学习前端技术！');
  </script>
</body>
</html>
```

#### 2. 多行注释

使用 `/* */` 注释多行代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 注释</title>
</head>
<body>
  
  <script>
    /* 这种的是多行注释的语法 */
    /*
    	更常见的多行注释是这种写法
    	在些可以任意换行
    	多少行都可以
      */
    document.write('嗨，欢迎来传智播学习前端技术！');
  </script>
</body>
</html>
```

**注：编辑器中单行注释的快捷键为 `ctrl + /`**

#### 3. 结束符

在 JavaScript 中 `;` 代表一段代码的结束，多数情况下可以省略 `;` 使用回车（enter）替代。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 结束符</title>
</head>
<body>
  
  <script> 
    alert(1);
    alert(2);
    alert(1)
    alert(2)
  </script>
</body>
</html>
```

~~~javascript
let num  = 10
~~~

~~~css
div {
    color: red;
}
~~~

> JavaScript 跟 HTML 和 CSS 一样，会忽略【一些】空白符，但是换行符（回车）会被识别成结束符 `;`，因此在实际开发中有许多人主张书写 JavaScript 代码时省略结束符 `;`



###  输入和输出

输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。

举例说明：如按键盘上的方向键，向上/下键可以滚动页面，按向上/下键这个动作叫作输入，页面发生了滚动了这便叫输出。

#### 1. 输出

JavaScript 可以接收用户的输入，然后再将输入的结果输出：

`alert()` 弹出警示对话框

`document.wirte()` 是页面中打印输出，可以写入标签

#### 2. 输入

向 `prompt()` 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1. document.write 是页面中打印输出，如果输出的内容写的是标签，也会被解析成网页元素
        document.write('我愿意')
        document.write('<h1>我愿意</h1>')
        // 2. alert 弹出警示对话框
         alert('黑马')
        // 3. 控制台输出语法 
        console.log('我是用来测试的')
        // 4. 显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字
        prompt('您今年多大了？')
    </script>
</body>

</html>
```

[js输入与输出语句](D:\Java code\3.  javaScript编程\javaScript 基础\day01\04-输入和输出语法.html)

## 变量

> - 变量是计算机中用来存储数据的“容器”，通俗的理解变量就是使用【某个符号】来代表【某个具体的数值】（数据）
>
> - 使用变量时，程序会在内存中申请的一块用来存放数据的小空间，使用完毕后该空间会被垃圾回收机制回收
> - JavaScript 中变量的值决定了变量的数据类型。

### 声明和赋值

#### 声明

声明(定义)变量有两部分构成：声明关键字、变量名（标识）

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 声明和赋值</title>
</head>
<body>
  
  <script> 
    // let 变量名
    // 声明(定义)变量有两部分构成：声明关键字、变量名（标识）
    // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语
    // age 即变量的名称，也叫标识符
    let age;
  </script>
</body>
</html>
```

> 关键字是 JavaScript 中内置的一些英文词汇（单词或缩写），它们代表某些特定的含义，如 `let` 的含义是声明变量的，看到 `let`  后就可想到这行代码的意思是在声明变量，如 `let age;` 
>
> `let` 和 `var` 都是 JavaScript 中的声明变量的关键字，推荐使用 `let` 声明变量！！！
>
> let 与 var 的区别：
>
> var申明的变量不具有块级作用域、let具有块级作用域；`var声明的变量可以为全局变量或者局部变量`
>
> var申明变量，可以重新定义申明的，let不可以；
>
> `var申明的变量，相当于window添加属性`，let直接就是变量
>
> var和let都可以只定义不赋值，此时变量类型为 undefined

#### 赋值

声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 声明和赋值</title>
</head>
<body>
  
  <script> 
    // 声明(定义)变量有两部分构成：声明关键字、变量名（标识）
    // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语
    // age 即变量的名称，也叫标识符
    let age;
    // 赋值，将 18 这个数据存入了 age 这个“容器”中
    age = 18;
    // 这样 age 的值就成了 18
    document.write(age);
    // 可以一次声明多个变量
    let age = 19, name = 'pink老师'
    // 也可以声明和赋值同时进行
    let str = 'hello world!';
    alert(str);
  </script>
</body>
</html>
```

> let 不允许多次声明一个变量，但可以一次声明多个变量  ，let age = 19, name = 'pink老师' ; 
>
>  `如果声明不同变量 但是附相同的值 ，可以简写    let max = min = arr[0], 同 let max=arr[0], min=arr[0]`

连等赋值时   var a = b = c = 9 ；相当于 var a = 9; b = 9; c = 9;  ( b 、c 不声明直接赋值)

```js
/*
			b = 9
			c = 9
			function f1 () {
				// var a = 9;
			    var a = b = c = 9;// var a = 9; b = 9; c = 9;
			    console.log(a);// 9
			    console.log(b);// 9
			    console.log(c);// 9
			}
		 */
			f1();
			console.log(c);// 9
			console.log(b);// 9
			console.log(a);// 报错
			function f1 () {
			    var a = b = c = 9;
			    console.log(a);
			    console.log(b);
			    console.log(c);
			}
```



### 关键字  

JavaScript 使用专门的关键字 `let` 和 `var` 来声明（定义）变量，在使用时需要注意一些细节：

以下是使用 `let` 时的注意事项：

1. 必须先声明再赋值
2. 不允许重复声明
3. 允许同时声明多个变量并赋值
4. JavaScript 中内置的一些关键字不能被当做变量名

以下是使用 `var` 时的注意事项：

2. 允许先赋值后声明
3. 允许重复声明
4. 允许同时声明多个变量并赋值

大部分情况使用 `let` 和 `var` 区别不大，但是 `let` 相较 `var` 更严谨，因此推荐使用 `let`，后期会更进一步介绍二者间的区别。

###  变量名命名规则

关于变量的名称（标识符）有一系列的规则需要遵守：

1. 只能是字母、数字、下划线、$，且不能能数字开头
2. 字母区分大小写，如 Age 和 age 是不同的变量
3. JavaScript 内部已占用于单词（关键字或保留字）不允许使用
4. 尽量保证变量具有一定的语义，见字知义

> - js严格区分大小写
>
> - 所谓关键字是指 JavaScript 内部使用的词语，如 `let` 和`var`，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 变量名命名规则</title>
</head>
<body>
  
  <script> 
    let age = 18; // 正确
    let age1 = 18; // 正确
    let _age = 18; // 正确

    // let 1age = 18; // 错误，不可以数字开头
    let $age = 18; // 正确
    let Age = 24; // 正确，它与小写的 age 是不同的变量
    // let let = 18; // 错误，let 是关键字
    let int = 123; // 不推荐，int 是保留字
  </script>
</body>
</html>
```

> **起名要有意义**
>
> - 遵守小驼峰命名法
>
> - 第一个单词首字母小写，后面每个单词首字母大写。例：userName

### 常量

JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值

- 使用const 声明常量，const 声明的常量也会产生块作用域，不能被 二次赋值，const定义的常量必须初始化赋值

- 开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量

> 常量名都用大写

---

## 数据类型

> 计算机世界中的万事成物都是数据。



计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型：



![image-20220910164300085](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910164300085.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 返回的什么类型  string  number Boolean  undefined object
        console.log(typeof 123)
        console.log(typeof '123')
        console.log(typeof true)
        console.log(typeof undefined)
        console.log(typeof null)
        let num = 10
        console.log(typeof num + '11')
            // console.log('number' + '11')
    </script>
</body>

</html>
```

> 通过 typeof 关键字检测数据类型
>
> - 返回的数据类型有：string  number  boolean   undefined  object

### 数组

- 数组(Array)是一种可以按顺序保存多个数据

![image-20220910163221460](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910163221460.png)

![image-20220910164002484](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910164002484.png)

> - 数组是按顺序保存，所以每个数据都有自己的编号
>
> -  `计算机中的编号从0开始，所以小明的编号为0，小刚编号为1，以此类推`
>
> -  在数组中，数据的编号也叫**索引或下标**
>
> - 数组可以存储任意类型的数据
>
> -  `空数组的声明：let newArr = [] `

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=
    , initial-scale=1.0">
    <title>Document</title>
</head>
	
<body>
    <script>
        let arr = ['马超', '黄忠', '关羽', '张飞', '貂蝉']
        console.log(arr)
        // 取值  数组名[索引]
        console.log(arr[0])
        console.log(arr[4])
    </script>
</body>

</html>
```

#### 1. 遍历数组

![image-20220913162150255](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913162150255.png)

案例：数组求和

需求：求数组 [2,6,1,7, 4] 里面所有元素的和以及平均值

分析： 

①：声明一个求和变量 sum。

②：遍历这个数组，把里面每个数组元素加到 sum 里面。

③：用求和变量 sum 除以数组的长度就可以得到数组的平均值。

```html
 <script>
        // 数组求和案例
        let arr = [2, 6, 1, 7, 4]
        // 求和变量
        let sum = 0
        // 求平均值变量
        let average = 0
        // 遍历数组
        for (let i = 0; i < arr.length; i++) {
            // console.log(arr[i])
            // sum = sum + arr[i]
            // arr[i] 就是数组里面的每个值 比如 2， 3
            sum += arr[i]
        }
        average = sum / arr.length
        document.write(`这个同学的总分是: ${sum}, 平均分是:${average}`)
    </script>
```

案例：数组求最大值

需求：求数组 [2,6,1,77,52,25,7] 中的最大值

分析： 

①：声明一个保存最大元素的变量 max。 

②：默认最大值可以取数组中的第一个元素。

③：遍历这个数组，把里面每个数组元素和 max 相比较。

④：如果这个数组元素大于max 就把这个数组元素存到 max 里面，否则继续下一轮比较。

⑤：最后输出这个 max

```html
  <script>
        let arr = [2, 6, 1, 77, 52, 25, 7]
        // 声明最大值的变量   得到数组元素的方法 数组名[索引号]
        let max = arr[0]
        // 定义最大值索引
        let index = 0
        // 遍历数组 
        for (let i = 1; i < arr.length; i++) {
            // i 是什么？  是序号 1234567  
            // 只不过这个 i序号，正好和 数组的索引号对应
            // i 可以看做是 数组的索引号
            // 得到数组元素的方法 数组名[索引号]  arr[i]
            if (max < arr[i]) {
                max = arr[i]
                //最大值得索引 index
                index = i
            }
        }
        console.log(max, index)
    </script>
```



#### 2. 操作数组

![image-20220913173859894](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913173859894.png)

##### 2.1 数组新增操作

![image-20220913174439129](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913174439129.png)

> `数组.push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度 (重点)`

![image-20220913174507198](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913174507198.png)

> `arr.unshift(新增的内容) 方法将一个或多个元素添加到数组的**开头**，并返回该数组的新长度`

案例：数组筛选

需求：将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组

分析：

①：声明一个新的数组用于存放新数据newArr

②：遍历原来的旧数组， 找出大于等于 10 的元素

③：依次追加给新数组 newArr

```html
    <script>
        let arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
        // 需要一个新的空数组   数组字面量  [] 
        let newArr = []
        // 遍历旧数组
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] >= 10) {
                // console.log(arr[i])
                // 满足条件的，依次追加给新的数组
                // 把 arr[i] 追加给 newArr
                // newArr = arr[i]  不可以
                newArr.push(arr[i])
            }
        }
        console.log(newArr)
    </script>
```

案例：数组去0案例

需求：将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中的 0 去掉后，形成一个不包含 0 的新数组

分析：

①：声明一个新的数组用于存放新数据newArr

②：遍历原来的旧数组， 找出不等于0的元素

③：依次追加给新数组 newArr

```html
 <script>
        let arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
        // 声明新数组
        let newArr = []
        // 遍历旧数组
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] !== 0) {
                // 追加给新的数组
                newArr.push(arr[i])
            }
        }
        console.log(newArr)
    </script>
```

##### 2.2 数组删除元素

![image-20220913180828177](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913180828177.png)

> `数组. pop() 方法从数组中删除最后一个元素，并返回该元素的值`

![image-20220913180857388](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913180857388.png)

> `数组. shift() 方法从数组中删除第一个元素，并返回该元素的值`

![image-20220913180954385](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913180954385.png)

> 数组. splice() 方法 删除指定元素
>
> `start 起始位置:  指定修改的开始位置（从0计数）; deleteCount: 表示要移除的数组元素的个数可选的。 如果省略则默认从指定的起始位置删除到最后`

```html
  <script>
        // 重点删除  arr.splice(从哪里开始删， 删几个)
        let arr = ['red', 'green', 'blue']
        //  我就想把green 删掉
        // 第一个1 是从索引号是1的位置开始删,删除1个
        arr.splice(1,1)
        
        // 参数为0时，默认全部删除
        arr.splice(0)
        console.log(arr)
    </script>
```

#### 3. 冒泡排序

```html
  <script>
        let arr = [2,  4, 3, 5, 1]
        // 1. 外层循环控制  趟数   循环 4次   arr.length - 1
        for (let i = 0; i < arr.length - 1; i++) {
            // 2. 里层的循环 控制 一趟交换几次  arr.length - i - 1 次序
            for (let j = 0; j < arr.length - i - 1; j++) {
                // 交换两个变量
                // arr[j]   arr[j + 1]
                if (arr[j] > arr[j + 1]) {
                    // 比较相邻两个数的大小，先将大值存储，再与小的数交换位置
                    let temp = arr[j]
                    arr[j] = arr[j + 1]
                    arr[j + 1] = temp
                }
            }
        }
        console.log(arr)
    </script>
```

> `冒泡排序是相邻的两个数进行比较，大的数放后，小数在前，每次循环会得到最大的数，并放在数组最后面，下次循环时循环次数会减一`
>
> 排序规律：外层循环的次数为 数组长度 - 1 次 ， 且  i 的初始值必须为 0 (外层循环次数与里层循环次数存在规律)；
>
> 里层循环次数为 数组长度 - i - 1 （ i 初始值必须为 0），每次外循环结束后，里循环的次数减一，因为得到的最大数不参与比较了

#### 4. 数组练习题

求多数组中的最大值

```js
let arr = [
		    	[23, 66, 33, 16],
		    	[19, 21, 49, 66, 123, 36],
		    	[78, 37, 89, 86]
		]
		let max = arr[0][0];
		for (let i = 0; i < arr.length; i++) {
			// arr[i]
			for (let j = 0; j < arr[i].length; j++) {
				if ( max < arr[i][j] ) {
					max = arr[i][j];
				}
			}
		}
		console.log(max);
```

求数组平均值

```js
		let arr = [
		    	[23, 66, 33, 16],
		    	[19, 21, 49, 66, 123, 36],
		    	[78, 37, 89, 86]
		]
		let sum = 0; // 求和变量
		let count = 0; // 循环次数变量，
		for (let i = 0; i < arr.length; i++) {
			// arr[i]又是一个数组
			for (let j = 0; j < arr[i].length; j++) {
				sum = sum + arr[i][j];
				count++;
			}
		}
		let avg = sum / count;
		console.log(avg);
```

###  数值类型

即我们数学中学习到的数字，可以是整数、小数、正数、负数

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 数据类型</title>
</head>
<body>
  
  <script> 
    let score = 100; // 正整数
    let price = 12.345; // 小数
    let temperature = -40; // 负数

    document.write(typeof score); // 结果为 number
    document.write(typeof price); // 结果为 number
    document.write(typeof temperature); // 结果为 number
  </script>
</body>
</html>
```

> - JavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。
>
> - `JS 是弱数据类型，变量到底属于那种类型，只有赋值之后，我们才能确认`
>
> - Java是强数据类型 例如 int a = 3 必须是整数

### 字符串类型

通过单引号（ `''`） 、双引号（ `""`）或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。

注意事项：

1. 无论单引号或是双引号必须成对使用
2. 单引号/双引号可以互相嵌套，但是不以自已嵌套自已
3. 必要时可以使用转义符 `\`，输出单引号或双引号

> `以后字符串拼接推荐使用反引号  `` `
>
> `反引号可以忽略字符串拼接问题，用单双引号包裹文字，如果文字中间需要换行，换行符会被解析为 ； 导致编译报错。使用反引号 `` 可以实现字符串的拼接，以及实现文字换行效果`

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 数据类型</title>
</head>
<body>
  
  <script> 
    let user_name = '小明'; // 使用单引号
    let gender = "男"; // 使用双引号
    let str = '123'; // 看上去是数字，但是用引号包裹了就成了字符串了
    let str1 = ''; // 这种情况叫空字符串
	console.log('我是\'pink德华\'') // 转义符，转义单引号
      
    documeent.write(typeof user_name); // 结果为 string
    documeent.write(typeof gender); // 结果为 string
    documeent.write(typeof str); // 结果为 string
  </script>
</body>
</html>
```

> 必要时可以使用转义符 `\`，输出单引号或双引号。写法 \ '  ,单引号前加 反斜杠

#### ES6 模板字符串

![image-20220910170326971](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910170326971.png)

> `字符串拼接变量时，用 ${} 包住变量，外面用  `` 反引号包裹`
>
> `模板字符串里可以加入html标签， 输入换行符，会被解析为空格， 内存之间会拉开点间距`

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 模板字符串
        let age = 81
        document.write(`我今年${age - 20}岁了`)
        // document.write('我是一个字符串')
        //模板字符串中，标签可以换行 
        document.write(`
        <div>123</div>
        <p>abc</p>
        `)
    </script>
</body>

</html>
```

**页面输出用户信息案例**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        span {
            color: pink;
        }
    </style>
</head>

<body>
    <script>
        // 1. 输入
        let uname = prompt('请输入您的名字:')
        let age = prompt('请输入您的年龄:')
        // 2. 输出，可以在变量前加标签修改样式
        document.write(`大家好，我叫<span>${uname}</span>，今年${age}岁了`)
    </script>
</body>

</html>
```

>  document.write(`大家好，我叫<span>${uname}</span>，今年${age}岁了`)
>
> 可以在变量前加标签修改样式

### 布尔类型

表示肯定或否定时在计算机中对应的是布尔类型数据，它有两个固定的值 `true` 和 `false`，表示肯定的数据用 `true`，表示否定的数据用 `false`。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 数据类型</title>
</head>
<body>
  
  <script> 
    //  pink老师帅不帅？回答 是 或 否
    let isCool = true; // 是的，摔死了！
    isCool = false; // 不，套马杆的汉子！

    document.write(typeof isCool); // 结果为 boolean
  </script>
</body>
</html>
```

###  undefined

未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JavaScript 基础 - 数据类型</title>
</head>
<body>
  
  <script> 
    // 只声明了变量，并末赋值
    let tmp;
    document.write(typeof tmp); // 结果为 undefined
  </script>
</body>
</html>
```

> **工作中的使用场景：**
>
> 我们开发中经常声明一个变量，等待传送过来的数据。
>
> 如果我们不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来。

### null（空类型）

![image-20220910173112014](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910173112014.png)

> console.log(typeof null)
>
> null的数据类型属于对象，返回 object

## 类型转换

> 理解弱类型语言的特征，掌握显式类型转换的方法

在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。

### 隐式转换

某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。

![image-20220910175352183](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910175352183.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // let num = prompt('请输入一个数字')
        // console.log(num, typeof num)
        // 内部悄悄的把 18 转换为了字符串的 '18'
        console.log('pink老师' + 18)
        console.log(10 + '10')  //  1010
        // - *  / 把 字符串的 '10' 转换为 数字型 10
        console.log(10 - '10') // 0
        
        let num = '10'
        console.log(num)
        // +号作为正号解析可以转换成Number 
        console.log(+num)
        // - 号也可以将字符串转为数字型，但是会变成负数 -10
        console.log(-num)
        console.log(10 + +'10')
    </script>
</body>

</html>
```

> - `i++ 、 i-- 存在隐式转换， 字符串数字 进行加加或者减减 都会转换为 数字进行运算`
>
> - \+ 号两边只要有一个是字符串，都会把另外一个转成字符串
>
> - 除了+以外的算术运算符 比如 - * / 等都会把数据转成数字类型
>
> - +号作为正号解析可以转换成Number , - 号也可以将字符串转为数字型，但是会变成负数

### 显式转换

编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。

![image-20220910180344039](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910180344039.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            width: 100px;
        }
    </style>
</head>

<body>
    <script>
        // Number(数据)，可以保留小数
        console.log(Number('10.01'))
        // 转换为数字型，只保留整数，没有四舍五入
        console.log(parseInt('10'))
        console.log(parseInt('10.111'))
        console.log(parseInt('10.999px'))
        // 转换为数字型，会保留小数
        console.log(parseFloat('10.999'))

        // 区别：
        // 1.Number() 只能放数字类型的字符，不能放abc这样的
        // 否则返回的是 NaN   not A number
        console.log(Number('10.01abc'))

        // parseFloat 经常用于过滤px单位
        // console.log(parseFloat('10.01abc'))
        console.log(parseFloat('100px'))


    </script>
</body>

</html>
```

> `Number() 只能放数字类型的字符，不能放abc这样的,当转换失败时会提示 NAN（不是一个数字）`
>
> `parseInt 转换为数字型，只保留整数,  可以用于去除 价格后的单位符号`：parselnt('5$')  输出结果 为 5 
>
> console.log(parseFloat('100px'))
>
> - parseFloat 经常用于过滤px单位,输出结果为100

![image-20220910181412039](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220910181412039.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        console.log(String(10))
        let age = 10
        console.log(age.toString())
        // 括号里面如果是2 转换为 二进制
        console.log(age.toString(2))
    </script>
</body>

</html>
```

## 运算符

### 算术运算符

![image-20220911120513172](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911120513172.png)

```html
 <script>
        let r= 0.03%5  // 0.03
        let s= 6%6   // 0
        let l= 23%7  // 2
        document.write(`r的值：${r} <br> s的值：${s} <br> l的值：${l}
        `)
    </script>
```

> `对比 0小的数  取余值都为 它本身,比如 0.03 取余 值 为 0.03`
>
> 取余就是判断该数能否被正常，能则取余值为 0 

#### 1. JavaScript算术运算符执行的优先级顺序

![image-20220911121509425](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911121509425.png)



### 赋值运算符

![image-20220911162135067](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911162135067.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
         let num = 18
       // num = num + 1
         num += 1
         //num 每次加1 ，控制台输出19
        console.log(num)

        // 两个变量的 把i加到 sum 里面去
        let i = 1
        let sum = 0
        // sum = sum + i
        sum += i
    </script>
</body>

</html>
```

### 一元运算符

![image-20220911162549245](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911162549245.png)

#### 1. 自增运算的用法

单独使用

![image-20220911162745142](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911162745142.png)

参与运算

![image-20220911163217283](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911163217283.png)

> 前置自增和后置自增单独使用时没有区别
>
> 参与运算时，++在前会先加，++在后则后加

#### 2. 拓展 面试题

```html
 <script>
        let i = 1
        // 1 +(2+1)+3
        console.log(i++ + ++i + i)
    </script>
```

> console.log(i++ + ++i + i)， 结果为7；
>
> i++ ，i的值为 1，当检测到运算符+后，执行 i+1 ；此时 ++i 里的 i 值变为2 ，执行+1后参加运算，最后的 i 变为3

### 比较运算符

![image-20220911171731400](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911171731400.png)

![image-20220911173026228](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911173026228.png)

```html
    <script>
        console.log(3 > 5) // false
        console.log(5 >= 5) //  true
        console.log(5 == 5)
        // == 只要值一样就是true  不管数据类型
        console.log(5 == '5') //true
        console.log(5 == 'pink') //false
        // === 以后判断要用  ===  开发常用   要求值和数据类型都一样
        console.log(5 === 5) //true
        console.log(5 === '5') //false
        // 特殊情况
        // 字符串比较，是比较的字符对应的ASCII码里的十进制数
        console.log('pink' > 'red') //false
        console.log('pink' > 'pin') // true
        //NaN不等于任何值,任何值与其比较都为false
        console.log(1 === NaN)  //false 
        console.log(NaN === NaN) // false
        // 尽量不要比较小数，因为小数有精度问题
        console.log(0.1 + 0.2 === 0.3) // false

        //不同类型之间比较会发生隐式转换,字符串会转换为数字
        console.log(3 > '2') // true
    </script>
```

> == 只要值一样就是true  不管数据类型;
>
> === 需要判断类型和值都相等，常用
>
> 字符串比较，是比较的字符对应的ASCII码里的十进制数，通常是先比较第一位，前面几位都相等的情况下，位数多的更大
>
>  NaN不等于任何值,任何值与其比较都为false
>
> 尽量不要比较小数，因为小数有精度问题
>
> `不同类型之间比较会发生隐式转换,字符串会转换为数字`

### 逻辑运算符

逻辑运算符用来解决多重条件判断

![image-20220911173446378](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911173446378.png)

```html
 <script>
	// 逻辑与 一假则假
         console.log(true && true) // true
         console.log(false && true) // false
        // 逻辑或  一真则真
         console.log(false || true)  // true
        console.log(false || false) // false
        // 逻辑非  取反
        console.log(!true) // false
        console.log(!false) // true
     </script>
```

#### 1. 逻辑运算符里的短路

![image-20220911181751270](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911181751270.png)

> 在逻辑运算符里 ，有5个值是当 false 来看的 ：  false  数字0   ' '   undefined   null  ；其他的都为true
>
> 逻辑运算符里 只有用比较运算符时，返回的是 false 或者true；
>
> &&  左边为false 则短路， 右边不再判断，输出左边的结果，如果为true，则输出右边结果； ||  左边为true则短路，右边不再判断，输出左边的结果，如果为false，则输出右边结果

### 运算符优先级

![image-20220911184224806](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911184224806.png)

![image-20220911185702361](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911185702361.png)

> 一元运算符里面的逻辑非优先级很高
>
> 逻辑与比逻辑或优先级高

## 语句

### 程序三大流程控制语句

![image-20220911190409159](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911190409159.png)



### 分支语句

#### 1. if 分支语句

![image-20220911194650353](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911194650353.png)

> 小括号内的结果若不是布尔类型时，会发生隐式转换转为布尔类型; `小括号里为   0  ' '  undefined  null  NaN  ，则会隐式转换为 false`，若为其他数字、字符串 则为 true

1.1 双分支if语法

![image-20220911195241763](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911195241763.png)

1.2 多分支if语法

![image-20220911202152986](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220911202152986.png)

```html

    <script>
        // 计算工资
        // 1. 用户输入工龄
        // let age = +prompt('请输入工龄')
        // let money = 10000
        // 2. 执行分支语句
        // if (age >= 1) {
        //     alert(`您实发工资:${money + 2000}`)
        // } else {
        //     alert(`您实发工资:${money}`)
        // }
        
        // 2. 计算闰年
        // 2.1 用户输入年份
        let year = +prompt('请输入年份：')
        // 2.2 执行分支语句
        if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
            alert(`${year}年是闰年`)
        } else {
            alert(`${year}年是平年`)
        }
    </script>

```

#### 2. 三元运算符

![image-20220912090612550](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220912090612550.png)

案例：数字补0

需求：用户输入1个数，如果数字小于10，则前面进行补0， 比如 09 03 等

分析： 

①：为后期页面显示时间做铺垫

②：利用三元运算符 补 0 计算

```html
   <script>
        // 1. 用户输入数字
        let num = prompt('请您输入一个数字')
        // 2. 判断条件是 小于 10  则数字前面 + '0'   01 否则 不补
        // let t = num >= 10 ? num : '0' + num
        let t = num < 10 ? '0' + num : num
        document.write(t)
    </script>
```

案例：判断2个数的最大值

需求：用户输入2个数，控制台输出最大的值

分析： 

①：用户输入2个数

②：利用三元运算符输出最大值

```html
 <script>
        // 两个字符比较，前面需要加上 +号
        let num1 = +prompt('请输入第一个数')
        let num2 = +prompt('请输入第二个数')
        let re = num1 > num2 ? num1 : num2
        document.write(`两个数最大的那个是${re}`)
    </script>
```

#### 3. switch语句

![image-20220912093152902](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220912093152902.png)

> switch case语句一般用于等值（===  比较值与类型） 判断, 不适合于区间判断
>
> switch case一般需要配合break关键字使用 没有break会造成case穿透

案例：简单计算机

需求：用户输入2个数字，然后输入 + - * / 任何一个，可以计算结果

分析：

①：用户输入数字

②：用户输入不同算术运算符，可以去执行不同的运算 (switch)

```html
  <script>
        // 1. 用户输入数字   还有一次 运算符
        let num1 = +prompt('请您输入第一个数:')
        let num2 = +prompt('请您输入第二个数:')
        let sp = prompt('请您输入+ - * / 运算')
        // 2. 根据不同的运算符计算不同的结果 switch
        switch (sp) {
            case '+':
                alert(`您选择的是加法，结果是: ${num1 + num2}`)
                break
            case '-':
                alert(`您选择的是减法，结果是: ${num1 - num2}`)
                break
            case '*':
                alert(`您选择的是乘法，结果是: ${num1 * num2}`)
                break
            case '/':
                alert(`您选择的是除法，结果是: ${num1 / num2}`)
                break
            default:
                alert(`你输了啥？ 请输入+ - * / `)
        }
    </script>
```

### 循环语句

#### 断点调试

![image-20220912101332173](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220912101332173.png)

#### while循环

循环：重复执行某段代码， 而 while : 在…. 期间

![image-20220912102648420](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220912102648420.png)

> 跟if语句很像，都要满足小括号里的条件为true才会进入执行代码
>
>  while大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若满足又执行大括号里的代码，然后再回到
>
> 小括号判断条件，直到括号内条件不满足，即跳出

![image-20220912102858671](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220912102858671.png)

案例：计算1-100之间的所有偶数和 

分析：

1. 声明累加和的变量 sum

2. 首先利用if语句把 i 里面是偶数筛选出来

3. 把 筛选的 i 加到 sum 里面

```html
<script>
//. 求 1~100 之间的偶数累加和
        let i = 1
        let sum = 0
        while (i <= 100) {
            if (i % 2 === 0) {
                // 此时 i 一定是偶数
                sum = sum + i
            }
            // 不管你是偶数还是奇数我都要++
            i++
        }
        console.log(sum)  
</script>
```

案例：页面弹框

需求：页面弹出对话框，‘你爱我吗’，如果输入‘爱’，则结束，否则一直弹出对话框

分析：

1. 循环条件永远为真，一直弹出对话框

2. 循环的时候，重新让用户输入

3. 如果用户输入的是： 爱，则退出循环 （break）

```html
    <script>
        while (true) {
            let str = prompt('如果是我DJ，你还爱我吗?')
            if (str === '爱') {
                alert('我也爱你啊~~')
                break
            }
            alert('你好好想想')
        }
    </script>
```

#### for循环

![image-20220913114341319](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913114341319.png)

案例： 求1-100之间所有的偶数和

```html
<script>
	 let sum = 0   // 值
         for (let i = 1; i <= 100; i++) {
             // 筛选偶数
           if (i % 2 === 0) {
                 // sum = sum + i
                 sum += i
            }
         }
        document.write(sum)
</script>
```

案例：循环数组打印输出

需求： 请将 数组 [‘马超’，‘赵云’， ‘张飞’, ‘关羽‘，’黄忠’] 依次打印出来

```html
<script>
    let arr = ['马超', '赵云', '张飞', '关羽', '黄忠', 'pink老师']
        // 利用循环的方式
        document.write(arr.length)
        // 2. arr.length  数组的长度  通过他可以告诉我们数组里面有几个元素
        for (let i = 0; i < arr.length; i++) {
            document.write(`名字是: ${arr[i]} <br>`)
</script>
```

##### 1. 循环嵌套

![image-20220913123918817](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913123918817.png)

案例：假如每天记住5个单词，3天后一共能记住多少单词？

![image-20220913124519495](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913124519495.png)

```html
  <script>
        // 记忆单词案例
        // 分析
        // 1. 外面的循环 记录第n天 
        for (let i = 1; i < 4; i++) {
            document.write(`第${i}天 <br>`)
            // 2. 里层的循环记录 几个单词
            for (let j = 1; j < 6; j++) {
                document.write(`记住第${j}个单词<br>`)
            }
        }
    </script>
```

案例：页面中打印出5行5列的星星

![image-20220913124628990](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913124628990.png)

```html
  <script>
        let num1 = prompt('请输入行数')
        let num2 = prompt('请输入列数')
        // 外层行  里层每个的几个星星
        for (let i = 1; i <= num1; i++) {
            for (let j = 1; j <= num2; j++) {
                document.write('★')
            }
            // 五个星星打完了，再换行
            document.write('<br>')
        }
    </script>
```

案例：九九乘法表

![image-20220913130445967](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220913130445967.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            display: inline-block;
            height: 25px;
            line-height: 25px;
            margin: 5px;
            background-color: pink;
            padding: 0 10px;
            border: 1px solid hotpink;
            color: deeppink;
            border-radius: 5px;
            box-shadow: 2px 2px 2px rgba(0, 0, 0, .2);
        }
    </style>
</head>
<body>
    <script>
        // 外层打印几行
        for (let i = 1; i <= 9; i++) {
            // 里层打印几个星星
            for (let j = 1; j <= i; j++) {
                // 模板字符串中添加标签，修改样式
                document.write(`
                <div> ${j} x ${i} = ${j * i} </div>
                `)
            }
            document.write('<br>')
        }
    </script>
</body>

</html>
```

[网页特效：九九乘法表](D:\Java code\3.  javaScript编程\javaScript 基础\day03\08-99乘法表.html)

#### 循环退出

- continue：结束本次循环，if 语句后面的代码不再执行，并继续下次循环

- break：结束所在的循环，循环外代码可以执行

- return：结束整个方法，循环外的代码不再执行 （ 效果最强）

```html
  <script>
        // 我们要打印吃包子
        let i = 1
        while (i <= 6) {
            if (i === 3) {
                i++
                // 当 i 为3 时，结束本次循环，回到循环体进行判断， 继续下一次循环
                // continue
                
                // 结束所有循环
                break
            }
            document.write(`我要吃第${i}个包子 <br>`)
            i++
        }
    </script>
```

## 函数

- **函数：**function，是被设计为执行特定任务的代码块

- 函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。

### 函数的使用

![image-20220914101909745](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914101909745.png)

#### 1. 函数名命名规范

![image-20220914102046112](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914102046112.png)

> `声明（定义）的函数必须调用才会真正被执行，使用 () 调用函数`

#### 2. 函数体

![image-20220914102630183](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914102630183.png)

> `将相似代码抽取 并 **封装** 成函数，方便代码的重复使用`

### 函数传参

**有参数的函数声明和调用**

![image-20220914103449489](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914103449489.png)

![image-20220914103626782](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914103626782.png)

> 调用函数时，需要传入几个数据就写几个，用逗号隔开

#### 1. 形参和实参

![image-20220914103932382](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914103932382.png)

> `形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）`
>
> ` 实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）`
>
> 形参可以理解为是在这个函数内声明的变量（比如 num1 = 10）实参可以理解为是给这个变量赋值
>
> 开发中尽量保持形参和实参个数一致
>
> 我们曾经使用过的 alert('打印'), parseInt('11'), Number('11') 本质上都是函数调用的传参

形参赋值的特殊写法

```html
<script>
// x 和 y 可以看做是 函数内部的局部变量
        // 调用的时候会有个内部判断是否有参数传递过来
        // 没有参数 则 执行 x = 0
        // 有参数，则执行 实参赋值
        function fn(x = 0, y = 0) {
            console.log(x + y)
        }
        fn()
        fn(3, 5)
</script>
```

> `函数形参里可以附上初始值，当调用函数时，未传递参数则显示默认值`

调用方法未赋值的情况

```html
  <script>
        // 如果一个变量没有赋值，则默认为  undefined
        // underfined 除了 与字符串拼接，其他情况都是NAN
        document.write(undefined + 10)
        document.write(undefined + true)
        document.write(undefined + undefined)
        document.write(undefined + null)
        document.write(undefined + 'pink') //   打印结果  undefinedpink

        // 什么时候当假看  0  undefined  null  '' false  NaN
        document.write('<br>-------------------------------')
        
        function getSum(x, y) {
            // x = 1 
            // document.write(x)
            // document.write(x + y)
            // 我们想要：如果调用的时候，我们没有传递实参，则默认为 0
            x = x || 0
            y = y || 0
            document.write(x + y)
        }
        getSum()
        getSum(1, 2)
    </script>

```

> `如果一个变量没有赋值，则默认为  undefined ; 如果调用函数时，没有赋值，同样参数类型为undefinded`
>
> `underfined 除了 与字符串拼接，其他情况都是NAN, 当传入的参数少于形参时，也会出现 NAN`

案例：函数封装-求学生总分

需求：学生的分数是一个数组,计算每个学生的总分

分析：

①： 封装一个求和函数

②： 传递过去的参数是一个数组

③： 函数内部遍历数组求和

```html
  <script>
        // 求学生总分
        // 声明函数
        function getScore(arr) {
            // arr = [99, 10, 100]
            let sum = 0
            for (let i = 0; i < arr.length; i++) {
                sum += arr[i]
            }
            document.write(sum)
        }
        // 调用函数
        getScore([99, 10, 100])
        getScore([100, 100, 100])
    </script>
```

### 函数返回值

有返回值函数的概念：

- 当调用某个函数，这个函数会返回一个结果出来

- 这就是有返回值的函数

![image-20220914114420680](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914114420680.png)

**用return返回数据**

![image-20220914114622213](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914114622213.png)

> `函数可以没有 return，这种情况函数默认返回值为 undefined`
>
> 在函数体中使用 return 关键字能将内部的执行结果交给函数外部使用 , 一般有返回值的函数都是赋值给一个变量进行接收
>
> 函数内部只能出现 1 次 return，并且 return 后面代码不会再被执行，所以 return 后面的数据不要换行写 
>
> return会立即结束当前函数

return 返回多个值

```html
<script>
        function fn(x, y) {
            let jia = x + y
            let jian = x - y
            // return jia, jian 结果值返回了 jian 因为return只能返回一个值
            //想要返回多个值，可以用数字存储
            return [jia, jian]
        }
        let re = fn(1, 2)   //  [3, -1]
        document.write(`相加之后的结果是：${re[0]},相减之后的结果是: ${re[1]} `)
    </script>
```

> `因为return只能返回一个值,想要返回多个值，可以用数字存储`

求一个数组最大值和最小值

```html
  <script>
        // 求一个数组最大值和最小值
        function getArrMaxAndMin(arr) {
            // 1.声明一个最大值变量和最小值变量
            let max = min = arr[0]
            // console.log(max, min)
            // 2. 遍历循环 得到最大值和最小值
            for (let i = 1; i < arr.length; i++) {
                if (max < arr[i]) {
                    max = arr[i]
                }
                if (min > arr[i]) {
                    min = arr[i]
                }
                // max < arr[i] ? max = arr[i] : max
                // min > arr[i] ? min = arr[i] : min

                // max = max < arr[i] ? arr[i] : max
                // min = min > arr[i] ? arr[i] : min

            }
            // 3. 返回值最大值和最小值
            return [max, min]
        }
        let value = getArrMaxAndMin([1, 5, 8, 2, 0])
        // value = [8,0]
        document.write(`数组的最大值是: ${value[0]}, 数组里面的最小值是： ${value[1]}`)
    </script>

```

### 作用域

- 作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。
- 作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

![image-20220914161441724](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914161441724.png)

> 1. 全局作用域。函数外部或者整个script 有效 ，`定义变量可以不写let，那么默认的就是全局变量  ，`var 不会产生块作用域 ，声明的变量为全局变量，且可以重复声明
>
> 2. 局部作用域。也称为函数作用域，函数内部有效，局部作用域里的变量也称为局部变量;`函数内部的形参可以看做是局部变量, 当函数执行完毕后，函数内部的变量实际被清空了`
>
> 3. 块级作用域。 { } 内有效   ，if 或者 for 语句里的变量属于 块级变量
>
> 4. `如果函数内部或者块级作用域内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐但是有一种情况`

#### 1. 变量访问原则-作用域链

- `在函数被执行时，会优先查找当前函数作用域中查找变量`，如果当前作用域查找不到则会`依次逐级查找父级作用域`直到全局作用域（采取就近原则的方式从里到外一层层向上链式查找）

![image-20220914164017571](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914164017571.png)

作用域案例

```js

		let num = 1;
		function f1 () {
			let num = 2;
			function f2 () {
				num = 3; // 将 let num = 2 改为 3
			}
			f2();
		}
		f1();
		console.log(num);  // 打印：1 
	-------------------------------------------------------------------------------------	
		let n = 123;
		function f1 () {
			n = 456;
			function f2 () {
				let n = 789
			}
			f2();
		}
		f1();
		console.log(n); // 打印： 456 
	------------------------------------------------------------------------------------------------
		let k = 1;
		function f1 () {
			let k = 9;
			function f2 () {
				console.log(k); // 打印：9  
			}
			f2();
		}
		f1();
```

> console 打印 的 num 值 为20
>
> 

### 匿名函数

![image-20220914164937721](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914164937721.png)

将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为函数表达式

![image-20220914165310053](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914165310053.png)

#### 1. 立即执行函数

![image-20220914170343321](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220914170343321.png)

```html
 <script>
 (function (x, y) {
          console.log(x + y)
         })(1, 2)
</script>
```

> `第一个小括号放的 形参  第二个小括号放的是实参`
>
> `多个立即执行函数要用 ; 隔开，要不然会报错`

## 对象

- 对象（object）：JavaScript里的一种数据类型

- 可以理解为是一种无序的数据集合

- 用来描述某个事物，的静态特征 (属性 ) 或者动态行为 (方法 )

### 对象的使用

![image-20220915112117143](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915112117143.png)

![image-20220915112142609](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915112142609.png)

![image-20220915112218195](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915112218195.png)

> `属性都是成 对出现的，包括属性名和值，它们之间使用英文 : 分隔 ,  多个属性用逗号 隔开  `

![image-20220915113926821](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915113926821.png)

> 使用方括号时 属性名 外加上单引号

![image-20220915115210563](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915115210563.png)

> `方法是由方法名和 匿名函数 两部分构成，它们之间使用 : 分隔`
>
> `方法是依附在对象中的函数` 
>
> 方法名可以使用 "" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等

![image-20220915115648196](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915115648196.png)

> 通过 对象名 . 方法名() 调用 ;  千万别忘了给方法名后面加小括号  

### 对象的操作

![image-20220915120237619](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220915120237619.png)

对象的增删改查

```html
   <script>
        let obj = {
            uname: '小明',
            age: 18

        }
        console.log(obj.age)
        // 修改  对象.属性 =  新值
        obj.age = 81
        console.log(obj)
        
        // 新增一个属性  js 可以非常方便的动态新增属性或者方法
       
        // 会去对象里面找是否有 sex这个属性，如果有则修改，没有则新增这个属性
        obj.sex = '男'
        obj.sing = function () {
            console.log('hi')
        }
       //  dir  可以打印出 对象里的方法
        console.dir(obj)

        // 删除 (了解)
        delete obj.uname
        console.dir(obj)
    </script>
```

> ` js 可以非常方便的动态新增属性或者方法 ,如果有则修改，没有则新增`
>
> 无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。不一样是则是新增的属性或者方法

### 对象的遍历

- 对象没有像数组一样的length属性,所以无法确定长度

- 对象里面是无序的键值对, 没有规律. 不像数组里面有规律的下标

![image-20220916102702372](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220916102702372.png)

```html
    <script>
        let obj = {
            uname: '小明',
            age: 18,
            sex: '男'
        }
        // for  in  循环语句
        // 语法
        // for (let k in 对象名) {}  重点
        // k 变量   k  或者  key    value  
        for (let k in obj) {
            console.log(k)  // 属性名
            // console.log(obj.k)  // obj.k 意思是 obj里面的k属性
            // console.log(obj['k'])
            console.log(obj[k])  // 属性值 

            // 为什么这么写？
            // k  ===  'uname'   === 'age'  === 'sex'
            // // obj.k
            // // obj['uname']
            // obj['sex']  === 18
        }
    </script>
```

> `k 属于变量，指对象的属性名， obj [k] 是 获得 属性值` ； 不能通过 obj .k  得到属性值
>
> 使用 for in 方法遍历 数组时， k指代数组下标

### 内置对象

#### 1. Math

![image-20220916162920904](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220916162920904.png)

```html
 <script>
        console.log(Math.PI)  //  圆周率    π  
        console.log(Math.random())  //  随机数  随机抽奖  随机点名
        // 返回的是小数  但是能得到 0  得不到 1
        // 向上取整  返回的整数
        console.log(Math.ceil(1.1))  // ceil  2
        console.log(Math.ceil(1.5))  // ceil  2
        console.log(Math.ceil(1.9))  // ceil  2
        // 向下取整  返回的整数  floor  
        console.log(Math.floor(1.1))  // floor  1
        console.log(Math.floor(1.5))  // floor  1
        console.log(Math.floor(1.9))  // floor  1
        console.log('-------------------------------')
        // round 就近取整( .5往大取证)  返回的整数   
        console.log(Math.round(1.1))  // round  1
        console.log(Math.round(1.5))  // round  2
        console.log(Math.round(1.9))  // round  2
        console.log('-------------------------------')
        console.log(Math.round(-1.1))  // round  -1
        console.log(Math.round(-1.5))  // round  -1
        console.log(Math.round(-1.9))  // round  -2

        // 最大值和最小值
        console.log(Math.max(1, 5, 9, 45))
        console.log(Math.min(1, 5, 9, 45))
    </script>
```

> `round 四舍五入取整时，  .5  则 往大数取整 ，比如1.5 取值 2， - 1.5 则取值为1  `：  console.log(Math.round(-1.5))  // round  -1
>
> 但是如果是 -1.6 则取值为 -2 ，往小的数取整

![image-20220916162947900](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220916162947900.png)

```html
  <script>
        // 求得是 N - M 之间的一个随机数公式
        // let random = Math.floor(Math.random() * (10 - 1 + 1)) + 1
        // console.log(random)
        // 封装一个随机数函数  min 到  max  
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min
        }
        let random = getRandom(1, 10)
        console.log(random)
        let random1 = getRandom(1, 50)
        console.log(random1)
    </script>
```

> `Math.floor(Math.random() * (max - min + 1)) + min  ； 生成的随机数包括最大值和最小值`
>
> `Math.floor(Math.random() * (max - min )) + min ； 生成的随机数 包括最小值 不包括最大值`

案例：随机点名

需求：请把 [‘赵云’, ‘黄忠’, ‘关羽’, ‘张飞’, ‘马超’, ‘刘备’, ‘曹操’] 随机显示一个名字到页面中

分析：

①：利用随机函数随机生成一个数字作为索引号

②： 数组[随机数] 生成到页面中

③：数组中删除刚才抽中的索引号

```html
<script>
        // 随机数
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min
        }
        // 声明一个数组
        let arr = ['赵云', '黄忠', '关羽', '张飞', '马超', '刘备', '曹操', 'pink老师']

        // 生成1个随机数 作为数组的索引号
        let random = getRandom(0, arr.length - 1)
        // console.log(random)
        document.write(arr[random])

        // 之后删除这个 人的名字
        // arr.splice(从哪里开始删， 删几个)
        arr.splice(random, 1)
        console.log(arr)
    </script>
```

### 案例：学生信息表格

需求：根据以上数据渲染生成表格

分析：

1. 打印表格 头部和尾部

2. 中间的行遍历数组，然后填充对象数据

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        table {
            width: 600px;
            text-align: center;
        }
        table,
        th,
        td {
            border: 1px solid #ccc;
            border-collapse: collapse;
        }
        caption {
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: 700;
        }
        tr {
            height: 40px;
            cursor: pointer;
        }

        table tr:nth-child(1) {
            background-color: #ddd;
        }

        table tr:not(:first-child):hover {
            background-color: #eee;
        }
    </style>
</head>

<body>
    <h2>学生信息</h2>
    <p>将数据渲染到页面中...</p>

    <script>
        // 定义一个存储了若干学生信息的数组
        let students = [
            { name: '小明', age: 18, gender: '男', hometown: '河北省' },
            { name: '小红', age: 19, gender: '女', hometown: '河南省' },
            { name: '小刚', age: 17, gender: '男', hometown: '山西省' },
            { name: '小丽', age: 18, gender: '女', hometown: '山东省' },
            { name: '晓强', age: 18, gender: '女', hometown: '山东省' }
        ]

        // 第一步 打印表格的头部和尾部
        document.write(`
         <table>
            <caption>学生列表</caption>
            <tr>
                <th>序号</th>
                <th>姓名</th>
                <th>年龄</th>
                <th>性别</th>
                <th>家乡</th>
            </tr>
        `)
        // 中间遍历行数  原则就是有几条数据，我就遍历几次

        for (let i = 0; i < students.length; i++) {
            document.write(`
            <tr>
                <td>${i + 1}</td>
                <td>${students[i].name}</td>
                <td>${students[i].age}</td>
                <td>${students[i].gender}</td>
                <td>${students[i].hometown}</td>
            </tr>
            `)
        }
        // 尾部
        document.write(`
         </table>
        `)
    </script>
</body>

</html>
```

[网页特效：学生信息表格](D:\Java code\3.  javaScript编程\javaScript 基础\day05\09-学生信息表案例.html)

---

## js基础案例

---

### 使用js改变按钮颜色

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .pink {
            background-color: pink;
        }
    </style>
</head>

<body>
    <button class="pink">按钮</button>
    <button>按钮</button>
    <button>按钮</button>
    <button>按钮</button>
    <script>
        let btns = document.querySelectorAll('button')

        for (let i = 0; i < btns.length; i++) {
            btns[i].addEventListener('click', function () {
                document.querySelector('.pink').className = ''
                this.className = 'pink'
            })
        }
    </script>
</body>

</html>
```

[改变按钮颜色](D:\Java code\3.  javaScript编程\javaScript 基础\day01\01-体验js.html)

### 用户订单信息案例

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    table {
      margin: 0 auto;
      text-align: center;
      /* 为表格设置合并边框模型： */
      border-collapse: collapse;
    }

    table th,
    td {
      border: 1px solid #000;
      padding: 15px;

    }

    table caption {
      margin: 15px 0;
    }
  </style>
</head>

<body>

  <script>
    // 1. 输入 price num  address 三个变量
    // 用变量接收时，进行隐式转换，将字符串转换为数字  
    let price = +prompt('请输入商品价格:')
    let num = +prompt('请输入购买的数量:')
    let address = prompt('请输入收货的地址:')
    let total = price * num
    // 2. 渲染表格 用模板字符串显示数据
    document.write(`
      <table>
      <caption>
        <h2>订单确认</h2>
      </caption>
      <tr>
        <th>商品名称</th>
        <th>商品价格</th>
        <th>商品数量</th>
        <th>总价</th>
        <th>收货地址</th>
      </tr>
      <tr>
        <td>小米手机青春PLUS</td>
        <td>${price}元</td>
        <td>${num}</td>
        <td>${total}元</td>
        <td>${address}</td>
      </tr>
    </table>
    `)
  </script>
</body>

</html>
```

> // 用变量接收时，进行隐式转换，将字符串转换为数字  
>     let price = +prompt('请输入商品价格:')

[网页特效：用户订单信息案例](D:\Java code\3.  javaScript编程\javaScript 基础\day01\22-综合案例.html)

### 简易ATM取款机案例

需求：用户可以选择存钱、取钱、查看余额和退出功能

分析：

1. 循环的时候，需要反复提示输入框，所以提示框写到循环里面

2. 退出的条件是用户输入了 4，如果是4，则结束循环，不在弹窗

3. 提前准备一个金额预先存储一个数额

4. 取钱则是减法操作， 存钱则是加法操作，查看余额则是直接显示金额

5. 输入不同的值，可以使用switch来执行不同的操作

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1. 不断的弹出对话框
        // 3. 金额的变量
        let money = 100
        while (true) {
            let str = prompt(`请您选择操作:
                1. 存钱
                2. 取钱
                3. 查看余额
                4. 退出
            `)
            // 2. 除非输入的是4 则退出循环  break
            if (str === '4') {
                break
            }
            // 4. switch 加减操作,switch 里的break 不会结束外层循环
            switch (str) {
                case '1':
                    let cun = +prompt('请您输入存钱的金额:')
                    // money = money + cun 
                    money += cun
                    break
                case '2':
                    let qu = +prompt('请您输入取钱的金额:')
                    money -= qu
                    break
                case '3':
                    alert(`您卡上的余额是${money}元`)
                    break
                default:
                    alert('请输入1 - 4 的选项')
                    break
            }
        }
    </script>
</body>

</html>
```

> `switch 里的break 不会结束外层循环,只能结束当前 switch 方法`

[网页特效：简易ATM取款机案例](D:\Java code\3.  javaScript编程\javaScript 基础\day02\21-综合案例-ATM取款机.html)

### 根据数据生成柱形图

需求： 用户输入四个季度的数据，可以生成柱形图

分析：

①：需要输入4次，所以可以把4个数据放到一个数组里面

利用循环，弹出4次框，同时存到数组里面

②：遍历改数组，根据数据生成4个柱形图，渲染打印到页面中

 柱形图就是div盒子，设置宽度固定，高度是用户输入的数据

div里面包含显示的数字和 第n季度

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .box {
            display: flex;
            width: 700px;
            height: 300px;
            border-left: 1px solid pink;
            border-bottom: 1px solid pink;
            margin: 50px auto;
            justify-content: space-around;
            align-items: flex-end;
            text-align: center;
        }

        .box>div {
            display: flex;
            width: 50px;
            background-color: pink;
            flex-direction: column;
            justify-content: space-between;
        }
        .box div span {

            margin-top: -20px;
        }

        .box div h4 {
            margin-bottom: -35px;
            width: 70px;
            margin-left: -10px;
        }
    </style>
</head>

<body>

    <!-- <div style="height: 123px;">
        <span>123</span>
        <h4>第1季度</h4>
    </div>
    <div style="height: 156px;">
        <span>156</span>
        <h4>第2季度</h4>
    </div>
    <div style="height: 120px;">
        <span>120</span>
        <h4>第3季度</h4>
    </div>
    <div style="height: 210px;">
        <span>210</span>
        <h4>第4季度</h4>
    </div> -->

    <script>        
        let arr = []
        for (let i = 1; i <= 4; i++) {
            // 浏览器4次弹框，每次弹框结束将数据添加数组
            arr.push(prompt(`请输入第 ${i} 季度的数据`))
        }
        // console.log(arr)
        // 页面渲染大盒子，将div标签拆分，里面用循环进行页面渲染
        document.write(`<div class="box">`)
        // 生成4 4个柱子
        for (let i = 0; i < arr.length; i++) {
            document.write(`
                 <div style="height: ${arr[i]}px;">
                     <span>${arr[i]}</span>
                    <h4>第${i + 1}季度</h4>
                </div>
            `)
        }
        // 大盒的 div 结束标签
        document.write(`</div>`)
    </script>
</body>

</html>
```

> 柱形图的长短根据用户输入的数据进行显示 

[网页特效：根据数据生成柱状图](D:\Java code\3.  javaScript编程\javaScript 基础\day03\20-综合案例-根据数据生成柱形图素材.html)

### 转换时间案例

需求： 用户输入秒数，可以自动转换为时分秒

分析：

①： 用户输入总秒数

②：计算时分秒（封装函数） 里面包含数字补0

③：打印输出

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 1.  用户输入
        let second = +prompt('请输入总的秒数：')
        // 2. 计算时间  封装函数
        function getTimes(t) {
            // 小时：  h = parseInt(总秒数 / 60 / 60 % 24)
            // 分钟：  m = parseInt(总秒数 / 60 % 60)
            // 秒数: s = parseInt(总秒数 % 60)
            //parseInt 保留整数部分
            if(t< 86400){
            let h = parseInt(t / 60 / 60 %24)
            let m = parseInt(t / 60 % 60)
            let s = parseInt(t % 60)
            h = h < 10 ? '0' + h : h
            m = m < 10 ? '0' + m : m
            s = s < 10 ? '0' + s : s
            return `计算之后的时间是${h}小时${m}分${s}秒`
            }else{
            let day=parseInt(t / 60 / 60 /24)
            let h = parseInt(t/ 60 / 60 % 24)
            let m = parseInt(t / 60 % 60)
            let s = parseInt(t % 60)
            h = h < 10 ? '0' + h : h
            m = m < 10 ? '0' + m : m
            s = s < 10 ? '0' + s : s
            return `计算之后的时间是${day}天${h}小时${m}分${s}秒`
            }  
        }
        // 3. 打印输出
        let str = getTimes(second)
        document.write(str)
        // document.write(str)
    </script>
</body>

</html>
```

> 天： 	day=parseInt(t / 60 / 60 /24)
>
> 小时： h = parseInt(总秒数 / 60 / 60 % 24)
>
> 分钟： m = parseInt(总秒数 / 60 % 60 )
>
> 秒数: s = parseInt(总秒数 % 60) 

[网页特效：转换时间](D:\Java code\3.  javaScript编程\javaScript 基础\day04\18-综合案例.html)

### 学成在线页面渲染案例

![image-20220916170610121](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220916170610121.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>学车在线首页</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- 4. box核心内容区域开始 -->
    <div class="box w">
        <div class="box-hd">
            <h3>精品推荐</h3>
            <a href="#">查看全部</a>
        </div>
        <div class="box-bd">
            <ul class="clearfix">
                <script>
                    // 定义数组存储 照片和文字
                    let data = [
                        {
                            src: 'images/course01.png',
                            title: 'Think PHP 5.0 博客系统实战项目演练',
                            num: 1125
                        },
                        {
                            src: 'images/course02.png',
                            title: 'Android 网络动态图片加载实战',
                            num: 357
                        },
                        {
                            src: 'images/course03.png',
                            title: 'Angular2 大前端商城实战项目演练',
                            num: 22250
                        }      
                    ]
                    // 根据数据的个数来渲染 到底有多少个小li 
                    // 循环渲染
                    for (let i = 0; i < data.length; i++) {
                        document.write(`
                        <li>
                            <img src=${data[i].src} alt="">
                            <h4>
                                ${data[i].title}
                            </h4>
                            <div class="info">
                                <span>高级</span> • <span> ${data[i].num}</span>人在学习
                            </div>
                        </li>
                    `)
                    }
                </script>

            </ul>
        </div>
    </div>

</body>

</html>
```

> `script可以写到标签内部 `

[网页特效：学成在线页面渲染](D:\Java code\3.  javaScript编程\javaScript 基础\day05\15-script可以写到标签内部 copy.html)

# webApi 

网页应用程序接口 ( js 里的内置对象 )

![image-20220918090427354](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918090427354.png)

## DOM文档对象模型

- DOM是用来呈现以及与任意 HTML 或 XML文档交互的API , DOM是浏览器提供的一套专门用来 **操作网页内容** 的功能。可以开发网页内容特效和实现用户交互

### DOM树

![image-20220918095140113](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918095140113.png)

### DOM对象

![image-20220918095357601](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918095357601.png)

> `DOM对象 是 浏览器根据html标签 生成的 所有js对象， 通过生成标签对象可以操作标签的属性` 
>
> `document 是 DOM中提供的一个对象`

#### 1. 获取DOM对象

![image-20220918100359927](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918100359927.png)

![image-20220918102213251](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918102213251.png)

获取一个或者多个DOM对象

```html
<body>
    <div>我是一个盒子</div>
    <div>我是er个盒子</div>
    <div class="three">我是三个盒子</div>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <span>就1个</span>
    <script>
        // 1. js 获取 第一个元素 ，选择器可以用，标签，类等选择器
         let div = document.querySelector('div')
         let div = document.querySelector('.three')
         let li = document.querySelector('ul li:last-child')
       
        // 2. 获取多个元素  伪数组
        let lis = document.querySelectorAll('ul li')
  
        // 通过遍历的方式，获得里面的每一个dom对象（元素）
        for (let i = 0; i < lis.length; i++) {
            console.log(lis[i])
        }
        let span = document.querySelectorAll('span')
        console.log(span)
    </script>
</body>
```

>  querySelector  只能获得一个元素， 选择器外加 单引号
>
> `querySelectorAll  能获得多个元素,得到的是一个伪数组, 也称为类数组。 是一种 按照索引存储数据 且具有 length 属性的 对象。 因为是对象，所以不能调用数组的方法 `

其他获取DOM元素方法（了解）

![image-20220918102628866](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918102628866.png)

#### 2. 修改元素内容

![image-20220918103102968](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918103102968.png)

document.write()

- 只能将文本内容追加到 </body> 前面的位置

-  文本中包含的标签会被解析

![image-20220918103219437](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918103219437.png)

元素innerText 属性

- 将文本内容添加/更新到任意标签位置

-  文本中包含的标签不会被解析

![image-20220918103949248](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918103949248.png)

> `innerText 不能解析标签， 添加 <h4> 标签没有效果`

元素.innerHTML 属性

- 将文本内容添加/更新到任意标签位置

- 文本中包含的标签会被解析

![image-20220918104133523](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918104133523.png)

> `用  innerHTML 可以添加标签， 文字加粗 并设置3级标题, 推荐使用`

#### 3. 设置/修改元素常用属性

![image-20220918190823700](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918190823700.png)

![image-20220918191611053](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918191611053.png)

##### 通过 style 属性操作CSS

![image-20220918192016548](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918192016548.png)

> 如果属性有-连接符，需要转换为小驼峰命名法； 例如：修改一个div盒子的样式，比如 padding-left：element.style.paddingLeft = ‘300px’
>
> `赋值的时候，需要的时候不要忘记加css单位`
>
> 通过js 修改元素样式，css样式会以行内式的方式在标签的style 属性中引入

案例：页面刷新随机更换背景图片

需求：当我们刷新页面，页面中的背景图片随机显示不同的图片

分析：

①： 随机函数

②： css页面背景图片 background-image

③： 标签选择body， 因为body是唯一的标签，可以直接写 document.body.style

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            background-image: url(./images/desktop_1.jpg);
        }
    </style>
</head>

<body>

    <script>
        // 随机的函数
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min
        }
        // 随机的值 1~10  
        let num = getRandom(1, 10)
        // 修改背景图片
        document.body.style.backgroundImage = `url(./images/desktop_${num}.jpg)`
    </script>
</body>

</html>
```

> 修改body 中的样式，通过 body.style.backgroundImage 修改（对象就是body）

[网页特效：页面背景随机刷新](D:\Java code\3.  javaScript编程\3.2 webapi\day01\08-随机背景.html)

---

##### 操作类名(className) 操作CSS

![image-20220918202022810](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918202022810.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            width: 200px;
            height: 200px;
            background-color: pink;
        }

        .active {
            width: 300px;
            height: 300px;
            background-color: hotpink;
            margin-left: 100px;
        }
    </style>
</head>

<body>
    <div class="one"></div>
    <script>
        // 1.获取元素
        // let box = document.querySelector('css选择器')
        let box = document.querySelector('div')
        // 2 设置样式div
        // box.style.width = '300px'
        // box.style.height = '300px'
        // box.style.backgroundColor = 'hotpink'
        // box.style.marginLeft = '100px'
        // 通过className 给标签添加类 来修改样式时， 标签上不要写class 会被覆盖
        box.className = 'one active'
    </script>
</body>

</html>
```

> 通过className 给标签添加类 来修改样式时， 标签上不要写class 会被覆盖
>
> `className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名`

#####  通过 classList 操作类控制CSS

![image-20220918203208161](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220918203208161.png)

>  `切换类  如果标签上有 相同的类则减，没有则加`
>
> ​    box.classList.toggle('one') 

##### 设置/修改 表单元素 属性

![image-20220919092710996](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919092710996.png)

![image-20220919093433486](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919093433486.png)

```html
<body>
    <input type="text" value="请输入">
    <button disabled>按钮</button>
    <input type="checkbox" name="" id="" class="agree">
    <script>
        // 1. 获取元素
        let input = document.querySelector('input')
        // 2. 取值或者设置值  得到input里面的值可以用 value
        // console.log(input.value)
        input.value = '小米手机'
        input.type = 'password'

        // 2. 启用按钮
        let btn = document.querySelector('button')
        // disabled 不可用   =  false  这样可以让按钮启用
        btn.disabled = false
        // 3. 勾选复选框
        let checkbox = document.querySelector('.agree')
        checkbox.checked = false
    </script>
```

> disabled (不可用)   添加到按钮中时，默认（true）会禁用按钮使用  ，设置为 false  则启用按钮
>
> checked、selected  添加到复选框或者下拉菜单中，默认（true）会选中，设置为 false 则禁用

##### 设置自定义属性

传统自定义属性

![image-20220929175325650](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929175325650.png)

> 传统的自定义属性，现在不常用

data - 自定义属性 (经常使用)

![image-20220929175443919](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929175443919.png)

```js
<body>
    <div class="box" data-index="0" data-name="andy"></div>
    <script>
        // 设置自定义属性
        let box = document.querySelector('.box')
        // box.dataset 得到所有自定义对象 .index 获得对应的属性值 0
        console.log(box.dataset)
        console.log(box.dataset.index)
    </script>
</body>
```

> 可以在标签上直接添加 data- 属性名（标签上直接添加自定义属性），`box.dataset  可以获得 box 标签上所有的自定义对象`

#### 4. 定时器-间歇函数

![image-20220919102722421](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919102722421.png)

开启定时器（window 对象里的函数方法，可以省略）

![image-20220919102812961](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919102812961.png)

> 时间间隔是以毫秒为点位，设置定时器后每个一段时间会定时执行函数

关闭定时器

![image-20220919102917856](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919102917856.png)

```html
<body>
    <script>
        // setInterval(function () {
        //     console.log('高薪就业')
        // }, 1000)

        function show() {
            console.log('月薪过2万')
        }
	// timer 值为 1 ，表示第一个定时器
        let timer = setInterval(show, 1000)
        // let timer1 = setInterval(show, 1000)

        // 清除定时器
        clearInterval(timer)
    </script>
```

>  `setInterval 里可以写匿名函数，定时器的返回值是 id数 ，表示第几个定时器，`

#### 5. 定时器- 延时函数

![image-20220928165643988](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928165643988.png)

> 延时函数是 等待一段时间后才执行，且只执行一次

结合递归函数可以使用 setTimeout 实现 setInterval 一样的功能

```js
 <div></div>
    <script>
        // 利用递归函数 模拟了 setinterval
        let div = document.querySelector('div')
        function fn() {
            div.innerHTML = new Date().toLocaleString()
            setTimeout(fn, 1000)
        }
        fn()
    </script>
```

#### 案例：倒计时效果

![image-20220919104145713](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919104145713.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <textarea name="" id="" cols="30" rows="10">
        用户注册协议
        欢迎注册成为京东用户！在您注册过程中，您需要完成我们的注册流程并通过点击同意的形式在线签署以下协议，请您务必仔细阅读、充分理解协议中的条款内容后再点击同意（尤其是以粗体或下划线标识的条款，因为这些条款可能会明确您应履行的义务或对您的权利有所限制）。
        【请您注意】如果您不同意以下协议全部或任何条款约定，请您停止注册。您停止注册后将仅可以浏览我们的商品信息但无法享受我们的产品或服务。如您按照注册流程提示填写信息，阅读并点击同意上述协议且完成全部注册流程后，即表示您已充分阅读、理解并接受协议的全部内容，并表明您同意我们可以依据协议内容来处理您的个人信息，并同意我们将您的订单信息共享给为完成此订单所必须的第三方合作方（详情查看
    </textarea>
    <br>
    <button class="btn" disabled>我已经阅读用户协议(6)</button>
    <script>
        // 1. 获取元素 button 
        let btn = document.querySelector('.btn')
        // 2. 计算逻辑
        // 2.1 我们需要一个变量 用来计数  
        let i = 6
        // 2.2 开启定时器 间歇函数  timer 定时器的序号id
        let timer = setInterval(function () {
            //每隔一秒，减一
            i--
            btn.innerHTML = `我已经阅读用户协议(${i})`
            if (i === 0) {
                // 清除定时器 ，需要获得定时器的返回值
                clearInterval(timer)
                // 开启按钮
                btn.disabled = false
                // 更换文字
                btn.innerHTML = '我同意该协议啦'
            }
        }, 1000)
    </script>
</body>

</html>
```

## DOM- 事件基础

### 事件

- 事件是在编程时系统内发生的**动作**或者发生的事情，比如用户在网页上**单击**一个按钮 什么是事件监听？

- 事件监听就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 注册事件

---

事件监听三要素：

- 事件源： 那个dom元素被事件触发了，要获取dom元素对象

- 事件触发方式：比如鼠标单击 click、鼠标经过 mouseover 等 

- 事件调用的函数： 要做什么事

![image-20220919160149186](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919160149186.png)

#### 1. 事件监听的代码实现

![image-20220919160458783](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919160458783.png)

> 事件触发类型要加单引号 ， ' click ' 表示单击触发事件

#### 2. 两种注册事件的区别

![image-20220925174459535](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220925174459535.png)

```js
<body>
    <button>点击</button>
    <script>
        let btn = document.querySelector('button')
        // 1.l0 on
        // 多次相同的事件，只执行最后一次
        // btn.onclick = function () {
        //     alert('第一次')
        // }
        // btn.onclick = function () {
        //     alert('第二次')
        // }
        // 解绑事件
        // btn.onclick = null
        // 2. addEventListener
        btn.addEventListener('click', add)
        function add() {
            alert('第一次')
        }
        // btn.addEventListener('click', function () {
        //     alert('第二次')
        // })
        btn.removeEventListener('click', add)
    </script>
</body>
```

> 传统on注册 ：注册多个事件时，前一个事件会被后注册的事件覆盖； 可以直接使用null 进行事件的解绑 `（ btn.onclick = null ）`
>
> 事件监听注册：注册多个事件不会覆盖； 必须使用 `removeEventListener` 解除绑定，但必须声明函数 

案例：淘宝点击关闭二维码

![image-20220919193551664](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919193551664.png)

```html
<body>
    <div class="erweima">
        <img src="./images/code.png" alt="">
        <i class="close_btn">x</i>
    </div>
    <script>
        // 1. 获取元素   事件源 i   关闭的 erweima 
        let close_btn = document.querySelector('.close_btn')
        let erweima = document.querySelector('.erweima')
        // 2. 事件监听
        close_btn.addEventListener('click', function () {
            // 在标签上添加css样式，设置隐藏
            erweima.style.display = 'none'
        })
    </script>
</body>
```

案例：随机点名

![image-20220919195232681](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919195232681.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            width: 200px;
            height: 40px;
            border: 1px solid pink;
            text-align: center;
            line-height: 40px;
        }
    </style>
</head>

<body>
    <div>开始抽奖吧</div>
    <button>点击点名</button>
    <script>
        // 1. 获取元素  div 和 button 
        let box = document.querySelector('div')
        let btn = document.querySelector('button')
        // 2. 随机函数
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min
        }
        // 声明一个数组
        let arr = ['刘备', '曹操', 'pink老师']
        // 3. 事件监听
        btn.addEventListener('click', function () {
            // 随机的数字
            let random = getRandom(0, arr.length - 1)
            // console.log(arr[random])
            box.innerHTML = arr[random]
            // 删除数组里面的元素  splice(从哪里删, 删几个)
            arr.splice(random, 1)
            // 如果数组没有了 长度为0，就要禁用按钮
            if (arr.length === 0) {
                // console.log('最后一个了')
                btn.disabled = true
                btn.innerHTML = '已经抽完'
            }
        })
    </script>
</body>

</html>
```

> 单击按钮时，获取随机数 0~2，( 对应数组下标 )，取得数组中的元素，并且添加到标签内容中
>
> 每抽一次，数组长度减一，当数组为0时，按钮禁用

#### 案例：通过定时器实现随机点名

需求：点击开始随机抽取，点击结束输出结果

- 点击开始按钮随机抽取数组的一个数据，放到页面中

- 点击结束按钮删除数组当前抽取的一个数据

- 当抽取到最后一个数据的时候，两个按钮同时禁用

![image-20220919202801860](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919202801860.png)

```html
 <script>
        // 数据数组
        let arr = ['马超', '黄忠', '赵云', '关羽', '张飞']
        function getRandom(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min
        }
        // 1. 获取元素  两个按钮 + div
        // 一定不要忘记加点  因为里面写css类选择器
        let start = document.querySelector('.start')
        let end = document.querySelector('.end')
        let qs = document.querySelector('.qs')
        // timer 要是全局变量
        let timer = 0
        // random 要是全局变量
        let random = 0
        // 2. 给开始按钮注册事件
        start.addEventListener('click', function () {
            // 随机抽数据--- 快速不断的抽取 间歇函数定时器
            timer = setInterval(function () {
                random = getRandom(0, arr.length - 1)
                // 从数组中获取元素 ，填充到提示框中
                qs.innerHTML = arr[random]
            }, 50)
            // 如果到了最后一个，就禁用两个按钮
            if (arr.length === 1) {
                // console.log('没了')
                // start.disabled = true
                // end.disabled = true
                start.disabled = end.disabled = true
            }
        })
        // 3. 给结束按钮注册事件  本质是停止定时器
        end.addEventListener('click', function () {
            // 停止定时器
            clearInterval(timer)
            // 删除数组元素
            arr.splice(random, 1)
            // console.log(arr)
        })
    </script>
</body>

</html>
```

> `给开始按钮添加单击事件，先将随机数作为数组下标，获得对应的数组中元素，再将开启定时器每个0.05s 给提示框 填充名字，做出内容快速变化的效果；`
>
> 每次结束都要停止定时器，并且删除数组元素
>
> 点击开始后，判断当数组中只剩一个元素时，需要同时禁用开始和结束按钮

[网页特效：定时器实现随机抽取](D:\Java code\3.  javaScript编程\3.2 webapi\day02\04-随机点名案例.html)

---

### 事件类型

![image-20220920181708258](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220920181708258.png)

案例：小米搜索框案例

![image-20220920181828976](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220920181828976.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        ul {

            list-style: none;
        }

        .mi {
            position: relative;
            width: 223px;
            margin: 100px auto;
        }

        .mi input {
            width: 223px;
            height: 48px;
            padding: 0 10px;
            font-size: 14px;
            line-height: 48px;
            border: 1px solid #e0e0e0;
            outline: none;
            transition: all .3s;
        }

        .mi .search {
            border: 1px solid #ff6700;
        }

        .result-list {
            display: none;
            position: absolute;
            left: 0;
            top: 48px;
            width: 223px;
            border: 1px solid #ff6700;
            border-top: 0;
            background: #fff;
        }

        .result-list a {
            display: block;
            padding: 6px 15px;
            font-size: 12px;
            color: #424242;
            text-decoration: none;
        }

        .result-list a:hover {
            background-color: #eee;
        }
    </style>

</head>

<body>
    <div class="mi">
        <input type="search" placeholder="小米笔记本">
        <ul class="result-list">
            <li><a href="#">全部商品</a></li>
            <li><a href="#">小米11</a></li>
            <li><a href="#">小米10S</a></li>
            <li><a href="#">小米笔记本</a></li>
            <li><a href="#">小米手机</a></li>
            <li><a href="#">黑鲨4</a></li>
            <li><a href="#">空调</a></li>
        </ul>
    </div>
    <script>
        // 1. 获取元素   input 
        let search = document.querySelector('input')
        let list = document.querySelector('.result-list')
        // 2. 事件监听 获得光标事件  focus
        search.addEventListener('focus', function () {
            // 显示下拉菜单
            list.style.display = 'block'
            // 文本框变色，添加类
            this.classList.add('search')
        })
        // 3. 事件监听 失去光标事件  blur
        search.addEventListener('blur', function () {
            // 隐藏下拉菜单
            list.style.display = 'none'
            // 文本框去色，移除类
            this.classList.remove('search')
        })
    </script>
</body>

</html>
```

> 当输入框获得焦点时，显示下拉菜单，并设置边框线；当输入框失去焦点时，隐藏菜单，并移除边框线
>
> `通过 classList  增加或者删除类 来实现边框线效果`

[网页特效：小米搜索框案例](D:\Java code\3.  javaScript编程\3.2 webapi\day02\06-小米搜索框.html)

#### 案例：微博输入案例

![image-20220920185144089](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220920185144089.png)

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="css/weibo.css">
</head>

<body>
  <div class="w">
    <div class="controls">
      <img src="images/tip.png" alt=""><br>
      <textarea placeholder="说点什么吧..." id="area" cols="30" rows="10" maxlength="200"></textarea>
      <div>
        <span class="useCount">0</span>
        <span>/</span>
        <span>200</span>
        <button id="send">发布</button>
      </div>

    </div>
    <div class="contentList">
      <ul>

      </ul>
    </div>
  </div>
  <script>
    // 1. 获取元素 文本域  count
    let area = document.querySelector('#area')
    let useCount = document.querySelector('.useCount')
    // 2. 绑定事件  用户输入事件 input
    area.addEventListener('input', function () {
      // console.log('测试中')
      // 不断得到文本域里面的字符长度
      // area.value 可以得到的值
      // console.log(area.value)
      // area.value.length 得到输入字符的长度
      // console.log(area.value.length)
      useCount.innerHTML = area.value.length
    })
  </script>
</body>

</html>
```

> `<textarea placeholder="说点什么吧..." id="area" cols="30" rows="10" maxlength="200"></textarea> `, maxlength="200" 表示能输入的最大长度为 200
>
> 监听文本框中的输入文字的个数，使用 input 事件 ； area.value 得到 文本框输入内容， .length 的到内容长度

[网页特效：微博输入案例](D:\Java code\3.  javaScript编程\3.2 webapi\day02\05－发布微博案例\weibo模板.html)

#### 案例：全选文本框案例

![image-20220920192949535](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220920192949535.png)

![image-20220920202208656](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220920202208656.png)

```html
<!DOCTYPE html>

<html>

<head lang="en">
  <meta charset="UTF-8">
  <title></title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    table {
      border-collapse: collapse;
      border-spacing: 0;
      border: 1px solid #c0c0c0;
      width: 500px;
      margin: 100px auto;
      text-align: center;
    }

    th {
      background-color: #09c;
      font: bold 16px "微软雅黑";
      color: #fff;
      height: 24px;
    }

    td {
      border: 1px solid #d0d0d0;
      color: #404060;
      padding: 10px;
    }

    .allCheck {
      width: 80px;
    }
  </style>
</head>

<body>
  <table>
    <tr>
      <th class="allCheck">
        <input type="checkbox" name="" id="checkAll"> <span class="all">全选</span>
      </th>
      <th>商品</th>
      <th>商家</th>
      <th>价格</th>
    </tr>
    <tr>
      <td>
        <input type="checkbox" name="check" class="ck">
      </td>
      <td>小米手机</td>
      <td>小米</td>
      <td>￥1999</td>
    </tr>
    <tr>
      <td>
        <input type="checkbox" name="check" class="ck">
      </td>
      <td>小米净水器</td>
      <td>小米</td>
      <td>￥4999</td>
    </tr>
    <tr>
      <td>
        <input type="checkbox" name="check" class="ck">
      </td>
      <td>小米电视</td>
      <td>小米</td>
      <td>￥5999</td>
    </tr>
  </table>
  <script>
    // 1. 获取元素  全选 和   ck 小复选框
    let all = document.querySelector('#checkAll')
    let cks = document.querySelectorAll('.ck')
    let span = document.querySelector('span')
    // 2. 事件监听   全选按钮  
    all.addEventListener('click', function () {
      // console.log(all.checked)  // true  false 
      // 我们需要做的就是把 all.checked 给下面三个小按钮
      // 因为三个按钮在伪数组里面，我们需要遍历的方式，挨着取出来，依次给值
      for (let i = 0; i < cks.length; i++) {
        cks[i].checked = all.checked
      }
      // 当我们的全选按钮处于选中状态，则可以改为取消
      if (all.checked) {
        // console.log('要改')
        span.innerHTML = '取消'
      } else {
        span.innerHTML = '全选'
      }
    })


    // 3. 小按钮的做法 同时给多个元素绑定相同事件
    for (let i = 0; i < cks.length; i++) {
      // 绑定事件
      cks[i].addEventListener('click', function () {
        // console.log(11)
        // 每次点击复选框，都要遍历所有的小按钮 ，判断当前状态 
        for (let j = 0; j < cks.length; j++) {
          // 只要有一个复选框未被选中，则全选框的状态为 未选中
          if (cks[j].checked === false) {
            // 如果有false 则退出循环 结束函数
            all.checked = false
            span.innerHTML = '全选'
              // return  后结束当前 函数
            return
          }
        }
        // 当我们的循环结束，如果代码走到这里，说明没有false，都被选中了，则全选按钮要选中
        all.checked = true
        span.innerHTML = '取消'
      })
    }

  </script>
</body>

</html>
```

> `每个复选框在未选择中的状态下 checked 属性为false ，如果在标签上添加 checked 属性 则复选框为选择状态， checked值为 true`
>
> 单击复选框，使其为选择状态时，checked值 也会变为 true
>
> 在事件内部,遍历所有的checkbox状态,只要有一个为false 就将全选状态设置为false , 把文字改为全选，并且直接return (退出循环)
>
> 在循环结束将全选的状态直接设置为true

#### 案例：购物车加减操作

![image-20220921101859863](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921101859863.png)

```html
 <script>
      // 1. 获取元素  三个
      let total = document.querySelector('#total')
      let add = document.querySelector('#add')
      let reduce = document.querySelector('#reduce')
      // 2. 点击加号 事件侦听  
      add.addEventListener('click', function () {
        // console.log(typeof total.value)
        // total.value = total.value + 1
        // i++   隐式转换
        // i = i + 1 
        total.value++
        reduce.disabled = false
      })
      // 3. 点击减号 事件侦听  
      reduce.addEventListener('click', function () {

        total.value--
          // 当 文本框中的数字为 1 时，禁用减号按钮
        if (total.value <= 1) {
          reduce.disabled = true
        }
      })
    </script>
```

> `通过 文本框对象.value 可以获得 文本框中的 内容`

[网页特效：购物车加减操作](D:\Java code\3.  javaScript编程\3.2 webapi\day02\09-购物车加减操作.html)

### 高阶函数

- 高阶函数可以被简单理解为函数的高级应用，`JavaScript 中函数可以被当成【值】来对待`，基于这个特性实现函数的高级应用。 

#### 1. 函数表达式

![image-20220921102902893](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921102902893.png)

> `函数表达式 就是 把函数赋值给变量， 一般是将匿名函数作为值 赋值给变量` .当需要调用该函数时`变量后需要加（）`，有参则传参，有返回值则再声明个变量进行接收
>
> `函数表达式必须要先声明再调用`, 普通函数的声明与调用无先后顺序

#### 2. 回调函数

- 如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数

- 简单理解： 当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数 

![image-20220921103235997](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921103235997.png)

> `把函数当做另外一个函数的参数传递，这个函数就叫回调函数 `
>
> 回调函数本质还是函数，只不过把它当成参数使用
>
> 使用匿名函数做为回调函数比较常见

#### 3. 递归函数

- 递归函数 ： 自己调用自己就是递归函数

- 递归函数容易造成死递归，一定要加退出条件

```js
  <script>
        // 递归函数 ： 自己调用自己就是递归函数
        // 递归函数容易造成死递归，一定要加退出条件
        let num = 0
        function fn() {
            num++
            console.log(111)
            // 在函数里面，调用自己  
            if (num >= 100) {
                return
            }
            fn()
        }
        fn()
    </script>
```

### 环境对象

- 环境对象指的是函数内部特殊的**变量 this** ，它代表着当前函数运行时所处的环境

- 函数中的this，谁调用就指向谁 （事件处理函数：事件源、定时器：window、调用者、自调用函数：window、调用者）

-  普通函数没有明确调用者时 this 值为 window，`严格模式下没有调用者时 this 的值为 undefined`。

- 直接调用函数，其实相当于是 window.函数，所以 this 指代 window

-  构造函数中this ， 指向实例化对象

```html
 <script>
        //  this指 window 对象，script里 是 通过window 对象调用函数，window对象可以省略
        function fn() {
            console.log(this)
        }
        // fn()
        window.fn()

        let btn = document.querySelector('button')
        btn.addEventListener('click', function () {
            console.log(typeof this)
            // 因为btn 调用了这个函数，所以 this 指向btn
        })
     -------------------------------------------------------------------------------------------
     // 2、构造函数 中this 指向实例化对象
		function Perosn (uname, age) {
			this.uname = uname;
			this.age = age;
			console.log(this);
		}
    	 let obj1 = new Perosn('阿飞', 22);
		console.log(obj1);
		let obj2 = new Perosn('李寻欢', 23);
		console.log(obj2);
     --------------------------------------------------------------------------------------------
    	 //4、事件处理函数：事件源
		document.addEventListener('click', function () {
			console.log(this);
		});

		//5、定时器：window、调用者
		window.setInterval(function () {
			console.log(this);
		}, 1000)

		//6、自调用函数：window、调用者
		;(function () {
			console.log(this);
		})()
    </script>
```

### 编程思想

---

#### 排他思想

给元素单独设置样式时，需要先清除其他元素上的样式，再单独设置

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .pink {
            background: pink;
        }
    </style>
</head>

<body>
    <button class="pink">第1个</button><button>第2个</button><button>第3个</button><button>第4个</button><button>第5个</button>
    <script>
        let btns = document.querySelectorAll('button')
        for (let i = 0; i < btns.length; i++) {
            btns[i].addEventListener('click', function () {
                // this.classList.add('pink')
                //  每次单击时，先循环清除所有样式
                for (let j = 0; j < btns.length; j++) {
                    btns[j].classList.remove('pink')
                }
                 // 我只需要找出那个唯一的 pink类 进行删除，按钮标签中必须有pink 类名
               //  document.querySelector('.pink').classList.remove('pink')
                // 清除完样式后，给当前按钮添加样式
                this.classList.add('pink')
            })
        }
    </script>
</body>

</html>
```

> 存在多个按钮时，当单击某一个按钮时，会变色；`再次单击另一个按钮时，先前按钮的样式需要清除`，当前单击按钮变色
>
> 可以利用循环 清除所有样式，也可以选中添加 pink类名的对象，进行样式移除再重新给当前按钮添加 样式 : document.querySelector('.pink').classList.remove('pink')   

[网页特效：按钮单击变色](D:\Java code\3.  javaScript编程\3.2 webapi\day02\13-排他思想升级.html)

## DOM- 节点操作

### 节点操作

#### 1. DOM 节点

![image-20220921190408205](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921190408205.png)

> dom节点 分为 元素节点、属性节点、文本节点

#### 2. 查找节点

##### 2.1 父节点查找

![image-20220921190743589](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921190743589.png)

```html
<body>
    <div class="father">
        <div class="son">儿子</div>
    </div>
    <script>
        let son = document.querySelector('.son')
        //  son.parentNode  代表了父节点
        son.parentNode.style.display = 'none'
    </script>
</body>
```



##### 2.2 子节点查找

![image-20220921190844812](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921190844812.png)

点击按钮，改变所有 li 里的文字的颜色

```html
<body>
    <button>点击</button>
    <ul>
        <li>我是孩纸</li>
        <li>我是孩纸</li>
        <li>我是孩纸</li>
        <li>我是孩纸</li>
        <li>我是孩纸</li>
        <li>我是孩纸</li>
    </ul>
    <script>
        let btn = document.querySelector('button')
        let ul = document.querySelector('ul')
        btn.addEventListener('click', function () {
            // console.log(ul.children)
            for (let i = 0; i < ul.children.length; i++) {
                ul.children[i].style.color = 'red'
            }
        })
        ul.children[0].style.color = 'green'
        // console.log(ul.childNodes)
    </script>
</body>
```

>  ul.children  可以获得ul 下的所有元素子节点，返回的是子元素数组

[网页特效：点击按钮变色](D:\Java code\3.  javaScript编程\3.2 webapi\day03\03-查找子节点.html)

##### 2.3 兄弟关系查找

![image-20220921200920409](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921200920409.png)

```html
<body>
    <button>点击</button>
    <ul>
        <li>第1个</li>
        <li class="two">第2个</li>
        <li>第3个</li>
        <li>第4个</li>
    </ul>
    <script>
        let btn = document.querySelector('button')
        let two = document.querySelector('.two')
        btn.addEventListener('click', function () {
            // two.style.color = 'red'
            // 将 第三个li 设置颜色为红色
            two.nextElementSibling.style.color = 'red'
            // 将第一个li 设置颜色为红色
            two.previousElementSibling.style.color = 'red'
        })
    </script>
</body>
```

#### 3. 增加节点

一般情况下，我们新增节点，按照如下操作：

- 创建一个新的节点

- 把创建的新的节点放入到指定的元素内部

![image-20220921201436597](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921201436597.png)

##### 3.1 创建节点

![image-20220921204126152](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921204126152.png)

##### 3.2 追加节点

![image-20220921204202481](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921204202481.png)

```html
<body>
    <ul>
        <li>我是大毛</li>
        <li>我是二毛</li>
    </ul>
    <script>
        // 1. 创建新的标签节点
        // let div = document.createElement('div')
        // div.className = 'current'
        let ul = document.querySelector('ul')

        //创建一个li 内容是 我是xiao ming
        let li = document.createElement('li')
        li.innerHTML = '我是xiao ming'

        // 2. 追加节点  永远在所有子元素最后生成, 在我是二毛后面追加
        // ul.appendChild(li)
        // 3. 追加节点 永远放在第一个  
        ul.insertBefore(li, ul.children[0])
    </script>
</body>
```

> //  追加节点  永远在所有子元素最后生成
>
>  ul.appendChild(li)

##### 3.3  复制节点

![image-20220922190730566](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220922190730566.png)

```html
<body>
    <ul>
        <li>我是内容11111</li>
    </ul>
    <script>
        let ul = document.querySelector('ul')
        // 括号为空则默认为false 如果是false则不克隆后代节点
        // 如果是true则克隆后代节点，ul 里包括 小 li 
        let newUl = ul.cloneNode(true)
        document.body.appendChild(newUl)
    </script>
</body>
```

> 若为true，则代表克隆时会包含后代节点一起克隆
>
> 若为false，则代表克隆时不包含后代节点
>
> 默认为false

#### 4. 删除节点

![image-20220922191432854](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220922191432854.png)

点击按钮删除ul 下的第一个小li 

```html
<body>
    <button>点击</button>
    <ul>
        <li>我是内容11111</li>
    </ul>
    <script>
        // 需求，点击按钮，删除小li
        let btn = document.querySelector('button')
        let ul = document.querySelector('ul')
        btn.addEventListener('click', function () {
            // 删除的语法 父元素.removeChild(子元素)
            ul.removeChild(ul.children[0])
        })
    </script>
</body>
```

> `必须根据父元素删除对应的子元素，如果不存在父子关系则无法删除`

#### 案例：关闭多个二维码

![image-20220921193754053](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921193754053.png)

```html
<body>
  <div class="erweima">
    <span class="close"></span>
  </div>
  <div class="erweima">
    <span class="close"></span>
  </div>
  <div class="erweima">
    <span class="close"></span>
  </div>
  <div class="erweima">
    <span class="close"></span>
  </div>
  <div class="erweima">
    <span class="close"></span>
  </div>

  <script>
    // 1. 获取元素  关闭按钮
    let close_btn = document.querySelectorAll('.close')
    // 2. 绑定多个点击事件给close
    for (let i = 0; i < close_btn.length; i++) {
      close_btn[i].addEventListener('click', function () {
        // 3. 关闭当前的那个二维码  ,找到子元素的父元素对象 并设置隐藏
        this.parentNode.style.visibility = 'hidden'
      })
    }
  </script>
</body>
```

> 当存在多个父级标签，且都添加了相同的类时，通过 给子级标签添加事件， 并获取 parentNode 属性 返回的属性值 是 父标签对象

#### 案例：学成在线案例渲染

①：准备好空的ul 结构

②：根据数据的个数，创建一个新的空li

③：li里面添加内容 img 标题等

④：追加给ul

![image-20220922185206018](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220922185206018.png)

```html
<script>
        let data = [
            {
                src: 'images/course01.png',
                title: 'Think PHP 5.0 博客系统实战项目演练',
                num: 1125
            },
            {
                src: 'images/course02.png',
                title: 'Android 网络动态图片加载实战',
                num: 357
            },
            {
                src: 'images/course03.png',
                title: 'Angular2 大前端商城实战项目演练',
                num: 22250
            },
            {
                src: 'images/course04.png',
                title: 'Android APP 实战项目演练',
                num: 389
            },
            {
                src: 'images/course05.png',
                title: 'UGUI 源码深度分析案例',
                num: 124
            },
            {
                src: 'images/course06.png',
                title: 'Kami2首页界面切换效果实战演练',
                num: 432
            },
            {
                src: 'images/course07.png',
                title: 'UNITY 从入门到精通实战案例',
                num: 888
            },
            {
                src: 'images/course08.png',
                title: '我会变，你呢？',
                num: 590
            },
            {
                src: 'images/course08.png',
                title: '我会变，你呢？',
                num: 590
            }
        ]
        let ul = document.querySelector('ul')
        // 1. 根据数据的个数，决定这小li的个数
        for (let i = 0; i < data.length; i++) {
            // 2. 创建小li
            let li = document.createElement('li')
            // console.log(li)

            // 4. 先准备好内容，再追加 
            li.innerHTML = `
            <img src=${data[i].src} alt="">
            <h4>
                ${data[i].title}
            </h4>
            <div class="info">
                <span>高级</span> • <span> ${data[i].num}</span>人在学习
            </div>
            `
            // 3. 追加给ul   父元素.appendChild(子元素)
            ul.appendChild(li)

        }
    </script>
```

> `先从后端拿到数据放进对象数组中，循环遍历，有几条数据则通过 js 创建 几个小 li，最后追加到 ul 父元素中`
>
>  li.innerHTML   在li 里布置标签  （innerHTML 可以识别标签）

### 时间对象

![image-20220923083549145](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923083549145.png)

> `获得时间对象需要将 date 类 实例化`

#### 1. 时间对象常用方法

![image-20220923085009144](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923085009144.png)

> getMonth( )  得到月份后需要 + 1
>
> `getDay( )  获得星期， 星期天的取值 是 0`

#### 2. 时间戳

![image-20220923094139976](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923094139976.png)

![image-20220923094353759](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923094353759.png)

> 时间戳主要用来做倒计时，可以利用将来的时间戳 减去 现在的时间戳 就是剩余的时间毫秒数

#### 案例：页面显示时间

需求：将当前时间以：YYYY-MM-DD HH:mm 形式显示在页面

①：调用时间对象方法进行转换

②：字符串拼接后，通过 innerText 给 标签

```html
<body>
    <div></div>
    <script>

        let arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
        let div = document.querySelector('div')
        // 定时器 有1秒的空白期，需要先调用函数
        getTime()
        setInterval(getTime, 1000)
        function getTime() {
            // 1. 实例化时间对象 一定写到定时器里面才可以额
            let date = new Date()
            let year = date.getFullYear()
            let month = date.getMonth() + 1
            let date1 = date.getDate()
            let hour = date.getHours()
            let min = date.getMinutes()
            let sec = date.getSeconds()
            let day = date.getDay()
            div.innerHTML = `今天是： ${year}年${month}月${date1}日 ${hour}:${min}:${sec} ${arr[day]}`
        }
    </script>
</body>
```

> 定时器 启动 1秒后才会调用函数， 为了防止空白期的出现，在启动定时器前先调用函数 

[网页特效：页面显示时间](D:\Java code\3.  javaScript编程\3.2 webapi\day03\10-显示时间.html)

---

#### 案例：毕业倒计时

![image-20220923100456499](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923100456499.png)

```html
<body>
  <div class="countdown">
    <p class="next">今天是2021年8月28日</p>
    <p class="title">下班倒计时</p>
    <p class="clock"> 
      <span id="hour">00</span>
      <i>:</i>
      <span id="minutes">25</span>
      <i>:</i>
      <span id="scond">20</span>
    </p>
    <p class="tips">
      现在是18:30:00
    </p>
  </div>
  <script>
    let hour = document.querySelector('#hour')
    let minutes = document.querySelector('#minutes')
    let scond = document.querySelector('#scond')
    let next = document.querySelector('.next')
    let tips = document.querySelector('.tips')


   //页面初次加载时，进获得当前时间
    time1()
    //获得倒计时的时间
    time()
      //开启定时器
    setInterval(time, 1000)
      
    function time1(){
    let date = new Date()
    let year = date.getFullYear()
    let month = date.getMonth() + 1
    let day = date.getDate()
    next.innerHTML = `今天是${year}年${month}月${day}日`
    let hour1 = date.getHours()
    let min = date.getMinutes()
    let sec = date.getSeconds()
    tips.innerHTML = `现在是${hour1}:${min}:${sec}`
    }
    function time() {
      //需要在定时器里重新获得当前系统时间
      let date = new Date()
      // 1. 得到现在的时间戳
      let now = +new Date()
      // 2. 得到指定时间的时间戳
      let last = +new Date('2022-9-23 14:30:00')
      // 3. （计算剩余的毫秒数） / 1000 === 剩余的秒数
      let count = (last - now) / 1000
      // console.log(count)
      // 4. 转换为时分秒
      // h = parseInt(总秒数 / 60 / 60 % 24)   //   计算小时
      let h = parseInt(count / 60 / 60 % 24)
      h = h < 10 ? '0' + h : h
      // m = parseInt(总秒数 / 60 % 60);     //   计算分数
      let m = parseInt(count / 60 % 60)
      m = m < 10 ? '0' + m : m
      // s = parseInt(总秒数 % 60); //   计算当前秒数
      let s = parseInt(count % 60);
      s = s < 10 ? '0' + s : s
      // 填充倒计时的数据
      hour.innerHTML = h
      minutes.innerHTML = m
      scond.innerHTML = s
    
       //填充 年月日、小时、分钟、秒的数据
    let year = date.getFullYear()
    let month = date.getMonth() + 1
    let day = date.getDate()
    next.innerHTML = `今天是${year}年${month}月${day}日`
    let hour1 = date.getHours()
    let min = date.getMinutes()
    let sec = date.getSeconds()
    tips.innerHTML = `现在是${hour1}:${min}:${sec}`
    }
  </script>
</body>
```

> 观看案例时，时间戳需要重新设置
>
>   // 2. 得到指定时间的时间戳
>       let last = +new Date('2022-9-23 14:30:00')

[网页特效：毕业倒计时](D:\Java code\3.  javaScript编程\3.2 webapi\day03\12-下班倒计时.html)

### 重绘和回流

#### 1. 浏览器是如何进行界面渲染的

![image-20220923152907720](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923152907720.png)

#### 2. 重绘和回流(重排) 

![image-20220923153040380](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923153040380.png)

![image-20220923153144014](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923153144014.png)

---

## DOM- 事件高级

---

### 事件对象

![image-20220924125113747](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220924125113747.png)

#### 1. 事件对象常用属性

![image-20220924131049211](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220924131049211.png)

> `pageX 和 pageY 跟包括了浏览器不可以见窗口到左上角的距离（当浏览器内容过多出现滚动条时，滚动条外的内容区属于不可以见区域）`
>
> 一般经常利用pageX 和 pageY   获得鼠标 位置 

---

#### 案例：跟随鼠标案例

需求：一张图片一直跟着鼠标移动分析：

①：鼠标在页面中移动，用到  mousemove 事件,并添加事件对象， e.pageX、e.pageY 获取鼠标位置信息

②：不断把鼠标在页面中的坐标位置给图片left和top值即可

```html
<body>
    <img src="./images/tianshi.gif" alt="">
    <script>
        let img = document.querySelector('img')
        // 不断得到当前的鼠标坐标，添加鼠标移动事件
        document.addEventListener('mousemove', function (e) {
            // 修改图片坐标，图片默认位于左上角进行移动，通过事件对象获取鼠标位置时，
            // 将图片向 x、y的负方向移动实现鼠标居中效果
            //必须添加 px 单位 才能实现图片移动
            img.style.left = e.pageX - 50 + 'px'
            img.style.top = e.pageY - 40 + 'px'
        })
    </script>
</body>
```

> 修改css样式时，必须添加 px 单位 才能实现图片移动

[网页特效：图片跟随鼠标移动](D:\Java code\3.  javaScript编程\3.2 webapi\day04\04-跟随鼠标的天使.html)

---

#### 案例：按下回车发布微博案例

需求：按下回车键盘，可以发布信息分析：

1. 必须使用 keyup ，键盘弹起后才执行

2. `按下回车键发布新闻，调用鼠标点击事件  send.click()`

```javascript
// 按下回车发布信息
    // 事件侦听的三要素
    // keyup'键盘事件' 是用户按下键盘弹起后才会执行
    // 如果使用 keydown 则用户按下键盘执行 发布清空操作，但键盘弹起后会多输入一个回车符
    textarea.addEventListener('keyup', function (e) {
      // 触发键盘事件后，事件对象里会保存对应键的key值
      console.log(e);
      // 判断当用户按下 回车键时，实现发布功能
      // 按下回车时，key里的值为enter
      if (e.key === 'Enter') {
        // 调用 鼠标点击事件
        send.click()
      }
    })
```

> `keydown 是键盘按下时触发，触发的时间较早 （keydown 一般用于移动图标）；keyup是键盘按下并弹起时触发，触发时间较晚 （keyup一般用于键盘输入事件）`
>
>  如果使用 keydown 则用户按下键盘执行 发布清空操作，但键盘弹起后会多输入一个回车符

[网页特效：发布微博](D:\Java code\3.  javaScript编程\3.2 webapi\day04\微博发布案例\微博发布案例.html)

---

### 事件流

![image-20220925112216633](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220925112216633.png)

> `事件冒泡是默认的事件执行流程`
>
> `DOM对象中对象层级 ： 顶层对象 document > html对象 > body对象 > 标签对象`

#### 1. 事件冒泡

- `在标签多层嵌套的结构中，如果子元素和父元素存在同样的事件触发类型`，当子元素的事件被触发时，父级元素中的事件也会被依次被触发，这一过程被称为事件冒泡
- `如果给父元素添加事件，子元素并未添加时，单击子元素后因为冒泡的原理，父元素的事件会被触发`

```js
<body>
    <div class="father">
        <div class="son"></div>
    </div>
    <script>
        let fa = document.querySelector('.father')
        let son = document.querySelector('.son')
        fa.addEventListener('click', function () {
            alert('我是爸爸')
        }, true)
        son.addEventListener('click', function () {
            alert('我是儿子')
        }, true)
        document.addEventListener('click', function () {
            alert('我是爷爷')
        }, true)

        // btn.onclick = function() {}
    </script>
</body>
```

> 给子元素添加点击事件 click 时，如果父级也存点击事件 click，`则触发子元素事件的同时父级的事件同样会被触发`( 事件冒泡)

#### 2. 事件捕获

-   与冒泡类似，子父级中存在同类型的事件时，从父级元素开始去触发对应的事件 (从外到里)

![image-20220925152009733](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220925152009733.png)

> `添加事件监听方法时，第三参数就是是否使用捕获机制，默认为false 则事件执行流程默认为冒泡模式，如要开启改为true`

#### 3. 阻止事件流动

![image-20220925152754359](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220925152754359.png)

```js
son.addEventListener('click', function (e) {
            alert('我是儿子')
            // 阻止流动 Propagation 传播
            e.stopPropagation()
        })
```

>  e.stopPropagation()  阻断事件流动传播，父元素上的同类型事件不会触发

#### 4. 阻止默认行为

![image-20220925154505973](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220925154505973.png)

#### 案例：鼠标经过事件

- mouseover 和 mouseout 会有冒泡效果 

- `mouseenter  和 mouseleave   没有冒泡效果(推荐)`

```js
<body>
    <div class="father">
        <div class="son"></div>
    </div>
    <script>
        let fa = document.querySelector('.father')
        let son = document.querySelector('.son')
        // 使用mouseenter 事件，鼠标经过子级盒子时，不会触发事件
        fa.addEventListener('mouseenter', function () {
            console.log(111)
        })
    </script>
</body>
```

> 使用 mouseover  事件时，虽然子级未添加同类型事件，但是鼠标经过子级盒子时，依然会触发父级事件
>
> `在使用鼠标经过事件时，推荐使用mouseenter  和 mouseleave   `

[网页特效：鼠标经过事件](D:\Java code\3.  javaScript编程\3.2 webapi\day04\07-mouseover和mouseenter区别.html)

---

### 事件委托

- 给父级元素加事件,点击所有的子元素都可以触发事件（ 替代循环遍历的方法）

- `事件委托其实是利用事件冒泡的特点， 给父元素添加事件，子元素可以触发实现：`

- `事件对象.target 可以获得当前点击的元素对象`

```js
<body>
    <ul>
        <li>我是第1个小li</li>
        <li>我是第2个小li</li>
        <li>我是第3个小li</li>
        <li>我是第4个小li</li>
        <li>我是第5个小li</li>
    </ul>
    <script>
        // 事件委托是给父级添加事件 
        let ul = document.querySelector('ul')
        ul.addEventListener('click', function (e) {
            
            //  e.target 得到当前的点击的子元素对象 并设置颜色为红色
            e.target.style.color = 'red'
        })
    </script>
</body>

```

[网页特效：使用事件委托改变 li的颜色](D:\Java code\3.  javaScript编程\3.2 webapi\day04\10-事件委托.html)

---

## DOM- 网页特效篇

---

### 滚动事件

![image-20220927114932912](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927114932912.png)

> `给浏览器页面添加事件时，用window 对象`

### 加载事件

![image-20220927115959666](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927115959666.png)

> `监听页面所有资源，给window添加 load 加载事件`，也可以针对某个资源添加 加载事件

#### 1. DOMContentLoaded 事件

- `初始的 HTML 文档被完全加载和解析后，而无需等待样式表、图像等完全加载就可以执行函数`

![image-20220927120920574](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927120920574.png)

> docunment 指 html 文档对象，(页面中的所有标签对象)， `一般都是给 document 对象添加DOMContentLoaded  事件`

### 元素大小和位置

#### 1. scroll 

- 使用scroll 来检测页面滚动的距离

![image-20220927123143693](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927123143693.png)

> `scrollWidth和scrollHeight 是指元素内容区域的宽和高（不包含滚动条,返回值不带单位），当内容超出盒子宽高时，给内容区域添加滚动条时，内容区域的宽会缩小，高则会增加`
>
> `scrollTop 当滚动条向下滚动时，页面的内容会向上移动，这时移动后超出屏幕的内容距离 就是 scrollTop`； scrollLeft 同理；该属性可以修改

绑定页面滚动事件，获得页面滚动距离

![image-20220927125051638](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927125051638.png)

> 页面滚动事件 用window 对象
>
> document.documentElement  获得  html 标签对象（包含页面所有标签的对象），`必须通过html标签对象的 scroll 属性才能得到页面滚动距离`

#### 2. offset

通过offset 可以 得到元素在页面中的位置

![image-20220927161441413](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927161441413.png)

> `offsetWidth和offsetHeight  获取元素（盒子）的自身宽高`、包含元素自身设置的宽高、padding、border
>
> `offsetTop和offsetLeft 得到位置以 带有定位的父级为准，如果都没有则以 文档左上角 为准`
>
> **offsetLeft和offsetTop** 注意是只读属性，不能修改，`且是一个固定值，页面初次加载时距离顶部的距离`；

#### 3. client (了解)

![image-20220927175421269](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927175421269.png)

> clientTop、clientLeft  是指 可视区域到边框的距离，就是指边框的宽度，没设置边框则为0  （了解）
>
> document.documentElement.clientWidth 可以获得手机端屏幕的宽度 

#### 4. scroll、offset、client 总结

![image-20220927180644553](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927180644553.png)

```js
 <script>
        // scroll得到盒子内容的宽高 （了解）
        let div = document.querySelector('div')
        console.log(div.scrollWidth)  // 150 不带单位
        console.log(div.scrollHeight)  // 336 不带单位
        console.log('----------------------------')
        // offset 盒子元素的大小 = 盒子本身的宽度和高度 + padding + border
        console.log(div.offsetWidth)  // 150 不带单位
        console.log(div.offsetHeight)  // 150 不带单位
        
        //  client 当前可视区域  不包含滚动条  边框等等
        console.log('----------------------------')
        console.log(div.clientWidth)
        console.log(div.clientHeight)
        console.log(div.clientTop)  // 边框的宽度  了解  
        console.log(div.clientLeft)
    </script>
```

[网页特效：元素大小位置属性总结](D:\Java code\3.  javaScript编程\3.2 webapi\day05\03-三大家族宽度对比.html)

---

### 案例练习

#### 案例：手风琴效果（切片效果）

1. 当我们鼠标经过， 当前的小li 宽度变大 800px 其余的小li 变为 100px 

2. 鼠标离开事件， 所有的小li 都要复原 宽度为 240px
3. 使用排他思想，先遍历设置统一样式，再给当前元素设置特殊样式

```js
<script>
  // 1. li 默认有个宽度是 240像素  
  // 2. 当我们鼠标经过， 当前的小li 宽度变大 800px 其余的小li 变为 100px 
  // 3. 鼠标离开事件， 所有的小li 都要复原 宽度为 240px
  // (1) 获取元素
  let lis = document.querySelectorAll('li')
  // (2) 绑定鼠标经过和离开事件
  for (let i = 0; i < lis.length; i++) {
    // (3) 鼠标经过
    lis[i].addEventListener('mouseenter', function () {
      // 排他思想  默认所有 li的宽度为 100px
      for (let j = 0; j < lis.length; j++) {
        lis[j].style.width = '100px'
      }
      //当前点击的 li 宽度为800px
      this.style.width = '800px'
    })
    // (4) 鼠标离开
    lis[i].addEventListener('mouseleave', function () {
      for (let j = 0; j < lis.length; j++) {
        lis[j].style.width = '240px'
      }
    })
  }
</script>
```

[网页特效：手风琴](D:\Java code\3.  javaScript编程\3.2 webapi\day05\手风琴\手风琴.html)

---

#### 案例：页面滚动显示返回顶部按钮

![image-20220927155627675](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927155627675.png)

```js
 <script>
        // 0 获取元素
        let backtop = document.querySelector('.backtop')
        // 一. 页面滚动事件
        window.addEventListener('scroll', function () {
            // 2. 页面检测滚动的距离
            // console.log(document.documentElement.scrollTop)
            let num = document.documentElement.scrollTop
            // 3. 进行判断显示和隐藏
            if (num >= 500) {
                //显示那个元素
                backtop.style.display = 'block'
            } else {
                // 否则隐藏元素
                backtop.style.display = 'none'
            }
        })
        // 二、点击链接返回顶部 backtop.children[1]
        backtop.children[1].addEventListener('click', function () {
            // 返回顶部
            // scrollTop 可读写
            document.documentElement.scrollTop = 0
        })
    </script>
```

[网页特效：页面滚动显示返回顶部按钮](D:\Java code\3.  javaScript编程\3.2 webapi\day05\仿新浪返回顶部\index.html)

---

#### 案例：仿京东固定导航栏案例

![image-20220927163442070](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927163442070.png)

```html
<body>
    <div class="header">我是顶部导航栏</div>
    <div class="content">
        <div class="sk">秒杀模块</div>
    </div>
    <div class="backtop">
        <img src="./images/close2.png" alt="">
        <a href="javascript:;"></a>
    </div>
    <script>
        let sk = document.querySelector('.sk')
        let header = document.querySelector('.header')
        // 1. 页面滚动事件
        window.addEventListener('scroll', function () {
            // console.log(11)
            // 要检测滚动的距离
            // console.log(document.documentElement.scrollTop)
            // console.log(sk.offsetTop)
            // 2. 要检测滚动的距离 >= 秒杀模块的offsetTop 则滑入
            if (document.documentElement.scrollTop >= sk.offsetTop) {
                // 每次滚动都设置，导航栏距离顶部距离始终为0
                header.style.top = '0'
            } 
            else {
                header.style.top = '-80px'
            }
        })
    </script>
</body>
```

> 顶部导航栏top设置为 -80px （实现默认隐藏效果），当移动的距离大于 秒杀模块时显示，小于时则 重新设置为 -80px 实现隐藏效果

[网页特效：仿京东固定导航栏案例](D:\Java code\3.  javaScript编程\3.2 webapi\day05\仿京东固定头部\index.html)

---

#### 案例：电梯导航

需求：点击可以页面调到指定效果

①：点击当前 小导航，当前添加active，其余移除active

②：得到对应 内容 的 offsetTop值

③：点击左侧导航栏时，右侧内容区自动移动到顶部显示 

![image-20220927171921246](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927171921246.png)

```js
 <script>
        // 1. 获元取素  
        let items = document.querySelectorAll('.item')
        // 内容的盒子获取
        let neirongs = document.querySelectorAll('.neirong')
        // 2. 左侧aside 模块 点击谁，谁高亮
        for (let i = 0; i < items.length; i++) {
            items[i].addEventListener('click', function () {
                // 找到上一个active 移除类
                document.querySelector('.aside .active').classList.remove('active')
                // 点击谁谁添加类
                this.classList.add('active')
                // 3. 右侧内容跟随走动  让页面滚动到对应的offsetTop值位置         
                document.documentElement.scrollTop = neirongs[i].offsetTop
            })
        }
    </script>
```

> document.documentElement.scrollTop = neirongs[i].offsetTop，`通过offsetTop 获取标签相对于浏览器顶部的位置（没有定位父级的情况下），再赋值给 scrollTop ，让标签到浏览器顶部的内容区域超出屏幕显示，最终实现该标签内容在浏览器顶部显示效果`。
>
> `如果页面内容有限（滚动条滑到底部，也无法使内容在顶部显示）`，则通过修改scrollTop的值，也无法将对应的内容区域移动到顶部显示

[网页特效：电梯导航](D:\Java code\3.  javaScript编程\3.2 webapi\day05\05-电梯导航案例.html)

---

## BOM- 操作浏览器

---

### Window对象

#### 1. BOM 浏览器对象模型

![image-20220928162706419](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928162706419.png)

> BOM 浏览器对象模式 其实就是指 window对象模型

```js
<script>
        // window.document.querySelector('.box')
        // window.setInterval()
        // function fun() {
        // }
        // window.fun()
        addEventListener('scroll', function () {
            console.log(111)
        })
        window.alert()
        window.prompt()
        console.log(window)
    </script>
```

> `一般省略对象直接调用的方法，都是window对象下的方法`

#### 2. JS 执行机制

`JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。`这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： `如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉`

----

同步和异步的概念

**同步**：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步

做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

**异步**：你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

`他们的本质区别`： 这条流水线上`各个流程的执行顺序不同`

---

同步与异步任务

![image-20220928180536310](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928180536310.png)

> 同步任务是会进入主线程上的执行栈后优先执行；
>
> 异步任务一般通过回调函数实现的，会添加到任务队列中（消息队列）

---

任务执行流程

![image-20220928181525391](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928181525391.png)

> 同步任务在执行栈中优先执行，`异步任务通过异步处理进程进行判断来确定进入任务队列的顺序，当主线程中的任务执行完毕后，按照之前判断的顺序 将任务队列先执行的任务推入主线程中的任务栈执行`
>
> 这不断获得、执行、再获得任务的过程称为`事件循环 event loop`

![image-20220928182511333](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928182511333.png)

#### 3. location 对象

![image-20220928184052408](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928184052408.png)

##### 3.1 href 属性

href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转

```js
<script>
        console.log(location.href)  // 得到当前网页的 url地址   可读写
        //  该属性可读写， 给 location.href 赋值  可以直接实现页面跳转
        location.href = 'http://www.itcast.cn'
    </script>
```

>  href 属性可读写， 给 location.href 赋值  可以直接实现页面跳转

5秒钟之后跳转的页面

需求：用户点击可以跳转，如果不点击，则5秒之后自动跳转，要求里面有秒数倒计时

```js
<a href="http://www.itcast.cn">支付成功，<span>5</span> 秒之后跳转首页</a>
    <script>
        let a = document.querySelector('a')
        let num = 5
        let timer = setInterval(function () {
            num--
            a.innerHTML = `支付成功，<span>${num}</span> 秒之后跳转首页`
            if (num === 0) {
                // 时间结束时，清除定时器，并进行页面跳转
                clearInterval(timer)
                // 跳转页面
                location.href = 'http://www.itcast.cn'
            }
        }, 1000)
    </script>
```

##### 3.2 search 属性

search 属性获取地址中携带的参数，符号 ？后面部分，`一般用于获得表单中用户输入的值`

```js
// 表单页面，当用户提交时，会访问 target.html 并跟上参数 ？username=123
<form action="target.html">
        <input type="text" name="username">// 文本框输入 123
        <button>提交</button>
    </form>

 console.log(location.search)  // 打印 ：？username=123 ，可以获得地址中携带的参数
```

##### 3.3 hash 属性

hash 属性获取地址中的哈希值，符号 # 后面部分

`后期vue路由的铺垫，经常用于不刷新页面`，显示不同页面，比如 网易云音乐

```js
<body>
    <a href="#one">第一个</a>
    <a href="#two">第二个</a>
    <script>
        console.log(location.hash) // 打印： #one、#two
    </script>
</body>
```

> 链接地址用 #号开头，页面不会刷新；`location.hash 可以得到地址栏中 # 后面的内容`

##### 3.4 reload 方法

reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新

```js
<body>
    <button>刷新</button>
    <script>
        let btn = document.querySelector('button')
        btn.addEventListener('click', function () {
            // reload() 刷新方法 有本地缓存   
            //强制刷新 ctrl + f5   直接更新最新内容从网上拉去，不走本地缓存
            location.reload(true)
        })
    </script>
</body>
```

> reload() 刷新方法 有本地缓存 ; `reload(true)  强制刷新 ctrl + f5   直接更新最新内容`

#### 4. navigator 对象

navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

通过 userAgent 检测浏览器的版本及平台

```js
<script>
        // 检测 userAgent（浏览器信息）
        !(function () {
            const userAgent = navigator.userAgent
            // 验证是否为Android或iPhone
            const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/)
            const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
            // 如果是Android或iPhone，则跳转至移动站点
            if (android || iphone) {
                location.href = 'http://m.itcast.cn'
            }
        })()

    </script>
```

> 检测到是移动设备浏览网页时，则跳转移动端网页

#### 5. histroy 对象

history 的数据类型是对象，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等 

![image-20220928205956263](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220928205956263.png)

```js
<button class="forward">前进</button>
    <button class="back">后退</button>
    <script>
        let qianjin = document.querySelector('.forward')
        let houtui = document.querySelector('.back')
        qianjin.addEventListener('click', function () {
            // history.forward()
            history.go(1)
        })
        houtui.addEventListener('click', function () {
            // history.back()
            history.go(-1)
        })
    </script>
```

### swiper 插件

插件: 就是别人写好的一些代码,我们只需要复制对应的代码,就可以直接实现对应的效果；swiper 插件主要实现图片轮播效果的插件

学习swiper插件的基本过程

- 熟悉`swiper 官网` https://www.swiper.com.cn/ 

- 看在线演示的`demo` https://www.swiper.com.cn/demo/index.html

- 查看基本使用流程 https://www.swiper.com.cn/usage/index.html

- 查看`APi文档`,去配置自己的插件 https://www.swiper.com.cn/api/index.html

> 注意: 多个swiper同时使用（页面需要多个轮播图）的时候, 类名需要注意区分
>
> swiper 最大的类（swiper-container ）后 再添加个新类，通过新的类名 实例化swiper对象
>
> ```js
> <div class="swiper-container one">
> 
> var swiper = new Swiper('.one', {}）
> ```
>
> 

下载使用 swiper插件

![image-20220929091709835](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929091709835.png)

> [Swiper使用方法 - Swiper中文网](https://www.swiper.com.cn/usage/index.html)

![image-20220929091240053](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929091240053.png)

解压缩 swiper.zip 

![image-20220929091437289](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929091437289.png)

> 将js 和css 文件 拷贝到项目中

先在项目中引用插件的js、css文件, `在swiper中找到符合自己需求的demo https://www.swiper.com.cn/demo/index.html`，在新窗口打开后，通过右键查看网页源代码，对需要的 css，js代码就行复制粘贴

```html
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    // 引入 css 文件
    <link rel="stylesheet" href="./css/swiper-bundle.min.css">
    <style>
     //  复制swiper  demo中的css 代码
    </style>
</head>

<body>
    <div class="box">
      //  复制swiper  demo中的标签
    </div>
      // 引入 js 文件
    <script src="./js/swiper-bundle.min.js"></script>
    
    <script>
        <!--js 代码 要放到 js引入文件的下面 -->
    </script>
</body> 
```

> 将swiper 轮播 代码放入自定定义的盒子中；修改swiper样式可以通过浏览器检查元素找到 类名后在 style 最后添加来覆盖原样式；`修改swiper 的js代码 则需要查看 官方api文档` https://www.swiper.com.cn/api/index.html

[网页特效：swiper 实现轮播图](D:\Java code\3.  javaScript编程\3.2 webapi\day06\14-我们需要一个轮播图.html)

---

### 本机存储

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 

1、数据存储在用户浏览器中

2、设置、读取方便、甚至页面刷新不丢失数据

3、容量较大，sessionStorage和localStorage约 5M 左右

---

localStorage

1、生命周期永久生效，除非手动删除 否则关闭页面也会存在

2、可以多窗口（页面）共享（同一浏览器可以共享）

3、以键值对的形式存储使用

![image-20220929103233142](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929103233142.png)

```js
 // 存储数据 localStorage.setItem('键', '值')
        localStorage.setItem('uname', 'pink老师')
         localStorage.setItem('age', 18)
        // 获取数据
        // localStorage.getItem('键')
         console.log(localStorage.getItem('uname'))
        // 删除数据
         localStorage.removeItem('uname')
         // 1. 存储复杂数据类型（引用数据类型）
        let obj = {
            uname: '刘德华',
            age: 17,
            address: '黑马程序员'
        }
       
        // 复杂数据类型一定要转换为json字符串在进行存储 （因为本地存储只能存储字符串）
        localStorage.setItem('obj', JSON.stringify(obj))

      // 取数据  可以使用 JSON.parse()  将json字符串转换为对象
        console.log(JSON.parse(localStorage.getItem('obj')))
```

> `本地只能存储字符串,无法存储复杂数据类型.需要将复杂数据类型转换成JSON字符串,在存储到本地`,JSON 属性和值都是双引号进行包含
>
> ```js
> //  json格式的数据
> let obj = {
>          "uname": "刘德华",
>          "age": "17",
>         "address": "黑马程序员"
>       }
> ```
>
> 数据进行本地存储时 `JSON.stringify(复杂数据类型)`  将复杂数据转换成JSON字符串 
>
> 从本地存储中取出数据时，`JSON.parse(JSON字符串)  `将JSON字符串转换成对象 

## 正则表达式

- 正则表达式（Regular Expression）是`用于匹配字符串中字符组合的模式`。在 JavaScript中，正则表达式也是对象通常用来查找、替换那些符合正则表达式的文本，许多语言都支持正则表达式。

---

正则表达式在 JavaScript中的使用场景：

例如：

1. 验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)    /^[a-z0-9_-]{3,16}$/

2. 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。

![image-20220930112619721](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930112619721.png)

### 正则语法

`表达式的前后添加双斜杠,字符之间不能存在空格，则为正则表达式 （正则表达式是个对象，可以调用 test 方法）`

![image-20220930113613341](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930113613341.png)

![image-20220930113828677](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930113828677.png)

> 使用 test 时 查看正则表达式与指定的字符串是否匹配时，`被检测的字符串中 包含有 正则表达式的字符串时（正则表达式中有一个字符串不在被检测的字符串中时，也是不匹配），表示匹配 并返回 true`
>
> ```js
>  let reg = /在端/
>         // 2. 检测是否匹配 test （重点）
>         let str = '我们大家都在学前端'
>         console.log(reg.test(str))  // false
> ```
>
> 首先字符必须在被检测字符串中存在， 且也必须相连 ， ( ''在'' 的后面只能跟 ''学''  才返回true )

![image-20220930114615240](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930114615240.png)

```js
    <script>
        // 定义正则表达式   reg 里面存的是对象
        let reg = /java/
        // 2. 检测是否匹配 test （重点）
        let str = '我们大家都在学前端'
        // console.log(reg.test(str))
        // 3. 检索 exec()
        // 返回的是数组
        console.log(reg.exec(str))   
    </script>
```

> exect 方法 如果`匹配成功 返回的是一个数组`，数组中包含了当前匹配的字符串，字符串所在的索引号 等数据；`匹配失败则 返回 null`

[网页特效：正则表达式 demo](D:\Java code\3.  javaScript编程\3.2 webapi\day07\01-正则表达式使用.html)

---

### exec() 函数的使用

- exec() 函数用于检索字符串中的正则表达式的匹配。失败返回 null， 成功返回数组

![image-20221104124154220](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221104124154220.png)

- `正则表达式中 ( ) 包起来的内容表示一个分组，可以通过分组来提取自己想要的内容`，示例代码如下：

![image-20221104124414826](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221104124414826.png)

- replace() 函数用于在字符串中用一些字符替换另一些字符，语法格式如下：

![image-20221104124529716](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221104124529716.png)

- 使用while循环replace

![image-20221104124834180](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221104124834180.png)

---

### 元字符(特殊字符）

是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。

比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklm…..  但是换成元字符写法： [a-z] 

**参考文档：**

 MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions

正则测试工具: http://tool.oschina.net/regex

为了方便记忆和学习，我们对众多的元字符进行了分类：

1. 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾）

2. 量词 （表示重复次数）

3. 字符类 （比如 \d 表示 0~9）

---

#### 1. 边界符

![image-20220930124422494](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930124422494.png)

```js
<script>
        // ^ 开头
        console.log(/^哈/.test('二哈'))  // false 
        console.log(/^哈/.test('我开心的哈哈大笑'))  // false 
        console.log(/^哈$/.test('我开心的哈哈大笑'))  // false 
        console.log(/^哈$/.test('哈哈'))  // false 
        console.log(/^哈$/.test('哈'))  // true  精确匹配
    </script>
```

> `如果 ^ 和 $ 在一起，表示必须是精确匹配，被检测的字符串与 正则表达式中的必须完全相等`

#### 2. 量词

量词用来 设定某个模式出现的次数

![image-20220930125035305](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930125035305.png)

```js
 // console.log(/a/.test('a'))
        //  * 量词 n >= 0  出现 0 次 或者多次
        console.log(/a*/.test('')) // true
        console.log(/a*/.test('a'))
        console.log(/a*/.test('aa'))
        console.log(/a*/.test('aaaaaaaa'))
        console.log(/a*/.test('b'))
        console.log('--------------------------')
        //  + 量词 n >= 1  出现 1次或者多次
        console.log(/a+/.test('')) // false
        console.log(/a+/.test('a'))
        console.log(/a+/.test('aa'))
        console.log(/a+/.test('aaaaaaaa'))
        console.log(/a+/.test('b')) // false
         console.log('--------------------------')
        //  ? 出现 0 || 1  重复出现 0 次或者 1次
        console.log(/^a?$/.test('')) // true
        console.log(/^a?$/.test('a'))
        console.log(/^a?$/.test('aa'))
	 console.log('--------------------------')
  // {n}   只能出现 n次   符号之间不要加空格
        console.log(/^a{3}$/.test('aa'))
        console.log(/^a{3}$/.test('aaa')) // true
        console.log(/^a{3}$/.test('aaaa'))
	 console.log('--------------------------')
        // {n,}   >= n   a 出现次数 大于等于3 
        console.log(/^a{3,}$/.test('aa'))
        console.log(/^a{3,}$/.test('aaa'))
        console.log(/^a{3,}$/.test('aaaa'))
        console.log('--------------------------')
        // {n,m}   >= n  <= m   a出现次数在 3-6 之间
        console.log(/^a{3,6}$/.test('aa')) // false
        console.log(/^a{3,6}$/.test('aaa'))
        console.log(/^a{3,6}$/.test('aaaa'))
        console.log(/^a{3,6}$/.test('aaaaa'))
        console.log(/^a{3,6}$/.test('aaaaaaaa')) // false
```

> 量词一般添加在 字符后面

[正则表达：量词 demo](D:\Java code\3.  javaScript编程\3.2 webapi\day07\03-元字符-量词.html)

---

#### 3. 字符类

![image-20220930131924882](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930131924882.png)

![image-20220930170854522](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930170854522.png)

```js
 // 字符类 [-] 连字符
        console.log(/^[abc]$/.test('abc')) // false
        console.log(/^[abc]$/.test('a'))  // true
        console.log(/^[abc]$/.test('b'))  //true
        console.log(/^[abc]$/.test('c'))  //true 
        console.log(/^[abc]$/.test('cc')) // false

        console.log('------------------------------------')
        // 26个英文字母选其中的一个
        console.log(/^[a-zA-Z]$/.test('d')) // true
        console.log(/^[a-zA-Z]$/.test('D')) // true
        console.log(/^[a-zA-Z]$/.test('DD')) // false
        console.log(/^[a-zA-Z0-9]$/.test('6')) // true
        console.log(/^[a-zA-Z0-9-_]$/.test('6')) // true

        console.log(/^abc+$/.test('cc')) // false
```

> /^[abc]$/ 表示 只能选择 a、b、c中的一个；`/^[a-zA-Z0-9]$  表示  在 a-z 、A-Z 、0 -9 之间选择一个数 `，
>
> 如果0-9 后面跟着 - _   (/^[a-zA-Z0-9 - _ ]$ ) ,表示  -_  ` 减号和下划线  都在取值范围`
>
> `当量词与字符类连用时，只能限制最近的字符类`,  ^[1-9] [0-9] {4, }$  表示 第一个数 1-9 之间， 第二个数 0-9 之间  且重复出现4 次以上

>  [ ] 里面加上 ^ 取反符号 比如：` [^a-z] 匹配除了小写字母以外的字符`
>
> . 匹配除换行符之外的任何单个字符

3.1 字符类简介写法

![image-20220930182101392](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930182101392.png)

> 日期格式的正则表达式 含有特殊符号减号 ：输入年、月 后 必须跟 减号 才会返回true`（ 正则表达式中 除去 边界符、量词、字符类、出现的其他特殊符号或者单独出现的字母、中文，必须按照顺序输入）`

#### 4. 修饰符 

![image-20220930184744514](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930184744514.png)

![image-20220930185509823](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220930185509823.png)

使用replace 过滤敏感词

```js
<body>
    <textarea name="" id="" cols="30" rows="10"></textarea>
    <button>发布</button>
    <div></div>
    <script>
        let btn = document.querySelector('button')
        let textarea = document.querySelector('textarea')
        let div = document.querySelector('div')
        btn.addEventListener('click', function () {
            // 过滤用户输入的内容
            div.innerHTML = textarea.value.replace(/激情|基情/g, '**')
            // div.innerHTML = textarea.value
        })
    </script>
</body>
```

> `/激情|基情/g  ` 正则表达式中 需要添加多个条件时，用 |  连接； 后面添加 g （正则修饰符 ）表示可以找到所有满足的结果，不添加则默认找到一个

[网页特效：过滤敏感词](D:\Java code\3.  javaScript编程\3.2 webapi\day07\06-过滤敏感词.html)

---

### 案例练习

---

#### 验证用户名

需求：用户名要求用户英文字母,数字,下划线或者短横线组成，并且用户名长度为 6~16位

```js
//css 样式
.error {
            color: red;
            background: url(./error1.png) no-repeat left center;
        }

        .right {
            color: green;
            background: url(./right.png) no-repeat left center;
        }
     ---------------------------------------------------------------------------------------------   
   <body>
    <input type="text">
    <span></span>
    <script>
        let input = document.querySelector('input')
        let span = input.nextElementSibling
        input.addEventListener('blur', function () {
            // 用户必须输入 6-16 位， 可以取值 减号 下划线 a-z 的大小或者小写 0到9
            if (/^[a-zA-Z0-9-_]{6,16}$/.test(input.value)) {
                span.className = 'right'
                span.innerHTML = '输入正确'
            } else {
                span.className = 'error'
                span.innerHTML = '只能要输6~16位字符'
            }
        })
    </script>
</body>
```

> 使用 className 添加类 后会覆盖之前的类名

[网页特效：验证用户输入](D:\Java code\3.  javaScript编程\3.2 webapi\day07\05-验证用户名案例.html)

---

## webApi 案例

---

### 案例：网页轮播图效果

![image-20220919105310360](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220919105310360.png)

```html
<body>
    <div class="img-box">
        <img class="pic" src="images/b01.jpg" alt="第1张图的描述信息">
        <div class="tip">
            <h3 class="text">挑战云歌单，欢迎你来</h3>
        </div>
    </div>

    <script>
        // 数据
        let data = [
            {
                imgSrc: 'images/b01.jpg',
                title: '挑战云歌单，欢迎你来'
            },
            {
                imgSrc: 'images/b02.jpg',
                title: '田园日记，上演上京记'
            },
            {
                imgSrc: 'images/b03.jpg',
                title: '甜蜜攻势再次回归'
            },
            {
                imgSrc: 'images/b04.jpg',
                title: '我为歌狂，生为歌王'
            },
            {
                imgSrc: 'images/b05.jpg',
                title: '年度校园主题活动'
            },
            {
                imgSrc: 'images/b06.jpg',
                title: 'pink老师新歌发布，5月10号正式推出'
            },
            {
                imgSrc: 'images/b07.jpg',
                title: '动力火车来到西安'
            },
            {
                imgSrc: 'images/b08.jpg',
                title: '钢铁侠3，英雄镇东风'
            },
            {
                imgSrc: 'images/b09.jpg',
                title: '我用整颗心来等你'
            },
        ]

        // 1. 获取元素  图片  和  h3
        let pic = document.querySelector('.pic')
        let text = document.querySelector('.text')
        // i 记录图片的张数
        let i = 0
        // 2.开启定时器
        setInterval(function () {
            i++
            // 修改图片的src属性
            // console.log(data[i].imgSrc)
            pic.src = data[i].imgSrc
            // 修改文字内容
            text.innerHTML = data[i].title

            // 无缝衔接，显示最后一张图片时，给i 重新赋值 为 -1
            if (i === data.length - 1) {
                // i++ 后初始值 为0
                i = -1
            }
            
        }, 1000)
    </script>
</body>

</html>
```

> 定义一个对象数组存储 图片和文字信息，开启定时器每隔一秒切换一张图片，且实现图片循环；
>
> `定时器需要实现每隔一秒，根据对象数组的下标取出对应的图片和文字`
>
> - 定义全局变量 i  初始值为 0 代表对象数组下标；
> - 定时器每次执行后，i++，当取到最后一张图片时，对应的索引重置为0 来显示第一张图片，考虑每次执行 i 都会加 1，此时 i 值应设为 -1

[网页特效：图片轮播](D:\Java code\3.  javaScript编程\3.2 webapi\day01\综合案例-焦点图案例.html)

---

### 案例：Tab栏切换

分析：

①：点击当前选项卡，当前添加类，其余的兄弟移除类， 排他思想

②：下面模块盒子全部隐藏，当前的模块显示

![image-20220921112354839](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220921112354839.png)

```html
<body>
  <div class="wrapper">
    <ul class="tab">
      <li class="tab-item active">国际大牌<span>◆</span></li>
      <li class="tab-item">国妆名牌<span>◆</span></li>
      <li class="tab-item">清洁用品<span>◆</span></li>
      <li class="tab-item">男士精品</li>
    </ul>
    
    <div class="products">
      <div class="main active">
        <a href="###"><img src="imgs/guojidapai.jpg" alt="" /></a>
      </div>
      <div class="main">
        <a href="###"><img src="imgs/guozhuangmingpin.jpg" alt="" /></a>
      </div>
      <div class="main">
        <a href="###"><img src="imgs/qingjieyongpin.jpg" alt="" /></a>
      </div>
      <div class="main">
        <a href="###"><img src="imgs/nanshijingpin.jpg" alt="" /></a>
      </div>
    </div>

  </div>

  <script>
    // 0. 获取元素
    // 得到所有的小li  
    let lis = document.querySelectorAll('.tab .tab-item')
    let divs = document.querySelectorAll('.products .main')
    // 1. 头部tab栏切换模块
    // 1.1 先给4个小li添加点击事件
    for (let i = 0; i < lis.length; i++) {
      lis[i].addEventListener('click', function () {
        // console.log(11)
        // 找到以前的active 类，移除掉 
        document.querySelector('.tab .active').classList.remove('active')
        // 当前的元素添加
        this.classList.add('active')

        // 2. 底部显示隐藏模块  一定要写到点击事件的里面
        document.querySelector('.products .active').classList.remove('active')

        // div对应序号的那个加上active 
        divs[i].classList.add('active')
      })
    }
  </script>

</body>

</html>
```

[网页特效：Tab栏切换](D:\Java code\3.  javaScript编程\3.2 webapi\day02\tab栏案例\index.html)

---

### 案例：发布微博案例

![image-20220923134128069](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220923134128069.png)

> 1. `对文本框内容进行监听，显示内容的长度`
>
>    分析：注册input事件 ；将文本的内容的长度，往对应的标签中添加内容的长度；表单的`maxlength属性`可以直接限制在200个数之间
>
>    代码：
>
>    ```html
>    <script>
>    textarea.addEventListener('input', function () {
>       // this.value 获得文本框的内容， 
>       useCount.innerHTML = this.value.length
>      })
>    ```
>
> 2. 判断如果用户输入内容为空，则提示不能输入为空, 并且直接return`（浏览器中空格与空字符串是不一样的,用户什么都不输入时表示为空字符串）`
>
>    分析：防止输入无意义空格, 使用字符串.trim()去掉首尾空格, 并将表单的value值设置为空字符串
>
>    代码：
>
>    ```html
>    <script>
>    send.addEventListener('click', function () {
>       if (textarea.value.trim() === '') {
>        // 用户输入大量空格时，需要并将表单的value值重新设置为空字符串
>       textarea.value = ''
>       //  内容长度设置为0
>       useCount.innerHTML = 0
>     return alert('内容不能为空')
>       }
>    ```
>
> 3. 用户点击发布时，显示用户头像，发布时间以及 发布内容
>
>    分析：先创建子节点，再创建父节点，向父节点中追加子节点（新追加的内容一直显示在第一个）；
>
>    ​		 `通过toLocaleString() 方法可以快速生成相应的时间格式  new Date().toLocaleString()；`
>
>    ​		  随机获取数据数组里面的内容, 替换图片（图片利用随机数）和名称；
>
>    ​		  发布完成后清空文本框；
>
>    代码：
>
>    ```html
>    <script>
>        // 随机数
>          function getRandom(min, max) {
>            return Math.floor(Math.random() * (max - min + 1)) + min
>          }
>          let random = getRandom(0, dataArr.length - 1)
>          
>    let li = document.createElement('li')
>          // 随机获取数据数组里面的内容, 替换newNode的图片和名字以及留言内容
>          li.innerHTML = `
>           <div class="info">
>          <img class="userpic" src=${dataArr[random].imgSrc}>
>          <span class="username">${dataArr[random].uname}</span>
>          <p class="send-time"> ${new Date().toLocaleString()} </p>
>          </div>
>          <div class="content">${textarea.value}</div>
>          <span class="the_del">X</span>
>          `
>           // 追加给 ul  用  父元素.insertBefore(子元素, 那个元素的前面)
>          // 父级里没有子标签时不影响追加效果
>          ul.insertBefore(li, ul.children[0])
>    
>           // 将文本框里面的内容重置为0
>          textarea.value = ''
>          //  文本框内容长度设置为0
>          useCount.innerHTML = 0
>    ```
>
> 4. 用户删除发布的内容
>
>    分析：删除留言  放到追加的前面；`用户在点击发布的同时绑定删除事件`;
>
>    ​          通过js创建的子节点，需要获取子节点 li 里的标签对象时，不能通过 document.querySelector() 获得对象，只能通过 
>
>    ​          li.querySelector('.the_del') 获取；
>
>    ​          ul.removeChild(li)  进行删除操作，`删除的是 li的对象，具有唯一性，能准确删除当前点击的内容`
>
>    代码：
>
>    ```html
>    <script>
>     // 需求4：删除留言  放到追加的前面
>          // 在事件处理函数里面获取点击按钮, 注册点击事件
>          //   (易错点: 必须在事件里面获取, 外面获取不到)
>          // 删除对应的元素(通过this获取对应的那条需要删除的元素)
>          // 教你一招: 放到追加进ul的前面，这样创建元素的同时顺便绑定了事件，赞~~
>          // js 创建的 子节点 ，
>          let del = li.querySelector('.the_del')
>          del.addEventListener('click', function () {
>            // 删除操作,删除的是 li的对象，具有唯一性，能准确删除当前点击的内容
>            ul.removeChild(li)
>          })           
>    ```

[网页特效：发布微博](D:\Java code\3.  javaScript编程\3.2 webapi\day03\微博发布案例\微博发布案例.html)

---

### 案例：购物车

![image-20220924100725940](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220924100725940.png)

> 1. 修改商品数量，计算每行商品的价格
>
>    1.1  document.querySelectorAll 获取 + - 号 以及 input 输入框的`数组对象`，循环遍历添加 + -号的单击事件；
>
>    1.2 `prices[i].innerText （通过 innerText 获取商品单价），inputs[i].value （vlaue 属性获取input 输入框中 的内容），totals[i].innerText = parseInt(prices[i].innerText) * inputs[i].value + '¥'   (两者相乘得到每行商品的价格`)；
>
>    注： parseInt 经常用于 去除商品价格单位，保留整数数字
>
>    ​		` div  span   ul  li  标签  有文字内容  怎么得到或则设置文字内容呢  元素.innerText   元素.innerHTML`
>    ​		`表单  input 单选 复选    textarea  select  怎么得到或则设置值   通过value属性 `
>    ​		 `特殊的  button 是通过inner来设置`
>
>    1.3 inputs[i].value++ 、reduces[i].disabled = false（点击加号商品数量自增，并启用 减号按钮）   inputs[i].value--、inputs[i].value <= 1 、 this.disabled = true（点击减号自减的同时，当减到1时，按钮重新变为禁用状态）；
>
>    ```html
>    <script>
>     // + - 删除是相同的，一一对应的 我们完全可以用一个for来遍历绑定事件
>        // +
>        let adds = document.querySelectorAll('.add')
>        // -
>        let reduces = document.querySelectorAll('.reduce')
>        // del
>        let dels = document.querySelectorAll('.del')
>        // 输入框input
>        let inputs = document.querySelectorAll('.count-c input')
>        // 单价 price  5
>        let prices = document.querySelectorAll('.price')
>        // 小计 total  5 * 2 = 10
>        let totals = document.querySelectorAll('.total')
>        
>         for (let i = 0; i < adds.length; i++) {
>          // 总价和单价是一样的
>          totals[i].innerText = prices[i].innerText
>          //1. 加号的操作
>          adds[i].addEventListener('click', function () {
>            // 点击了谁，就让对应的输入框自增就行了
>            inputs[i].value++
>            // 减号要启用
>            reduces[i].disabled = false
>            // prices[i].innerText  得到的是 5¥     parseInt('5¥')  === 5
>            console.log(parseInt(prices[i].innerText))
>            // 计算小计模块 
>            // prices[i].innerText  拿到商品价格 5￥ 
>            // 使用 parseInt 过滤单位 得到 5
>            totals[i].innerText = parseInt(prices[i].innerText) * inputs[i].value + '¥'
>            // 计算现在的总额 调用
>            result()
>          })
>    
>          //2. 减号的操作
>          reduces[i].addEventListener('click', function () {
>            // 点击了谁，就让对应的输入框自增就行了
>            inputs[i].value--
>            // prices[i].innerText  得到的是 5¥     parseInt('5¥')  === 5
>            // console.log(parseInt(prices[i].innerText))
>            // 判断如果表单里面的值 小于等于1 则，禁用按钮
>            if (inputs[i].value <= 1) {
>              this.disabled = true
>            }
>            // 计算小计模块 
>            // totals[i].innerText =  单价 * 数量  
>            // totals[i].innerText = 20
>            totals[i].innerText = parseInt(prices[i].innerText) * inputs[i].value + '¥'
>    
>            // 计算现在的总额 调用
>            result()
>          })
>    ```
>
> 2. 删除一行的商品数据
>
>    在循环中添加删除事件，`.parentNode 可以找到该子类的最近一级的父类对象，经常用于删除操作`
>
>    ```html
>    <script>
>     // 3. 删除操作
>          dels[i].addEventListener('click', function () {
>            // carBody 是包裹所有商品的大盒子
>            //  删除一行商品需要移除 td 子标签，
>            // del标签存在嵌套关系，  td>tr>del,想删除td ，需要找到父类的父类 this.parentNode.parentNode
>            carBody.removeChild(this.parentNode.parentNode)
>            // 每次删除后重新计算商品总数和价格
>            result()
>          })
>        }
>    ```
>
> 3. 计算购物车中商品的总价，商品总个数
>
>    当点击加号、减号、删除时总价、个数都会发送变化，将计算方法单独定义个函数，重复调用；
>
>    初次循环遍历绑定事件时，需要调用一次该方法；
>
>    `通过 小计栏 计算商品总价、通过input 栏里的值 计算商品总数量。当进行删除操作后，由于小计栏的数量发生变化，需要重新获取小计栏、input 栏的数组对象，取出最新的值并进行计算` 
>
>    ```html
>    <script>
>        // 以前数组求和的方式 累加
>        //  计算总价 result 函数  把所有的小计 totals 加起来的结果
>        function result() {
>          //进行删除操作后，需要重新获取 小计栏、input 栏的数组对象，取出最新的值
>          let totals = document.querySelectorAll('.total')
>          let inputs = document.querySelectorAll('.count-c input')
>          let sum = 0
>          let num = 0
>          for (let i = 0; i < totals.length; i++) {
>            // sum = sum + 小计的数字  10￥
>            sum = sum + parseInt(totals[i].innerText)
>            num = num + parseInt(inputs[i].value)
>          }
>          // console.log(sum)
>          totalResult.innerText = sum + '￥'
>          // console.log(num)
>          totalCount.innerText = num
>        }
>    ```

[网页特效：购物车](D:\Java code\3.  javaScript编程\3.2 webapi\day04\购物车案例\car.html)

---

### 案例：渲染学生信息

需求：点击录入按钮，可以增加学生信息

![image-20220926101605494](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220926101605494.png)

> 1. 页面初次加载时，把数组中的数据渲染到页面中
>
>    1.1 定义渲染函数 render ,`并通过 dom创建、追加子元素的方式进行页面渲染`；
>
>    1.2 通过` tbody.innerHTML = '' `清空表格数据
>
>     1.3`<a href="javascript:" id="${i}">删除</a>` 追加删除标签时 `先定义id 属性的值为当前数组下标`
>
>    ```js
>     // 渲染函数  把数组里面的数据渲染到页面中
>        function render() {
>          // 每次录入新数据时，需要清空旧数据再重新录入
>          tbody.innerHTML = ''
>          // 在渲染新的数据
>          // 根据数据的条数来渲染增加 tr  
>          for (let i = 0; i < arr.length; i++) {
>            // 1.创建tr  
>            let tr = document.createElement('tr')
>            // 2.tr 里面放内容
>            tr.innerHTML = `
>            <td>${arr[i].stuId}</td>
>            <td>${arr[i].uname}</td>
>            <td>${arr[i].age}</td>
>            <td>${arr[i].gender}</td>
>            <td>${arr[i].salary}</td>
>            <td>${arr[i].city}</td>
>            <td>
>              <a href="javascript:" id="${i}">删除</a>
>            </td>
>            `
>            // 3.把tr追加给 tobdy  父元素.appendChild(子元素)
>            tbody.appendChild(tr)
>          }
>        }
>    ```
>
> 2. 点击录入按钮，把表单里面的值都放入数组里面，并清空表单里的数据
>
>    2.1 使用 push 方法，在数组最后添加对象
>
>    2.2  获取表单里的值 使用value 属性，`学号自动生成，是数组最后一个数据的学号+1`
>
>    2.3 每次点击录用都要重新渲染页面，渲染结束将表单数据重置为默认值，`可以使用 连等写法（uname.value = age.value =   salary.value = ''）`
>
>    ```js
>    add.addEventListener('click', function () {
>          // alert(11)
>          // 获得表单里面的值   之后追加给 数组 arr  用 push方法
>          arr.push({
>            // 得到数组最后一条数据的学号 1003    + 1
>            stuId: arr[arr.length - 1].stuId + 1,
>            uname: uname.value,
>            age: age.value,
>            gender: gender.value,
>            salary: salary.value,
>            city: city.value
>          })
>          // console.log(arr)
>          // 重新渲染我们的函数
>          render()
>          // 点击录用后，清空表单数据
>          uname.value = age.value = salary.value = ''
>          gender.value = '男'
>          city.value = '北京'
>        })
>    ```
>
> 3. 删除表格中的数据
>
>    3.1 使用事件委托方式，给父类（tbody）添加点击事件，则子类也会触发；
>
>    3.2 通过e.target 获取当前点击的目标对象 `（多层嵌套结构中的对象也能准确获得，例如 td>a ）`；
>
>    3.3 `tagName 属性可以获得当前对象的标签名，一般为字符串大写 ，（点击 td、a标签时，显示 'TD'、'A'）`
>
>    3.4  根据a标签的id值，输出数组中的数据；`e.target.id  当点击a标签时，获得id值，而id值对应的就是当前数据在数组中的下标`
>
>    ```js
>    // 删除操作， 删除的也是数组里面的数据 ， 但是我们用事件委托
>        tbody.addEventListener('click', function (e) {
>                                                                                                                                
>          // 俺们只能点击了链接才能做删除操作
>          console.dir(e.target.tagName)
>          console.dir(e.target)
>        //点击删除时触发，删除被定义为a标签，得到的标签名大写
>          if (e.target.tagName === 'A') {
>                                                                                                                              
>            // 删除操作  删除 数组里面的数据  arr.splice(从哪里开始删，1)
>            // 我要得到a的id 需要
>            console.log(e.target.id)
>            // 删除数组中对应的数据， id的值就是数组下标
>            arr.splice(e.target.id, 1)
>                                                                                                                            
>            // 重新渲染我们的函数
>            render()
>          }
>    ```
>
>    

[网页特效：渲染学生信息](D:\Java code\3.  javaScript编程\3.2 webapi\day04\动态创建表格\user模板.html)

---

### 案例：轮播图

![image-20220927181229030](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220927181229030.png)

> 1. 鼠标经过小图标时显示高亮，离开变淡，并且切换到对应的大图
>
>    1.1 默认给每个 li 添加了透明度，并隐藏了下边框，当添加active时则表示选中状态，透明度效果隐藏，下边框显示
>
>    1.2 对应的大图片跟着显示，li 默认添加  opacity: 0 ，添加active时，则设置为1，实现了过渡效果过渡效果`（大图与小图的排序必须完全一致，大图和小图索引一致的情况下，能得到对应的图片）`
>    
>    1.3 修改图片的描述信息
>    
>    1.4 `定义全局变量 let index = 0 ，并且每次鼠标经过时，将图片的索引 赋值给 index，  index = i`
>    
>    ```js
>      let lis = document.querySelectorAll('.indicator li')
>       // 给多个小li绑定事件
>        for (let i = 0; i < lis.length; i++) {
>          lis[i].addEventListener('mouseenter', function () {
>            // 选出唯一的那个active ，删除类
>            document.querySelector('.indicator .active').classList.remove('active')
>            // 鼠标经过谁，谁加上active 这个类
>            this.classList.add('active')
>              
>              // 需求② ：大图片跟随变化  一定要放到鼠标经过事件里面
>            // 对应的大图片跟着显示，如果想要过渡效果，可以使用opacity效果，可以利用CSS淡入      淡出的效果，还是添加类
>            // 选出唯一的那个active ，删除类
>             document.querySelector('.slides ul .active').classList.remove('active')
>            // 对应序号的那个 li，谁加上active 这个类
>            piclis[i].classList.add('active')
>            text.innerHTML = `第${i + 1}张图的描述信息`
>            
>            // 点击右侧按钮可以实现播放下一张，但是鼠标经过前面的，播放就会乱序
>            // 解决方案：  让变化量 index 重新赋值为 当前鼠标经过的索引号
>            // 鼠标经过了那个小li 他的索引号就是 i 
>            // 右侧按钮是通过 index 来了控制播放的
>            index = i
>            }
>    ```
>
> 2. 点击左右按钮时，大图片与小图片跟着切换，图片描述信息也发送变化
>
>    2.1  let index = 0  定义全局变量  作为 大图小图数组（li 数组）的下标，每次点击右按钮时 ++，当播到最后一张图片时，变为0
>
>    每次点击左按钮时 --，当播到第一张时，变为最后一张图 索引为 lis.length - 1
>
>    2.2  利用排他思想，添加active类，给选中的小图加高亮和下边框，选中的大图透明度 设为1
>
>    2.3 `必须在鼠标经过时提前获得当前图片的索引，当用户先进行经过事件 ，后点击按钮时，会在先前图片的索引上进行++、--操作`
>
>    ```js
>      let index = 0  // 全局变量  信号量 控制器 为了给 右侧按钮和左侧按钮同时使用
>      //   点击右侧按钮，可以自动播放下一张图片
>        //   需要一个变化量  index 不断自增
>        //   然后播放下一张图片
>        //   如果到了最后一张，必须要还原为第1张图片
>        next.addEventListener('click', function () {
>          index++
>          // 选出 index 小图片 做操作
>          // console.log(index)
>          // index 与 10取余，当播到第10张图片时，跳回第一张
>          if (index === lis.length) {
>            index = 0
>          }     
>          //index = index % lis.length
>          common()
>    
>        })
>     //   点击左侧按钮，可以自动播放上一张图片
>        //   需要一个变化量  index 不断自减
>        //   然后播放上一张图片
>        //   如果到了第一张，必须要从最后一张播放
>     prev.addEventListener('click', function () {
>          index--
>          // 选出 index 小图片 做操作
>          // console.log(index)
>          if (index < 0) {
>            index = lis.length - 1
>          }
>          // index = (lis.length + index) % lis.length
>          common()
>    
>        })
>    
>     //   因为左侧按钮和右侧按钮里面有大量相同的操作，可以抽取封装一个函数 common
>        function common() {
>          document.querySelector('.indicator .active').classList.remove('active')
>          lis[index].classList.add('active')
>          // 选出 index 大图片 做操作
>          document.querySelector('.slides ul .active').classList.remove('active')
>          piclis[index].classList.add('active')
>          text.innerHTML = `第${index + 1}张图的描述信息`
>        }
>    ```
>
> 3. 实现图片自动播放，当鼠标移入时暂停，移除时进行播放
>
>    3.1 `开启定时器 ，每隔一秒 回调鼠标右按钮的事件，实现图片轮播`；鼠标经过停止定时器 ，鼠标离开开启定时器 
>
>    3.2  再次调用 定时器时 不能使用  timer （），必须写全  timer = setInterval(function () { next.click() }, 1000) 
>
>    ```js
>     //   其实定时器自动播放，就相当于点击了右侧按钮，此时只需要， next.click()
>        let timer = setInterval(function () {
>          // 自动调用右侧按钮的点击事件
>          next.click()
>        }, 1000)
>        // 需求⑧：
>        //   鼠标经过停止定时器 （清除定时器）
>                                                                                                                      
>        main.addEventListener('mouseenter', function () {
>          clearInterval(timer)
>        })
>        //   鼠标离开开启定时器 （开启定时器）
>        main.addEventListener('mouseleave', function () {
>          timer = setInterval(function () {
>            // 自动调用右侧按钮的点击事件
>            next.click()
>          }, 1000)
>        })
>    ```
>
>    

[网页特效：轮播图](D:\Java code\3.  javaScript编程\3.2 webapi\day05\轮播图案例\焦点图.html)

---

### 案例：本地存储学习信息案例

需求：改为本次存储版本的学习信息表

![image-20220929160507084](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20220929160507084.png)

> 1. 读取本地存储数据（封装函数）
>
>    1.1 用 if 语句进行判断，拿到data数据则为true，并返回 JSON.parse() 之后的对象；data 里的值为 null 则为false 表示本地存储中没有数据
>
>    1.2 如果本地存储没有数据，则默认写入三条数据，注意存储的利用JSON.stringify() 存 储JSON 格式的数据 （可以将数组对象转为json字符串）
>
>    1.3 页面第一次加载时，调用该方法
>
>    ```js
>    // 读取本地存储的数据  封装为函数 
>        // 需求①：读取本地存储数据（封装函数）
>        //   如果本地存储有数据，则返回 JSON.parse() 之后的对象
>        //   如果本地存储没有数据，则默认写入三条数据，注意存储的利用JSON.stringify() 存 储JSON 格式的数据
>        function getLocalData() {
>          let data = localStorage.getItem('data')
>          if (data) {
>            //   如果本地存储有数据，则返回 JSON.parse() 之后的对象
>            return JSON.parse(data)  //   {xxxxx}
>          } else {
>            // 如果本地存储没有数据，则默认写入三条数据，注意存储的利用JSON.stringify() 存 储JSON 格式的数据
>            let arr = [
>              { stuId: 1001, uname: '欧阳霸天', age: 19, gender: '男', salary: '20000', city: '上海' },
>              { stuId: 1002, uname: '令狐霸天', age: 29, gender: '男', salary: '30000', city: '北京' },
>              { stuId: 1003, uname: '诸葛霸天', age: 39, gender: '男', salary: '2000', city: '北京' },
>            ]
>            // 写入到本地存储里面，并将数组对象转为 json字符串
>            localStorage.setItem('data', JSON.stringify(arr))
>          }
>        }
>     // 先调用一次
>        getLocalData()
>    ```
>
> 2. 渲染模块  ( 先读取本地存储数据，然后渲染 )
>
>    每次数据更新或者删除，渲染模块都要重新调用，且调用前应该清空之前的数据
>
>    ```js
>     // 渲染函数  把数组里面的数据渲染到页面中
>        function render() {
>          // 需求②：渲染模块
>          // 先读取本地存储数据，然后渲染
>          let arr = getLocalData()
>          //每次渲染前清空之前的数据
>          tbody.innerHTML = ''
>          // 在渲染新的数据
>          // 根据数据的条数来渲染增加 tr  
>          for (let i = 0; i < arr.length; i++) {
>            // 1.创建tr  
>            let tr = document.createElement('tr')
>            // 2.tr 里面放内容
>            tr.innerHTML = `
>            <td>${arr[i].stuId}</td>
>            <td>${arr[i].uname}</td>
>            <td>${arr[i].age}</td>
>            <td>${arr[i].gender}</td>
>            <td>${arr[i].salary}</td>
>            <td>${arr[i].city}</td>
>            <td>
>              <a href="javascript:"  data-id="${i}">删除</a>
>            </td>
>            `
>            // 3.把tr追加给 tobdy  父元素.appendChild(子元素)
>            tbody.appendChild(tr)
>          }
>        }
>        // 页面加载就调用函数
>        render()
>    ```
>
> 3. 添加模块
>
>    注意，先取的最新的本地存储数据，然后追加数组对象中，`再把新的数组对象放入本地存储`
>
>    ```js
>    add.addEventListener('click', function () {
>          // 需求③：添加模块
>          // 注意，先取的最新的本地存储数据，然后追加
>          let arr = getLocalData()
>          // alert(11)
>          // 获得表单里面的值   之后追加给 数组 arr  用 push方法
>          arr.push({
>            // 得到数组最后一条数据的学号 1003    + 1
>            stuId: arr[arr.length - 1].stuId + 1,
>            uname: uname.value,
>            age: age.value,
>            gender: gender.value,
>            salary: salary.value,
>            city: city.value
>          })
>          // console.log(arr)
>    
>          // 存储到仓库里面 
>          localStorage.setItem('data', JSON.stringify(arr))
>    
>          // 重新渲染我们的函数
>          render()
>          // 复原所有的表单数据
>          uname.value = age.value = salary.value = ''
>          gender.value = '男'
>          city.value = '北京'
>        })
>    ```
>
> 4. 删除模块
>
>    注意，先取的最新的本地存储数据，删除对象数组中的数据，再放入到本地存储
>
>    设置第一条数据不能删除
>
>    ```js
>    // 删除操作， 删除的也是数组里面的数据 ， 但是我们用事件委托
>        tbody.addEventListener('click', function (e) {
>          // 读取本地存储里面的数据
>          let arr = getLocalData()
>          // alert(11)
>          // 我们只能点击了链接 a ，才会执行删除操作
>          // 那我们怎么知道你点击了a呢？
>          // 俺们只能点击了链接才能做删除操作
>          // console.dir(e.target.tagName)
>          if (e.target.tagName === 'A') {
>            // alert('你点击了链接')
>            // 删除操作  删除 数组里面的数据  arr.splice(从哪里开始删，1)
>            if(e.target.dataset.id==='0')
>            {
>              alert('管理员账号不能删除')
>              // 结束当前方法  
>              return
>            }
>            arr.splice(e.target.dataset.id, 1)
>            // 存到本地里面
>            localStorage.setItem('data', JSON.stringify(arr))
>            // 重新渲染我们的函数
>            render()
>          }
>        })
>    ```
>
>    

[网页特效：本地存储学生信息](D:\Java code\3.  javaScript编程\3.2 webapi\day06\动态创建表格\user模板.html)

---

### 案例：小兔鲜页面注册

![image-20221001092416490](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221001092416490.png)

> 1. 发送验证码，显示 05秒后重新获取，时间到了自动改为 重新获取
>
>    验证码业务写在立即执行函数里；给验证码按钮添加单击事件，设置变量 num 为 倒计时的时间，开启定时器 每执行一次 num-- ；时间为 0时，innerHTML 修改元素内容
>
>    ```js
>     (function () {
>          // 需求①： 发送验证码
>          // 用户点击之后，显示  05秒后重新获取
>          // 时间到了，自动改为 重新获取
>          let code = document.querySelector('.code')
>          code.addEventListener('click', function () {
>            // 倒计时读秒操作
>            this.innerHTML = '05秒后重新获取'
>            let num = 5
>            let timer = setInterval(function () {
>              num--
>              code.innerHTML = `0${num}秒后重新获取`
>              if (num === 0) {
>                code.innerHTML = `重新获取`
>                // 清除定时器
>                clearInterval(timer)
>              }
>            }, 1000)
>          })
>    ```
>
> 2. 校验表单数据 （用户名、密码、验证码、手机号验证方法一样）
>
>    2.1 验证数据是否规范，`用change 事件 （表单里的值发送变化后且鼠标失去焦点，则会触发）`,`将验证方法封装为函数 verifyUsername 用户名、verifyPhone 手机号、verifyCode 验证码、verifyPass 密码、verifyConfirm 再次密码验证`
>
>    2.2 需要 返回布尔值，为了 最后的提交按钮做准备
>
>    2.3 手机号正则  /^1(3\d|4[5-9]|5[0-35-9]|6[567]|7[0-8]|8\d|9[0-35-9])\d{8}$/、 验证码正则  /^\d{6}$/  、密码正则 /^[a-zA-Z0-9-_]{6,20}$/
>
>    ```js
>     // 需求②： 用户名验证（注意封装函数  verifyxxx）
>          // 正则 /^ [a - zA - Z0 - 9 - _]{ 6, 10 } $ /
>          // [name=username]  css 属性选择器
>          let username = document.querySelector('[name=username]')
>          // change 事件是 表单里的值发送变化后且鼠标失去焦点，则会触发
>          username.addEventListener('change', verifyUsername)
>          // 验证用户名的函数 verifyUsername
>          function verifyUsername() {
>            // 获得兄弟元素对象
>            let span = username.nextElementSibling
>            // 开始验证  正则  1. 定义规则  2. 检测  
>            let reg = /^[a-zA-Z0-9-_]{6,10}$/
>            if (!reg.test(username.value)) {
>              // 输入不符合规定时，提示错误信息
>              span.innerHTML = '请输入6~10的字符'
>              return false
>            }
>            // 正确时，情况提示信息
>            span.innerHTML = ''
>            return true
>          }
>    ```
>
>    2.4 再次验证密码模块 ，输入的两次密码必须完全一致
>
>    ```js
>     // 如果本次密码不等于上面输入的密码则返回错误信息
>          // 其余同上
>          let confirm = document.querySelector('[name=confirm]')
>          confirm.addEventListener('change', verifyConfirm)
>          function verifyConfirm() {
>            let span = confirm.nextElementSibling
>            if (confirm.value !== pass.value) {
>              span.innerHTML = '两次密码不一致'
>              return false
>            }
>            // console.log('right')
>            span.innerHTML = ''
>            return true
>          }
>    
>    ```
>
> 3. 点击同意条款
>
>    `用classList.toggle  添加样式类 icon-queren2 `, 有则删除当前类，没有则添加
>
>    ```js
>     // 需求⑦： 我同意模块
>          // 切换类   .icon-queren2  则是默认选中样式
>          let icon = document.querySelector('.icon-queren')
>          icon.addEventListener('click', function () {
>            // 利用切换类，有则删除，没有则添加
>            this.classList.toggle('icon-queren2')
>          })
>    ```
>
> 4. 提交按钮模块
>
>    4.1 `提交时获取 form  表单对象，并且绑定提交事件，点击 button 按钮时，自动触发提交事件`（button 上有 submit属性，能触发表单提交事件）
>
>    4.2 如果上面的每个模块，返回的是 false 则 阻止提交。`事件流 里的 阻止默认行为  preventDefault() `
>
>    4.3 如果没有勾选同意协议，则提示 需要勾选。`classList.contains() 看看有没有包含某个类，如果有则返回true，每有则返回false`
>
>    补充： if (!verifyUsername())  e.preventDefault()  `if 代码块中只有一句代码时，可以省略 {}`
>
>    ​			 ` if (! verifyUsername())   if 里面调用了方法 ，并且获得了返回值`
>
>    ```js
>     let form = document.querySelector('form')
>          form.addEventListener('submit', function (e) {
>            // 我们如果没有验证成功，不允许提交 阻止提交的行为
>            // 这样说明验证不通过
>            if (!verifyUsername()) {
>              // 阻止提交
>              e.preventDefault()
>            }
>            if (!verifyPhone()) {
>              // 阻止提交
>              e.preventDefault()
>            }
>            if (!verifyCode()) {
>              // 阻止提交
>              e.preventDefault()
>            }
>            if (!verifyPass()) {
>              // 阻止提交
>              e.preventDefault()
>            }
>            if (!verifyConfirm()) {
>              // 阻止提交
>              e.preventDefault()
>            }
>            // 勾选模块 必须勾选才能通过
>            // classList.add() 添加
>            // classList.remove() 移除
>            // classList.toggle() 切换
>            // classList.contains() 看看有没有包含某个类，如果有则返回true，么有则返回false
>            if (!icon.classList.contains('icon-queren2')) {
>              alert('请勾选同意协议')
>              e.preventDefault()
>            }
>    ```
>
>    

[网页特效：小兔鲜页面注册](D:\Java code\3.  javaScript编程\3.2 webapi\day07\综合案例素材\register.html)

---

### 案例：小兔鲜登录页面

![image-20221001114534494](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221001114534494.png)

> 1. 登录按钮点击的时候
>
>    需要先判断,是否勾选同意 ，`remember.checked 获得复选框的状态`
>
>    勾选协议后，将用户名、密码（暂时不验证是否与数据库一致）存入浏览器本地存储了 `  localStorage.setItem('pink', JSON.stringify(obj))`,并实现页面跳转`  location.href = './index.html'`
>
>    ```js
>    // 需求：
>        // 1. 登录按钮点击的时候，需要先判断
>        // 如果没有勾选同意，则提示要勾选
>        // 如果勾选协议，则记住用户名和密码
>        // 登录成功则跳转到首页
>        // 注意，登录按钮需要先阻止默认行为
>        let dl = document.querySelector('.dl')
>        // 复选框
>        let remember = document.querySelector('.remember')
>        let username = document.querySelector('[name=username]')
>        let password = document.querySelector('[name=password]')
>        dl.addEventListener('click', function (e) {
>           //  阻止默认事件，不触发提交事件 （现在不进行用户名、密码验证）
>          e.preventDefault()
>          if (!remember.checked) {
>            alert('请勾选协议')
>            return
>          }
>    
>          let obj = {
>            username: username.value,
>            password: password.value,
>          }
>          // console.log(obj)
>          localStorage.setItem('pink', JSON.stringify(obj))
>          // 跳转到新的页面
>          location.href = './index.html'
>        })
>    
>    ```
>
> 2. 下次打开页面，如果本次存储中有值，则从本地存储中取值，并勾选同意协议
>
>    ```js
>    // 2. 打开页面时候，如果本地存储有数据， 则自动记录显示用户名和密码，并勾选复选框
>        let obj = JSON.parse(localStorage.getItem('pink'))
>        if (obj) {
>          username.value = obj.username
>          password.value = obj.password
>          // 如果有数据则默认勾选
>          remember.checked = true
>        }
>    ```
>
> 3. 实现网页跳转后，显示用户名
>
>    ![image-20221001121326430](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221001121326430.png)
>
>    
>
>    用a标签包裹文字，并动态获取用户名 ` <a href="#">你好，${obj.username} 欢迎来到小兔鲜世界</a>` 
>
>    ```js
>    script>
>        // 如果本地存储有数据，则 显示 你好 xxxx
>        // 否则 显示 请跳转到注册页面
>        let li = document.querySelector('.xtx_navs li:first-child')
>        let obj = JSON.parse(localStorage.getItem('pink'))
>        if (obj) {
>          li.innerHTML = ` <a href="#">你好，${obj.username} 欢迎来到小兔鲜世界</a>`
>        }
>      </script>
>    ```
>
>    

[网页特效：小兔鲜登录页面](D:\Java code\3.  javaScript编程\3.2 webapi\day07\综合案例素材\login.html)

---

# JavaScript 高级

---

## 闭包

闭包：一个作用域有权访问另外一个作用域的局部变量,延申变量的使用范围.。`从代码形式上看闭包是一个做为返回值的函数`

**总结**

- 闭包本质仍是函数，只不是从函数内部返回的

- 闭包能够创建外部可访问的隔离作用域，避免全局变量污染

- 过度使用闭包可能造成内存泄漏 

---

一个子函数访问了父函数的局部变量后，并且 作为返回值返回该子函数,称为闭包

```js
function father () {
			let num = 66;
			// 闭包：
			return function () {
				console.log(num)
			}
		}
		let o = father();
		// console.log( o );
	// 接收后 调用该函数，可以使用局部变量
		o();
```

回调函数也能访问函数内部的局部变量。

```js
function fn (a ){
	let num = 12
	
	a( num)  //  打印; 12 
}
fn( funciton (n ){ console.log(n )  })
```

> 调用函数传递的参数也是 函数时 ，该函数属于回调函数， `函数内部可以使用  参数名+（） 的方式调用`  a ()

## 预解析 

也称为变量、函数的提升 。`在代码执行之前，提前解析变量和函数。 任何一个作用域执行代码之前都要先预解析`

---

1.变量预解析

 `会把代码中申明的变量，提前解析到当前(提升到)作用域最前面，但是只定义不赋值`（预解析过程中变量会先存储到内存中，但未赋值）。预解析执行完成后，自上往下执行代码

```js
		// 因为存在变量预解析，不会报错，自上往下执行代码。此时的变量未赋值
		console.log(n)  // 打印： undefinder
		var n = 2
		console.log( m) // 打印： m is not defined
		console.log( t)  //   let 没有初始化之前不让使用
		let  t= 1
```

> 变量在未声明即被访问时会报语法错误； 变量在声明后未赋值之前被访问，变量的值为 undefined
>
> `let 也存在预解析，但是声明的变量没有初始化（赋值）之前不让使用`,let 声明的变量未被赋值前存在于死区中，不允许被使用
>
> `实际开发中推荐先声明再访问变量`

2.函数预解析

 `会把代码中具有名字的函数提前解析，解析到当前作用域最前面 ，但是只定义不调用`。预解析执行完成后，自上往下执行代码

```js
		//  因为存在函数预解析，先调用 后定义函数不会报错
		fn();
		function fn () {
			console.log('函数123');
		}
		// 表达式函数，不论是否有名都不会进行函数预解析，被当做变量进行预解析
		var fn1 = function fun() {} 
		var fn1 = function () {} 
```

> 表达式函数，不论是否有名都`不会进行函数预解析`，会被当做变量进行预解析。`调用表达式函数时，必须先定义再调用否则会报错`

当变量和函数重名时，函数优先（预解析只保留函数）

```js
// 预解析 函数a 、预解析变量 a ，最终保留函数a （a= 函数）
		console.log(a); // 打印 函数
			function a () {}

			var a = 2; //将函数a 覆盖为 变量 a 并赋值为 2
		console.log(a); //打印：2
```

## 函数参数

- `声明函数时为形参赋值即为参数的默认值，`调用函数时没有传入对应实参时，参数的默认值被当做实参传入

- 如果参数未自定义默认值时，而且调用也未传入实参时，参数的默认值为 undefined

---

定义参数默认值

```js
// 调用时，未传入实参，默认值为 undefined
		function fn (uname , age ) {
			// 形参没有接受实参，那么形参是undefined
			console.log( `我叫${uname}今年${age}岁` );
		}
		fn();

		// 求任意两个数的和，默认值 为 0 和
		function getSum (num1 = 0, num2 = 0) {
			let he = num1 + num2;
			console.log(he);
		}
		getSum(6, 3);

```

### 动态参数 arguments

- arguments 是函数内部内置的伪数组变量，`它包含了调用函数时传入的所有实参`。(所有函数调用时传递的实参，都会先存入arguments 伪数组中)
- 伪数组不能调用方法，但能遍历取值

---

利用动态参数求最大值

```js

			// 求若干个数的最大值
			// 在函数内部有一个特殊的对象，arguments
			// arguments用于接受所有的实参
		function getMax () {
			// 假设最大值 
			let max = arguments[0];

			// 遍历比较
			for (let i = 0; i < arguments.length; i++) {
				if ( max < arguments[i] ) max = arguments[i];
			}
			console.log(max);
		}

		getMax(23, 66, 78, 123, 4, 9, 3, 12345, 456, 65,67, 34);// 参数不固定
```

> 如果参数固定写形参，参数不固定用arguments

### 剩余参数

- ... 是语法符号，借助 ... 获取的剩余实参，置于函数最后的形参之前 （此时形参是个数组）

```js
function getSum (...a) {
			// a
			let sum = 0;
			for (let i = 0; i < a.length; i++) {// a = [1, 2, 3......]
				sum = sum + a[i]
			}
			console.log(sum);
		}
		getSum(1, 2, 3, 4, 5, 6);
```

> 如果存在多个形参，使用剩余参数时，必须放在最后面  function fun (a, b ,c ,d , ...e) { }

## 箭头函数

- `箭头函数属于表达式函数，因此不存在函数预解析`

- 箭头函数只有一个参数时可以省略圆括号 ()

- 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回

- 箭头函数中没有 arguments，只能使用 ... 动态获取实参

- `箭头函数认为不存在this，箭头函数中的this指向的是上级作用域的this`

```js

		// 箭头函数 代替 函数表达式
		// let fn = function () {console.log(123);};
		let fn = (a, b) => {
			return a + b;
		}
		let re = fn(1, 2);
		console.log(re);

		// 注意：如果参数只有一个，那么可以省略小括号
		let fn = a => {
			return a * a;
		}
		console.log( fn(3) );
		// 注意：如果函数体只有一行代码，那么可以省略大括号，
		// 如果把打括号省略的话，会自动的返回结果，不需要写return
		let fn1 = a => a * a;
		console.log( fn1(6) );
----------------------------------------------------------------------------------------------------
		// 构造函数：箭头函数不能当做构造函数的使用
		let Person = (uname, age) => {
			this.uname = uname;
			this.age = age;
		}
		// new Person();

```

箭头函数主要用来代替回调函数

```js
		// 箭头函数使用
		window.setInterval(function () {console.log('定时器');}, 1000);
		window.setInterval(() => {
			console.log('函数体');
		}, 1000)
----------------------------------------------------------------------------------------------------------------
		// 1、箭头不存在预解析，所以必须先定义再调用
		let fn = () => {
			console.log('aaa');
		}
		fn()
----------------------------------------------------------------------------------------------------------------
		// 箭头函数认为不存在this，箭头函数中的this指向的是上级作用域的this
			let obj = {
			uname : '阿飞',
			age : 22,
			fei : function () {
				// 箭头函数里的 this 指向 obj
				window.setInterval( () => {
					console.log(this)
				}, 1000 );
			}
		}
		obj.fei();

```

> `箭头函数认为不存在this`，箭头函数中的this指向的是上级作用域的this ;`如果涉及到this使用的时候，劲量不要使用箭头函数`

## 解构赋值

- `解构赋值是一种快速为变量赋值的简洁语法`，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。

---

### 数组解构

- 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法

- 语法：let  [ 变量名 ]  = arr （需要解构赋值的数组）;左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量

```js
		let arr = ['张飞', '赵云', '关羽', '张辽', '许褚', '典韦'];
		// 将数组中的数取出来单独赋值
		let uname1 = arr[0];
		let uname2 = arr[1];
		let uname3 = arr[2];
		let uname4 = arr[3];
		let uname5 = arr[4];
		let uname6 = arr[5];

		// 解构赋值：解开数据解构赋值给变量
		let [a, b, c, d, e, f] = arr
		console.log( a, b, c, d, e, f );
```

> 数组中的值与变量名对应

数组解构赋值的多种情况

```js
		// 一一对应
		// let [a, b, c, d, e, f] = ['张飞', '赵云', '关羽', '张辽', '许褚', '典韦']
		// console.log(a, b, c, d, e, f);

		// 变量多值少  
		// 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined
		// let [a, b, c, d, e, f, g, h, i, j, k,l] = ['张飞', '赵云', '关羽', '张辽', '许褚', '典韦'];
		// console.log( a, b, c, d, e, f, g, h, i, j, k, l );

		// 变量少值多
		// 顺序赋值
		// let [a, b, c] = ['张飞', '赵云', '关羽', '张辽', '许褚', '典韦'];
		// console.log( a, b, c );
		
		// 按需取值 a 关羽、b 张辽 、c 典韦
		//  使用 逗号 占位
		// let [, , a, b, , c] = ['张飞', '赵云', '关羽', '张辽', '许褚', '典韦']
		// console.log( a, b, c ); 
		
		// 剩余值  a 赵云、 b 关羽 、c '张辽', '许褚', '典韦'
		//  ... 语法将  
		// let [, a, b, ...c] = ['张飞', '赵云', '关羽', '张辽', '许褚', '典韦'];
		// console.log(a, b, c);
		
		// 复杂情况 a 关羽、 b 张辽、 c 鲁智深、d 武松
		//  数组二次解构
		let [, , a, b, [, c, d]] = ['张飞', '赵云', '关羽', '张辽', ['林冲', '鲁智深', '武松', '宋老板']]

		console.log( a, b, c, d );
```

> 变量的顺序对应数组中数值的位置依次进行赋值操作
>
> `变量的数量大于单元值数量时，多余的变量将被赋值为 undefined`
>
> `精准取值，需要使用 逗号占位`
>
> 支持多维解构赋值

### 对象解构

- 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法

- 属性名当做变量名   ， let {变量名} = {属性名}  ，对象中找不到与变量名一致的属性时变量值为 undefined

- `当变量名 已被定义时，用冒号改名字`

```js
		let uname = '阿飞';
		// 把对象解开解构赋值给变量
		// 当变量名 已被定义时，用冒号改名字
		let {uname:userName, sex} = {
			uname : '张三丰',
			age : 22,
			sex : '男',
			score : 99,
			index : 6,
		}
        	console.log( userName, sex );
        ----------------------------------------------------------------------------
        // 解构赋值对象中的对象 的属性
        let { dog:{uname} } = {
			uname : '张三丰',
			dog : {
				uname : '小狗子',
				age : 1,
			},
			age : 22,
			sex : '男',
			score : 99,
			index : 6,
		}
		console.log( uname );
        ---------------------------------------------------------------------------
            // 使用场景 ，在函数形参中 完成对象的解构赋值
        	function person ( {uname, age, sex} ) {
			// let uname = obj.uname;
			// let age = obj.age;
			// let sex = obj.sex;

			console.log(`我叫${uname}今年${age}岁是${sex}性`);
		}
		person( {uname : '阿飞', age : 22, sex : '男'} )
        
```

> `解构赋值对象中的对象的属性时 ，变量名与对象名一致 后去 加冒号、花括号 ：{}`，  let { dog:{uname} }  
>
> `可以在在函数形参中 完成对象的解构赋值`,语法更加简洁

## 面向对象

---

### 原型对象

- 实际上每一个构造函数都有一个名为 prototype 的属性，译成中文是原型的意思，`构造函数的prototype属性指向了一个对象，我们把这个对象称为原型对象或者原型`
- 原型对象中的所有属性和方法都是共享方法，`并且原型对象被所有实例对象共享`，可以节省内存；把实例对象赋值给原型对象，指回构造函数本身，实现原型继承。

- 每一个原型对象都有一个属性：constructor，用于指回构造函数本身  Person.prototype.constructor。

- 每一个对象都有一个属性：__ proto __ ，用于指向原型对象(prototype)，`（当访问对象的属性或方法时，先在当前实例对象中查找，未找到时会自动调用__ proto __ 属性指向原型对象，然后再去原型对象查找。）`  obj.__ proto __ === Person.prototype 

---

将自定义构造函数中的方法写入原型对象中

```js
			function Person (uname, age) {
				this.uname = uname;
				this.age = age;

				// this.sing = function () {
				// 	console.log('唱歌');
				// }
			}
			// 往原型对象中添加方法
			Person.prototype.sing = function () {
				console.log('唱歌');
			}
			
			let obj = new Person('阿飞', 22);

			// 原型对象被所有实例共享。可以通过实例化对象直接调用原型对象里的方法
			obj.sing();
```

> 原型对象被所有实例共享。可以通过实例化对象直接调用原型对象里的方法

在数组的原型对象中追加求和方法

```js
		let arr = [1, 2, 3];
		// 写一个方法，让所有的数组都能够使用，调用这个方法就可以得到数组的和
		// 方法里面的this调用者
		Array.prototype.sum = function () {
			// 定义变量
			let he = 0;
			// 遍历
			for (let i = 0; i < this.length; i++) {
				he = he + this[i];
			}
			// 返回
			return he;
		}
		console.log( arr.sum() );
		let ary = [11, 22, 33];
		console.log( ary.sum() );
		console.log( Array.prototype );
```

> 添加到原型对象的方法，使用this时 指向调用者

#### 1. 原型链

- 原型对象的链状结构关系称为原型链，JavaScript 对象中包括了一个非标准备的属性 __proto__ 它指向了构造函数的原型对象，通过它可以清楚的查看原型对象的链状结构。

---

原型链查找，采取就近原则，(当前对象的原型对象中没有找到时，会去Object 的原型对象中去找相应的方法和属性 )

```js
		// 原型链：由原型构成链状结果
		// 作用：提供查找成员机制
		
		// 构造函数
		function Person (uname, age) {
			this.uname = uname;
			this.age = age;
		}
		// 原型对象
		Person.prototype.eat = function () {
			console.log('吃');
		}
		// console.log( Object.prototype );
		Object.prototype.lanqiu = function () {
			console.log('Object篮球')
		}
		Person.prototype.lanqiu = function () {
			console.log('Person篮球');
		}
		// 实例化对象
		let obj = new Person('阿飞', 22);

		// 每个对象都有一个属性，__proto__

		// 根据原型链查找，采用就近原则
		obj.lanqiu(); // 执行person里的 篮球方法
```

### 面向对象编程

- 面向对象编程是一种程序设计思想，它具有 3 个显著的特征：封装、继承、多态。

- 函数是最典型也是最基础的代码封装形式，面向对象思想中的封装仍以函数为基础，`其优势是能够保证代码复用且易于维护`。

- 继承：把实例对象赋值给原型对象，指回构造函数本身。继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是`借助原型对象实现继承的特性`。

---

通过构造函数创建对象，体现了函数封装代码的思想 （将对象重复的属性和方法抽取到构造函数中）

```js
// 构造函数：当作模板
		function Person (uname, age, height, weight) {
			this.uname = uname;
			this.age = age;
			this.height = height;
			this.weight = weight;
			// 吃饭
			this.eat = function () {
				console.log('吃饭');
			}
			this.sleep = function () {
				console.log('睡觉');
			}
		}
		// 实例化
		let obj1 = new Person('张飞', 22, '90kg', '189CM');
		obj1.uname = '张飞飞';
		console.log( obj1 );

		let obj2 = new Person('关羽', 23, '90kg', '199CM');
		console.log(obj2);
```

> 缺点：通过构造函数 实例化对象时，`每次实例化对象都会开启新的空间保存对象中的方法`，创建过多对象时，会造成空间资源浪费

#### 1. 继承

- 继承：把实例对象赋值给原型对象，指回构造函数本身。通过继承进一步提升代码封装的程度。

- JavaScript 中大多是`借助原型对象实现继承的特性`

---

Chinese 对象通过继承使用Person 对象中公共的属性和方法

```js
		// 将公共的属性和方法抽取出来， 定义为新的构造函数
		function Person () {
			this.head = 1;
			this.eyes = 2;
			this.legs = 2;

			this.say = function () {console.log('say');}
			this.eat = function () {console.log('eat');}
		}
		// Chinese 对
		function Chinese () {
			this.language = '汉语';
			this.skin = 'yellow';
		}

		// 继承:
		// 1、把对象赋值给原型对象, 原型对象会指向新的内存地址，导致constructor 属性消失
		Chinese.prototype = new Person();
		// 2、指回构造函数本身，手动添加constructor属性，并赋值为构造函数名
		Chinese.prototype.constructor = Chinese;

		console.log(Chinese.prototype);

		let c1 = new Chinese();
		// 实例化对象调用 可以公共方法
		c1.eat();
		

```

> 把公共对象赋值给原型对象时， 必须通过 new 构造函数的方法 指向新的对象 （确保指向新的对象）
>
> 原型对象会指向新的内存地址，导致constructor 属性消失，`指回构造函数本身 是指手动添加constructor属性，并赋值为构造函数名`

### 构造函数

- 构造函数：其实也是函数，只不过构造函数一般用于和new搭配使用创建对象` (使用 new 关键字调用函数的行为被称为实例化)`

-  js 内置构造函数：Object，创建对象 (对象中没有属性和方法，需要手动添加)

- 如果构造函数不需要参数，那么可以省略小括号  ( let obj = new Object )

- `构造函数中不需要return (写了返回值也无效)，返回值默认为新创建的对象`

---

创建对象的两种方法

```js
		// 1、字面量创建对象 ，创建一个对象赋值给变量
		let obj = {
			// 属性名：属性值，
			// 键值对
			// 成员
			uname : '张三丰',
			age : 22,
			sex : '男',
			taiji : function () {
				console.log('打太极');
			},
		}
------------------------------------------------------------------------------------------
		// 构造方法创建对象
		let obj = new Object();

		// 添加属性和方法
		obj.uname = '阿飞';
		obj.age = 22;
		obj.fei = function () {
			console.log('方法');
		};
		obj.chi = function () {
			console.log('吃');
		}
		console.log( obj );
		// 构造方法的参数可以接收对象
		let obj = new Object( {uname : '张三丰', age : 22, sex : '男'} );

		console.log( obj );
```

#### 1. 自定义构造函数

- 从视觉上区分构造函数和普通函数，`自定义构造函数时，函数名首字母大写`。

- 构造函数的返回值即为新创建的对象

- 构造函数里面this指向当前实力对象

```js
function Person (uname, age, sex) {
			// 添加属性名并赋值
			this.uname = uname;
			this.age = age;
			this.sex = sex;

			this.eat = function () {
				console.log('吃饭');
			};
			this.sing = function () {
				console.log('唱歌');
			}
		}
		// 一般如何使用
		// 可以多次实例化对象
		let o = new Person('张三丰', 22, '男');
		console.log( o );

		let o1 = new Person('阿飞', 21, '男');
		console.log( o1 )
```

#### 2. instanceof 与constructor的使用

- instanceof：用于判断一个对象是否是另外一个构造函数的实例对象，返回布尔值   语法：`对象 instanceof 构造函数`

- 实例对象的 constructor 属性返回实例化对象的构造函数 

```js
		function A () {}
		function B () {}
		let obj = new B();

console.log( obj instanceof B );
console.log( obj.constructor );
```

#### 3. 函数成员 (属性和方法)

- 我们把`在构造函数身上直接添加的成员，称为静态成员`（静态属性和静态方法）；`只能由构造函数访问`

- `构造函数内部为实例对象准备的成员，称为实例成员`（实例属性和实例方法）；`只能由实例对象访问`

```js
		function Star (uname, age) {
			this.uname = uname;
			this.age = age;
			this.sing = function () {
				console.log('唱歌');
			}
		}
		
		// Star构造函数也属于对象，对象身上就可以添加属性和方法
		Star.language = '汉语';
		Star.skin = '黄皮肤';
		Star.chi = function () {
			console.log(123);
		}

		// 实例化对象
		let obj = new Star('刘德华', 23);
		console.log(Star.skin); // 
		console.log(obj.uname);
```

> js 中所有的属性和方法都可以看成对象，`构造函数也属于对象，对象身上就可以添加属性和方法`

### js中内置的对象

---

`js  api 文档` ：[|MDN - js 内置对象（new 构造函数得到的对象）](https://developer.mozilla.org/en-US/docs/Web/JavaScript)

---

内置对象：必须通过 new 构造方法来实例化的对象

- Object：是内置的构造函数，用于创建普通对象。

- Array：是内置的构造函数，用于创建数组。`任何一个数组都是Array构造函数的实例化对象`

- RegExp：内置的构造函数，用于创建正则表达式。 ` let reg1 = new RegExp(/abc/);`

---

#### 1. Object 构造函数中的静态方法

```js
// Object：创建普通对象的构造函数
		let obj = new Object( {uname : '阿飞', age : 22, sex : '男'} );
		console.log(obj);

		//Object.keys：获取对象的所有键
		let re = Object.keys(obj)
		console.log( re );

		// 获取对象的索引值
		let re1 = Object.values(obj);

		console.log(re1);
```

> `推荐使用字面量方式声明对象，而不是 Object 构造函数`
>
> Object.assign 静态方法创建新的对象；Object.keys 静态方法获取对象中所有属性；Object.values 表态方法获取对象中所有属性值
>
> `构造函数的静态方法只能通过构造函数调用`

Array 构造函数创建数组

```js
		// 字面量
		let arr = [1, 2, 3];
		Array构造函数
		let ary = new Array(1, 2, 3);
		console.log( ary );
		console.log( arr instanceof Array ); // true
```

> 不论是任何通过哪种方式创建的数组，都算是通过Array构造函数的方式创建数组 （new 构造函数的方式，也称为实例化对象）

#### 2. Array 对象中的方法 

（需要实例化对象，new 构造函数后得到的对象，不过任何数组都可以当成Array构造函数的实例化对象）

![image-20221003165853564](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221003165853564.png)

##### 2.1 join 方法进行数组元素的拼接，将数组拼接为字符串

```js
const elements = ['Fire', 'Air', 'Water'];

console.log(elements.join());
// expected output: "Fire,Air,Water"

console.log(elements.join(''));
// expected output: "FireAirWater"

console.log(elements.join('-'));
// expected output: "Fire-Air-Water"

```

> `如果省略，数组元素用逗号 （“，”） 分隔。`
>
> `如果 为空字符串，则连接所有元素时它们之间没有任何字符`

concat  用于拼接为新数组；reverse：翻转数组顺序

```js
 //concat：用于拼接为新数组
		let arr = [1, 2, 3];
		let ary1 = ['a', 'b', 'c', 'd'];
		let ary2 = [11, 222, 333];
		let reArr = arr.concat(ary1, ary2, '张飞', '关羽', '赵云');
		console.log(reArr);
	// reverse：翻转数组顺序
		let arr = [1, 2, 3];
		let re = arr.reverse();
		console.log(re);
```

`indexOf 顺序查找某个元素在数组中首次出现的索引位置，返回索引值，找不到就是返回-1` ；lastIndexOf：从末尾查找某个元素在数组中首次出现的索引位置，找不到就返回-1

```js
		// indexOf：查找某个元素在数组中首次出现的索引位置，找不到就是返回-1
		let arr = ['a', 'b', 'c', 'd', 'a', 'b', 'f'];
		let re = arr.indexOf('b'); // 1
		let re = arr.indexOf('m'); // -1
		console.log(re);

		// lastIndexOf：查找某个元素在数组中尾次出现的索引位置，找不到就返回-1
		let re = arr.lastIndexOf('b'); // 5
		console.log(re);
```

使用 indexOf 找到数组中的重复元素，去重后并添加到新的数组中

```js
		let arr = ['a', 'b', 'a', 'c', 'd', 'a', 'd', 'b', 'c', 'd', 'e']
		let newArr = [];
		// 遍历arr的每一个元素，在newArr中查找，如果找不到就把这个值添加进去
		for (let i = 0; i < arr.length; i++) {
			if ( newArr.indexOf(arr[i]) == -1 ) newArr.push(arr[i]);
		}
		console.log( newArr );
```

##### 2.2 sort 对原数组单元值排序

```js
		// sort：排序
		let arr = [3, 16, 22, 66, 123, 99];

		// 正序排列: 固定写法将函数作为参数传递 , 默认 a小 b大  ，返回值为 a-b  a在前，b在后
		let re = arr.sort(function (a, b) {return a - b;});
		console.log( re );
		// 倒序排列  返回值为 b-a ， b在前，a在后
		 let re1 = arr.sort(function (a, b) {return b - a;});
		console.log( re1 );
```

> `sort 里的 回调函数 能实现正序或者倒序的功能`: 默认 a小 b大  ，返回值为 a-b ，a在前，b在后 正序排列  ;  返回值为 b-a ， b在前，a在后 倒序排列

Array 构造函数 中的静态方法 isArray() 判断一个值是否是数组、from() 把伪数组转换为真数组

```js
	//  isArray() 判断一个值是否是数组
		Array.isArray();
		let a = [1, 2, 3];
		let re = Array.isArray(a);
		console.log(re);
----------------------------------------------------------------------------------------------------------------		
		// from() 把伪数组转换为真数组
		// Array.from(伪数组)
		// 特别注意：要想把伪数组转换为真数组必须有length属性
		let o = {
			0 : 'a',
			1 : 'b',
			2 : 'c',
			3 : 'd',
			4 : 'e',
			5 : 'f',
			6 : 'h',
			length : 4,
		}
		let ary = Array.from(o);
		console.log( ary );
-----------------------------------------------------------------------------------------------------------------		
		// 伪数组转换的使用场景
		let lis = document.querySelectorAll('li');
		// 将 li的伪数组 转换为真数组
		let arr = Array.from(lis);
		arr.pop();
		console.log(arr);
-----------------------------------------------------------------------------------------------------------------
			function fn () {
			//  将arguments 伪数组，转为真数组
			let ary = Array.from(arguments);
			ary.pop();
			console.log(ary);
		
		}
		fn(1, 2, 3, 'a', 'b', 'c');

```

> `要想把伪数组转换为真数组必须有length属性`,length 属性值 多于数组中实际长度时，多出的部分用 undefined 代替， 过少时有多少显示多少

##### 2.3 遍历数组的方法

forEach：用于遍历数组 ，(forEach 方法需要将 回调函数作为实参传递)

```js
		// forEach：用于遍历数组
		 let arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

		arr.forEach( function (item, index, o) {
			// 参数名可以随便定义
			// 第一个参数：代表数组的每一项（每个元素）
			// 第二个参数：代表数组的每一项的索引值（索引值）
			// 第三个参数：代表当前数组本身
			console.log(item, index, o);
		} );
-----------------------------------------------------------------------------------------------------------------
    		//  从数组对象中取值 
			let arr = [
					{uname :'阿飞', age : 22, sex : '男'},
					{uname :'张三丰', age : 23, sex : '男'},
					{uname :'李寻欢', age : 21, sex : '男'},
					{uname :'张三丰1', age : 23, sex : '男'},
					{uname :'李寻欢1', age : 21, sex : '男'},
					{uname :'张三丰2', age : 23, sex : '男'},
					{uname :'李寻欢2', age : 21, sex : '男'},
					{uname :'张三丰2', age : 23, sex : '男'},
					{uname :'李寻欢2', age : 21, sex : '男'},
				];
		arr.forEach( item => {	
			console.log(`姓名:${item.uname},年龄${item.age},性别${item.sex}`);
		} );
		
```

find：用于查找首次出现的满足条件的值，并返回，为找到返回undefined；findIndex：用于查找首次出现的满足条件的值，并返回期所在索引值 ，未找到返回 -1

```js
	// find：用于查找首次出现的满足条件的值，并返回  （返回第一个满足条件的数组中的元素）
		let re = [2, 6, 4, 7, 9, 3].find( function (item, index, o) {
			return item > 5;
		} )
		console.log(re); //  打印：6
-----------------------------------------------------------------------------------------------------------------------------------------------
	// findIndex：用于查找首次出现的满足条件的值，并返回期所在索引值
		let re = [2, 6, 4, 7, 9, 3].findIndex( function ( item, index, o ) {
			return item > 6;
		} );
		console.log(re);  //打印：3
```

some：用于查找如果有一个满足条件返回true ；every：用于查找满足条件的元素，如果都满足返回true，否则就是false

```js
// some：用于查找如果有一个满足条件返回true
let re = [2, 6, 4, 7, 9, 3].some( function (item, index, o) {
			return item > 5;
		} )
		console.log(re); //打印：true
---------------------------------------------------------------------------------------------------------
  // every：用于查找满足条件的元素，如果都满足返回true，否则就是false 
let re = [2, 6, 4, 7, 9, 3].every( function (item, index, o) {
			return item > 5;
		} );
		console.log(re);// 打印 ：false 
```

filter：筛选数组把满足条件的元素放到新数组返回 ；map：遍历数组让每个元素执行一边回调函数，把所有结果放到新数组返回

```js
// filter：筛选数组把满足条件的元素放到新数组返回
		let re = [2, 6, 4, 7, 9, 3].filter( function (item, index, o) {
			return item > 5;
		} );
		console.log(re);
--------------------------------------------------------------------
// map：遍历数组让每个元素执行一边回调函数，把所有结果放到新数组返回
		let re = [2, 6, 4, 7, 9, 3].map( function (item, index, o) {
			return item * item;
		} );
		console.log(re);
```

> `filter 、map 方法返回的都是新数组`

### 拷贝对象

- 浅拷贝：只拷对象中的简单数据类型 ，浅拷贝方法 assign ，等同于循环遍历赋值

- 深拷贝：拷贝对象中的所有数据 （包括复杂数据类型）

---

深拷贝对象，利用递归，`判断对象中是否有复杂数据类型，将复杂类型递归为简单类型进行拷贝`（适用于所有对象拷贝）

```js
		let obj = {
			uname : '张三丰',
			age : 22,
			sex : '男',
			color : ['red', 'blue', 'yellow', 'pink'],
			message : {
				score : 99,
				index : 6,
			}
		}
		let newObj = {}

		// 遍历
		// 如果遇到obj[key]是复杂类型，再遍历操作
		function kaobei (newObj, obj) {
			for ( let key in obj ) {
				if ( obj[key] instanceof Array ) {// 判断对象中是否存在数组 ,有则遍历取出简单数据赋值，复杂类型继续递归
					// 保证newObj[key]是数组
					newObj[key] = [];
					kaobei(newObj[key], obj[key]);
				} else if ( obj[key] instanceof Object ) {//判断对象中是否存在对象，有则遍历取出简单数据赋值，复杂类型继续递归
					// 保证newObj[key]是对象
					newObj[key] = {};
					kaobei(newObj[key], obj[key])
				} else {
                    	·	// 简单数据拷贝，对象中 key 代表键、数组中代表下标
				newObj[key] = obj[key];
				}
			}
		}
		// 前面写空对象，后面写拷贝对象
		kaobei(newObj, obj);
		obj.message.index = 666;
		console.log(obj, newObj);
```

> 数组也可以用 for in 进行遍历，此时 key 代表数组下标

## 包装类型

- `JavaScript 底层使用 Object 构造函数来包装 字符串、数值、布尔这些基本数据类型`，使得字符串、数值、布尔具有对象的使用特征，具有属性和方法。
- 字符串、数值、布尔类型数据 也被称为包装类型，`通过字面量的方式创建也能调用属性和方法 `（调用时会自动包装成对象）。

---

### String 对象的方法

字符串与数组类似，也存在索引，可以遍历

![image-20221004134746725](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221004134746725.png)

`trim`：用于去除字符串两端空白；`split`：分割字符串，并返回数组

```js
		// trim：用于去除字符串两端空白
		let str = '    abc        defgabcd       ';
		console.log(str);
		console.log(str.trim()); 
------------------------------------------------------------------------------------
		// let str = 'abcdefgabcd';
		// // split：分割字符串，并返回数组
		let re = str.split('c'); // 将字符串中的c替代为逗号
		let re = str.split('');// 空字符串 注意不加空格，每个字符间用逗号隔开
		console.log(re);
```

`toLowerCase`：把字母转成小写；`toUpperCase`：把字母转成大写

```js
		let str = 'abcdeFGabcd';
		// toLowerCase：把字母转成小写
		 let re = str.toLowerCase();
		// toUpperCase：把字母转成大写
		let re = str.toUpperCase();
		console.log(re);
```

`indexOf`：查找某个元素首次出现的索引值，找不到就是-1；`lastIndexOf`：查找某个元素尾次出现的索引值，找不到就是-1

```js
		let str = 'abcdefgabcd';
		// indexOf：查找某个元素首次出现的索引值，找不到就是-1
		 let re = str.indexOf('m');
		// lastIndexOf：查找某个元素尾次出现的索引值，找不到就是-1
		let re = str.lastIndexOf('m')
		console.log(re);
		
```

`slice(start，end) `字符串截取 , 从start索引值位置截取字符串截取到end索引位置, `end索引位置上的字符取不到`

`substring`：截取字符串  与slice用法一致 ，但是不区分参数中的大小值

`substr(start, length) `从start索引位置开始截取字符串，截取length个

`注：如果只有一个参数，那么从这个索引值位置开始一直截取到最后`

```js
let str = 'abcdefgabcd';
let re = str.slice(1, 4); // 从 1索引截取到 3 索引 （不包括4）
let re = str.substring(4, 1);  // 不区分参数中的大小值
let re = str.substr(1, 4); // 从1索引开始 截取4个数 
```

### Number 对象的方法

toFixed(number)：用于保留几位有效数字

```js
// toFixed(number)：用于保留几位有效数字
		let price = 66.36875123;
		price = price.toFixed(3);
		console.log(price);

		// parseInt 字符串成数组并保留整数、parFloat  字符串成数组并保留小数
		let num = 66.123;
		console.log( Number.parseFloat(num) );
		console.log( Number.parseInt(num) );
```

> 新版本里 parseInt、parFloat  需要通过Number 对象调用 `（Number对象里的静态方法）`

### String 练习题

---

截取文件名 ，lastIndexOf 获得字符对应的索引，substr 截取字符串，split 分割字符串得到数组

```js
		let str = 'file:\\C:\\Users\\laogou\\Desktop\\JavaScript高级\\day3\\index.html';
		let gang = str.lastIndexOf('\\');
		let last = str.substr(gang+1); //从第一个 反斜杠开始截取，反斜杠不包含
		let arr = last.split('.'); //  用点 分割字符，返回文件名和后缀的数组

		console.log(arr); // arr = [index, html]
```

> \\ \  第一个反斜杠是转义字符, 第二个表示 反斜杠

求字符串中出现最多的字符及出现的次数

```js
		// 求出字符串中出现最多的字符
		let str = '132642343739373635384628633124';

		// 用对象保存字符以及字符次数
		let obj = {
			// 字符当做键，次数当做值
			// 1 : 3,
			// 2 : 6,
		};
		// 如果对象中有这个键，就让值+1，
		for (let i = 0; i < str.length; i++) {
			// 要去obj里面判断有没有str[i]这个键
		
			// 空字符串不能 通过. 获得属性值，需要通过 []的方式
			// if里面要布尔值，如果obj[str[i]]存在，返回一个数字，隐式转换布尔值为true
			// obj访问str[i]这个属性，如果有就会返回一个数字那么这个时候只要让这个数值+1
			if ( obj[str[i]] ) {
				obj[str[i]]++;
			} else {
				//对象中如果没有这个键，就添加这个键并且初始值为1
				obj[str[i]] = 1;
			}
		}
		//  得到保存字符、字符出现次数的对象
		console.log(obj);

		// 求出现最多的字符以及出现了几次
		// 假设最大值是 第一个数
		let max = 1;
		let count = obj['1'];
		// 遍历对象
		for (let key in obj) {
			if ( count < obj[key] ) {
                	// 如果比max大，则将 键和值 重新赋值
				count = obj[key];
				max = key;
			}
		}
		console.log( max, count );
```

> 用对象保存字符以及字符次数，if 判断对象中是否有键值时，`空字符串不能 通过  .（点）获得属性值，需要通过 [ ]的方式进行访问` obj[str[i]]

## js严格模式

-  开启严格模式："use strict"，"use strict"如果这句话放到全局的开头，全局都要严格模式

- "use strict"如果整句话放到了函数的开头，代表这个函数内部严格，其他地方严格

```js
		// 1、变量必须定义再使用
		// 2、普通函数中的this指向undefined
		// 3、函数的形参不准重名
		// n = 2;
		// function fn () {
		// 	console.log(this);
		// }
		// fn();

		function fn (a, a) {
			console.log( a + a );
		}
		fn(1, 2);
```

> 1、变量必须定义再使用   2、普通函数中的this指向undefined    3、函数的形参不准重名

## 改变函数中this 指向

- JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向:Call（）、apply（）、Bind（）
- 通过函数对象调用方法 （函数原型对象中的方法）

- 调用Call（）、apply（）方法时都会执行函数，`在执行的过程中改变this的指向`； 调用 Bind（）不会立即执行函数，需手动调用

---

函数.call(this，arg1, arg2,......) 第一个是this指向对象，后面的指需要传递的函数实参

```js

		function fun (a, b) {
			console.log(this, a, b)
		}
		
		let obj = {uname : '张三丰', age : 22};
		// 函数.call(this，arg1, arg2,......) 第一个是this指向对象，后面的指需要传递的函数实参
		// 函数调用call、call会调用函数执行，在执行的过程中改变this的指向
		// 函数对象调用  （使用函数名）
		fun.call(obj, 1, 2);
--------------------------------------------------------------------------------------------------------------
			let obj = {
			uname : '张三丰',
			age : 22,
			fei : function () {
				console.log(this);
			}
		}

		let o = {
			uname : '李寻欢',
			sex : '男'
		}
		//  获取对象中的函数对象 obj.fei
		obj.fei.call(o);
```

> 函数调用call、call会调用函数执行，`在执行的过程中改变this的指向`

apply：函数.apply(this, [arg1, arg2,......])  第二个参数是数组

```js
	// apply：函数.apply(this, [arg1, arg2,......])
		function fn (a, b) {
			console.log(this, a, b);
		}

		let obj = {uname : '阿飞'};	
		fn.apply(obj, [111, 222]);
-----------------------------------------------------------------------
  		  // 求数组最大值  
    	    // Math.max（） 里不能传数组，需要调用apply 传递数组
		let arr = [23, 66, 33, 19, 4, 7];
		let re = Math.max.apply(null, arr);
		console.log( re );

		// ... 扩展运算符：数组，字符串，对象
		let arr = [23, 66, 33, 19, 4, 7];

		let re = Math.max(...arr);
		
```

bind：函数.bind(this, arg1, arg2,......) ，`不会立即调用函数，调用函数需要加 （）`

```js
		function fn (a, b) {
			console.log(this, a, b);
		}

		let obj = {uname : '李寻欢', age : 22};
		fn.bind(obj, 123, 456) ();// 等同于  let re = fn.bind(obj)    re();
------------------------------------------------------------------------------------------------------
		//  改变按钮禁用状态
		let btn = document.querySelector('input');

		btn.addEventListener('click', function () {
			// 禁用按钮
			this.disabled = true;
			// 开启定时器,使用bind 不会立即调用函数
			setTimeout(function () {
			this.disabled = false;
                	//  函数外的this 指向 btn
			}.bind(this), 5000);

		});

```

> 匿名函数直接调用函数对象中的方法

##  用 class 语法创建类

- 传统面向对象的编程序语言都是【类】的概念，对象都是由类创建出来，但是 ECMAScript 6 规范开始增加了【类】相关的语法，使得 JavaScript 中的面向对象实现方式更加标准。

- class（类）是 ECMAScript 6 中新增的关键字，专门用于创建类的，类可被用于实现逻辑的封装。

---

创建类，添加实例成员和静态成员，并实例化 （使用class 关键字， 后面不加括号 ）

```js
		class Person {
			// 静态成员 前面添加 static
			static language = '汉语';
			static skin = 'yellow';

			static eat () {
				console.log('吃');
			}
			static he () {
				console.log('喝');
			}
		}
		// 实例化对象
		let obj = new Person();
		// 静态方法 通过类名调用
		console.log( Person.language );
		Person.eat();
--------------------------------------------------------------------------------------
		class Person {
			// 实例成员
			uname = '张三丰';
			age = 23;
			sex = '男';
			say () {
				console.log('方法');
			}
			hi () {
				console.log('hi');
			}
		}
		// 实例化对象
		let obj = new Person();
		console.log( obj.uname );
		obj.say();
```

> 类里定义的方法不加 function 

### 类中的constructor 方法（构造函数）

- 创建类时在类的内部有一个特定的方法 constructor ，`该方法会在类被实例化时自动被调用`，常被用于处理一些初始化的操作。

- constructor 是类中固定的方法名；constructor 方法在实例化时立即执行；`constructor 方法接收实例化时传入的参数`；constructor 并非是类中必须要存在的方法

---

通常constructor用于接受参数，做初始化操作

```js
		// constructor：是一个特殊的方法，如果我们不写，那么会自动的帮我们创建这个构造方法
		// 这个consntructor在实例化对象的时候就会执行
		// 通常constructor用于接受参数，做初始化操作
		class Person {
			constructor (uname, age) {
				this.uname = uname;
				this.age = age;
			}
			say () {
				console.log('说话');
			}
			run () {
				console.log('跑步');
			}

		}
		let obj = new Person('张三丰', 22);
		console.log(obj);

		let obj1 = new Person('阿飞', 23);
		console.log(obj1);
```

### 类的继承 extends

- 类的本质：函数，`通过 类名.prototype  获得原型对象`

- extends 是专门用于实现继承的语法关键字

- 如果想要实现继承，用extends定义子类，去继承父类

- `在继承的过程中子类有自己的成员时， constructor 中必须调 super 函数，否则会有语法错误`

```js
class Father {
			constructor (uname, age) {
				this.uname = uname;
				this.age = age;
			}
			qian () {
				console.log('赚他一个亿');
			}
		}
		// 继承：
		// 子类有自己的成员
		// super：调用父类的方法
		class Son extends Father {
			// 继承中，如果子类有自己的constructor，必须通过super才可以调用父类的方法
			constructor (uname, age, score) {
				// 先调用super，再设定自己的成员
				super(uname, age);
				this.score = score;
			}
			qian () {
				// 方法就近原则，
				// 如果依旧想要调用父类里面的方法，用super
				super.qian();
				console.log('2mq');
			}
		}
		let obj = new Son('阿飞', 6, 99);
		// console.log(obj);
		// 就近原则
		obj.qian();
```

> 语法糖：让语法更加简洁

## js所有对象的公共方法 

- 引用类型或是包装包类型都包含两个公共的方法 toString 和 valueOf

- valueOf 方法获取原始值，数据内部运算的基础，很少主动调用该方法

- toString 方法以字符串形式表示对象

- `undefined和null不可以使用这两个方法`

```js
		// valueOf：获取原始值
		let num = new Number(666);
		console.log( num.valueOf() );
		let flag = new Boolean(true);
		console.log(flag.valueOf());
		let d = new Date();
		console.log( d.valueOf() );
-----------------------------------------------------------------		
		let num = 123;
		console.log(num.toString());
		let flag = true;
		console.log(flag.toString());
		// undefined和null不可以使用这个方法
		console.log( null.toString() );
```



## js中的数据存储与传递

---

数据存储

- 堆和栈是内存中的数据存储空间

- 简单类型的数据保存在内存的栈空间中

- 引用类型的数据保存在内存的堆空间中，栈内存中存取的是引用类型的地址  （函数也存储在对空间中）

---

数据传递

- 变量传递给另外一个变量，称为数据传递

- 值传递：会把数据复制一份传递，（简单类型）

- 引用传递：会把数据地址复制一份传递，（引用类型）

```js
		//简单数据类型传值
		let n = 10;
		let m = 11;

		function fn (a, b) {
			// 将n的 值传递给 a
			// 将m的 值传递给 b
			a = 100;
			b = 200;
		}
		fn(n, m); 
		console.log(n, m);// n =10  m =11
------------------------------------------------------------------------------
		// 引用数据类型传值
		let o = {uname : '张三丰', age : 22, sex : '男'};
		function fun (obj) {
			// obj = o  传递的是数据地址
			obj.uname = '李寻欢';
		}
		fun(o);
		console.log(o); // 对象中的uname 改为 李寻欢

```

> `简单数据类型是进行值传递，引用数据类型（对象、数组）是数据地址传递 （传递后两个变量都指向同一数据地址）`

# Jquery 

- jQuery 是JavaScript类库（js文件）

- jQuery 封装了大量 DOM 操作的方法, 极大的提升开发效率 （简化DOM操作）

---

## Jquery 使用准备

- 下包：把 jQuery 下载到本地

- 导包：在希望使用的页面中导入下载好的 jQuery

![image-20221008101047947](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008101047947.png)

```html
  <body>
    <h2>03-使用准备</h2>
    <p>下包,导包,测试</p>
    <!-- 导包 -->
    <!--  min 压缩版本，与完整版本功能上没有区别 -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <!-- <script src="./jquery/jquery-3.5.1.min.js"></script> -->

    <!-- 测试 -->
    <script>
      //  控制台输出函数表示导入成功
      console.log($)
      // 通过 jquery 修改页面颜色
      $('body').css('backgroundColor', 'pink')
    </script>
  </body>
```

## Jquery语法

---

### 选择器

- `jQuery 中通过选择器来获取 DOM 节点`，功能类似于原生的 querySelectorAll 、querySelector方法，支持的选择器与 CSS 的选择器几乎一致。

![image-20221008102419849](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008102419849.png)

```html
<body>
    <h3>04-jQuery <span>选择器</span></h3>
    <p>
      jQuery 中的选择器是用来获取 DOM 节点的，jQuery 中所支持的选择器与 CSS 的选择器几乎一致。
    </p>
    <p>jQuery 封装了大量 DOM 操作的方法，极大的提升了开发效率！</p>
    <p class="p">jQuery 的口号是 <span>Write Less Do More!</span></p>
    <p id="p">jQuery 内部对浏览器之间的兼容也做了相关的处理。</p>
    <!-- 导入 jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <script>
      // 1. 标签选择器
      $('p').css('backgroundColor', 'pink')
      // 2. 类选择器
      $('.p').css('backgroundColor', 'skyblue')
      // 3. id选择器
      $('#p').css('backgroundColor', 'orange')
      // 4. 后代选择器
      $('p span').css('backgroundColor', 'hotpink')
    </script>
  </body>
```

>   jQuery 中的选择器 可以获得多个或者一个节点，

### 对象

- jQuery 中利用选择器获取到的并非原生的 DOM 对象，而是 jQuery 对象 `（会将 dom对象 以数组的形式存储在jquery对象中）`

-  jQuery 对象 的方法都存在于 原型对象中

- jQuery对象 和 DOM对象 的语法不能混用

![image-20221008103214531](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008103214531.png)

```html
<h3>05-jQuery 对象</h3>
    <p>
      jQuery 中利用选择器获取到的并非原生的 DOM对象，而是 jQuery 对象
    </p>

    <h4>将原生 DOM 对象转换成 jQuery 对象后，便可以调用其实例中的方法了。</h4>
    <ul>
      <li>html</li>
      <li>css</li>
      <li>javascript</li>
      <li>jQuery</li>
    </ul>
 ------------------------------------------------------------------------------------------------------   
   <script src="./jquery/jquery-3.5.1.min.js"></script>
    <script>
      // 1. 打印dom和jQ对象的区别
      let li = document.querySelector('li')
      console.log('li:', li)
      // 获得所有li标签
      let $li = $('li')
      console.log('$li:', $li)

      // 2. jQ对象的方法
      $li.css('backgroundColor', 'hotpink')
      // 3. 混着用(只是测试而已)
      // li.css('backgroundColor', 'skyblue')

      // 4. dom对象转jQ对象
      let $li2 = $(li)
      $li2.css('backgroundColor', 'skyblue')
    </script> 
    
```

> `dom对象转jQ对象   $ ( dom对象)  `: let li = document.querySelector('li') 、 let $li2 = $( li )   ；

### 获取dom对象

- jQuery 并没有封装所有 dom 的方法，例如：播放、暂停、重置的方法没有封装
- jQuery 封装了获取内部 dom 对象的方法

![image-20221023103301577](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221023103301577.png)

jQuery 通过trigger可以触发这些方法

![image-20221023103318467](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221023103318467.png)

获取dom 对象的方法 get （）、 [ ]  、 可以通过 index  获得索引 （$(this).index()）

![image-20221023103424006](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221023103424006.png)

```html
 <h3>12-获取dom对象</h3>
    <p>
      jQuery 封装了获取内部 dom 对象的方法
    </p>
    <!-- 测试标签 播放器 -->
    <button class="play">播放</button>
    <button class="pause">暂停</button>
    <br />
    <video src="./video/video.mp4"></video>
    <!-- 测试标签 form -->
    <form action="">
      <input type="text" placeholder="请输入用户名" />
      <br />
      <input type="password" placeholder="请输入密码" />
      <br />
      <input type="button" class="reset" value="重置" />
    </form>
------------------------------------------------------------------------------------------------------
<script>
      // 1.get方法
      let $btn = $('button')
      console.log('$btn:', $btn)
      let pauseBtn = $btn.get(1)
      console.log('pauseBtn:', pauseBtn)

      // 2. 中括号
      let playBtn = $btn[0]
      console.log('playBtn:', playBtn)

      // 3. 播放视频
      $('.play').click(function () {
        // $('video').play()
        // $('video').trigger('play')
        let video = $('video')[0]
        console.log('video:', video)
        video.play()
      })

      // 4. 暂停视频
      $('.pause').click(function () {
        // $('video').play()
        // $('video').trigger('pause')
        let video = $('video')[0]
        console.log('video:', video)
        video.pause()
      })

      // 5. 重置表单
      $('.reset').click(function () {
        // $('video').play()
        // $('form').trigger('reset')
        let form = $('form')[0]
        console.log('form:', form)
        form.reset()
      })
    </script>
```

[网页特效：获取dom对象](D:\Java code\4. jQuery\day03\12-获取dom对象\12-获取dom对象.html)

---

### 表单提交事件

- form 标签本身具有提交数据的能力，但是现在基本不这么用
- 将 表单的 jq 对象转为 dom对象，可以使用重置表单的 reset() 方法，来清空数据   $('#formAddCmt') [0].reset()

---

点击提交按钮，输入区域点击回车都会触发表单提交 ；表单中的 button 默认就是提交按钮

![image-20221013115618189](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013115618189.png)

阻止默认提交事件

![image-20221013115725056](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013115725056.png)

### 表单序列化

- jQuery 中封装了快速获取表单数据的方法 , 叫做序列化

- 表单元素要有 name 属性才可以通过 序列化获取到 value 值

- `获取到的数据格式是 name1=value1&name2=value2 的 字符串`

![image-20221024101238004](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221024101238004.png)

通过 序列化方法 获得表单的数据，（数据以字符串的形式体现）; `表单元素必须具有 name属性`

```html
 <form>
      昵称: <input type="text" name="nickname" />
      <br />
      爱好: <input type="text" name="habbit" />
      <br />
      好友: <input type="text" name="friend" />
      <br />
      <button>提交</button>
    </form>
    ----------------------------------------------------------------
 <script>
      $('form').submit(function (event) {
        let data = $(this).serialize()
        console.log('data:', data)
        // event.preventDefault()
        return false
      })
    </script>
```

[网页特效：表单序列化](D:\Java code\4. jQuery\day03\14-表单序列化\14-表单序列化.html)

---

### 事件绑定

- 在 jQuery 中以原生事件类型的名称为依据 , 封装了相对应的事件处理方法（JQ中并未给所有的事件都定义了方法，比如 input事件没有对应的方法）

![image-20221008112135141](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008112135141.png)

```js
 <script>
      // 1.为 li 添加点击事件
      $('li').click(function () {
        console.log('click')
        // this 获得dom 对象，获得当前点击的 li 标签对象
        console.log(this)
        // 将dom对象转为jquery对象
        let $this = $(this)
        $this.css('backgroundColor', 'pink')
      })

      // 2.为 .text 添加获得焦点事件
      $('.text').focus(function () {
        console.log('focus')
      })

      // 3.为 .text 添加失去焦点事件
      $('.text').blur(function () {
        console.log('blur')
      })

      // 4.为 .box 添加鼠标移入事件
      $('.box').mouseenter(function () {
        console.log('mouseenter')
        $(this).css('backgroundColor', 'pink')
      })

      // 5.为 .box 添加鼠标移出事件
      $('.box').mouseleave(function () {
        console.log('mouseleave')
        $(this).css('backgroundColor', 'yellowgreen')
      })
    </script>
```

> 回调函数里的this 指向 dom对象 ，需要将dom对象转成 jquery对象才能使用 jquery方法

[网页特效：jquery 事件绑定](D:\Java code\4. jQuery\day01\06-事件绑定.html)

---

#### 链式编程

- 链式编程 通过点(.) 把多个操作(方法)连续的写下去, 形成和 链子 一样的结构

- `大部分 jQ对象 方法的返回值还是同一个 jQ对象`,事件绑定方法支持链式编程的

![image-20221008150251918](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008150251918.png)

```js
 // 3. 测试jQuery方法的返回值
      let $test = $('.test')
      let $test2 = $test.focus(function () {
        console.log('获得焦点')
      })

      console.log($test === $test2) // true
```

>    console.log($test === $test2)   JQ对象和 方法的返回值对比，为true 则可以使用链式编程

#### 事件进阶

- jQuery 中封装了更为灵活的 on/off、one 方法处理 DOM 事件

![image-20221009103513125](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009103513125.png)

```html
<!-- 测试标签 -->
    <input type="text" class="onoff" />
    <br />
    <button class="one">支付</button>

<script>
      // 1. 注册事件 on
      $('.onoff').on('focus', function () {
        console.log('获取焦点')
      })
      $('.onoff').on('blur', function () {
        console.log('失去焦点')
      })
      $('.onoff').on('input', function () {
        // console.log('input事件触发')
        // console.log(this)
        let value = $(this).val()
        console.log('value:', value)
      })
      // $('.onoff').input(function () {
      //   console.log('input事件触发')
      // })

      // 2. 移除指定事件 off
      $('.onoff').off('focus')

      // 3. 移除所有事件 off
      $('.onoff').off()

      // 4. 注册一次性事件 one，执行一次后失效
      $('.one').one('click', function () {
        alert('支付成功998元')
      })
    </script>
```

> one 方法绑定一次性事件，触发一次后失效；input 事件是当文本框的值发生变化时触发

#### 页面加载事件

- jQuery 中提供了更为简便的入口函数写法

-  $(window).on('load', function () {}) ，是页面资源加载完毕执行(包括图片、css等等)逻辑代码

- $(document).ready(function () {}) ， 是DOM载入完毕就会执行 (html标签解析完毕后执行)

- `ready方法比 onload 先执行 `

![image-20221012094459635](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221012094459635.png)

![image-20221012094644579](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221012094644579.png)

```js
	//1. onload原始写法
      window.onload = function () {
        $('.box').css('backgroundColor', 'orange')
      }

     // 2. onload结合jQ
      $(window).on('load', function () {
        $('.box').css('backgroundColor', 'skyblue')
      })

      //3. ready完整写法
      $(document).ready(function () {
        $('.box').css('backgroundColor', 'pink')
      })

      //4. ready简化写法
      $(function () {
        $('.box').css('backgroundColor', 'deepskyblue')
      })

      // 5. onload 和 ready的执行先后，ready先onload后
      $(window).on('load', function () {
        console.log('load')
      })
      $(function () {
        console.log('ready')
      })
```

#### 触发事件

- jQuery 中如何通过代码的方式触发绑定的事件，不是所有的事件都能通过  .事件名（）的方式直接触发 

- `trigger 可以触发所有事件，自定义事件必须通过 trigger 触发`

-  `使用 on可以注册自定义事件`

![image-20221009111507801](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009111507801.png)

```html
 <!-- 测试用标签 -->
    <button class="btn">按钮</button>
<script>
      // 1. 直接触发
      $('.btn').click(function () {
        $(this).css('backgroundColor', 'skyblue')
      })
      // $('.btn').click()

      $('.text').on('input', function () {
        console.log('input触发啦！')
      })

      // 2. trigger触发
      $('.text').trigger('input')
      $('.btn').trigger('click')

      // 3. 注册自定义事件
      $('.text').on('itheima-input', function () {
        console.log('自定义事件触发！')
      })

      // 4. 触发自定义事件
      $('.text').trigger('itheima-input')
    </script>
```

#### window事件绑定

- 使用 jQuery 为window对象绑定事件,直接传入 window 对象，不需要写成选择器

![image-20221009122630795](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009122630795.png)

### 事件对象

- jQuery 绑定的事件中可以获取事件参数(事件对象),`用法和原生js完全一致`

![image-20221011190633692](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011190633692.png)

```js
 <script>
      // 1. 事件触发对象
      $('.outer').click(function (event) {
        // console.log(event)
        console.log('outer-click')
      })

      // 2. 阻止冒泡
      $('.box').click(function (e) {
        console.log('box-click')
        e.stopPropagation()
      })

      // 3. 阻止默认行为
      $('a').click(function (e) {
        e.preventDefault()
      })

      // 4. 判断键盘按键
      $('input').keyup(function (e) {
        console.log(e.key)
      })
    </script>
```

### 事件委托

- jQuery 中封装了事件委托的支持 , 直接通过 on 方法即可使用
- 开启事件委托后，只需为父级注册事件，减少了事件注册
- 动态新增后代可以开启事件委托为新增后代绑定事件
- `回调函数中的this是触发事件的dom对象`

![image-20221011193649971](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011193649971.png)

```js
 <script>
      // 1.减少事件注册
      // $('.dog').click(function () {
      //   $(this).remove()
      // })
     //  删除当前点击的标签
      $('.box').on('click', '.dog', function () {
         //console.log(this)
        $(this).remove()
      })

      // 2.新增后代元素的事件绑定
      $('.add').click(function () {
        $('.box').append('<img class="doge" src="./img/旺财2.jpg" alt="" />')
      })
      $('.box').on('click', '.doge', function () {
        console.log(this)
        $(this).remove()
      })

      // 3.原理是事件冒泡，阻止事件冒泡后，无法触发父级的
      $('.dog').click(function (e) {
        e.stopPropagation()
      })
    </script>
```

[网页特效：事件委托](D:\Java code\4. jQuery\day02\01.knowledges\18-事件委托.html)

---

### 尺寸操纵

- jQuery 对获取元素尺寸进行了封装，使得在不同场景中获取元素尺寸十分方便

![image-20221011182501487](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011182501487.png)

![image-20221011182436490](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011182436490.png)

```js
 <script>
      // 1.获取元素内容区域大小，盒子宽200 高120
      $('.content').click(function () {
        let width = $('.box').width()
        let height = $('.box').height()
        console.log('width:', width)
        console.log('height:', height)
      })

      // 2.获取元素内容区域 + 内边距大小，左内边距10 、下内边距20
      $('.padding').click(function () {
        let width = $('.box').innerWidth()
        let height = $('.box').innerHeight()
        console.log('width:', width)
        console.log('height:', height)
      })

      // 3.获取元素内容区域 + 内边距 + 边框大小
      $('.border').click(function () {
        let width = $('.box').outerWidth()
        let height = $('.box').outerHeight()
        console.log('width:', width)
        console.log('height:', height)
      })

      // 4.获取元素内容区域 + 内边距 + 边框 + 外边距大小
      $('.margin').click(function () {
        let width = $('.box').outerWidth(true)
        let height = $('.box').outerHeight(true)
        console.log('width:', width)
        console.log('height:', height)
      })
    </script>
```

[网页特效：尺寸操纵](D:\Java code\4. jQuery\day02\01.knowledges\14-获取尺寸.html)

---

### 内容操纵

- jQuery 中封装了设置和读取网页元素文本内容的方法

- 设置时:` html 方法解析标签` ,  text 不解析标签

- 取值时: html 方法获取标签 ,  text 只获取文本

- `设置标签时支持链式编程`

```js
       // 2. 设置标签， html能解析标签
      $('.box1').html('<a href="#">黑马程序员</a>')
      $('.box2').text('<a href="#">黑马程序员</a>')

      // 3. 取值，html 能拿到文本和标签
      let box1Html = $('.box1').html()
      let box1Text = $('.box1').text()
      console.log('box1Html:', box1Html)
      console.log('box1Text:', box1Text)
--------------------------------------------------------------------------------------
      // 4. 链式编程
      let $box1 = $('.box1')
       let $res = $box1.html(' <a href="#">传智教育</a>')
       console.log($box1 === $res) // true
       
      $box1.html(' <a href="#">传智教育</a>').click(function () {
        console.log('黑马程序员')
      })
```

### 样式操纵

- jQuery 中对样式的操作进行封装 , 可以设置或者获取样式

- 数值类的样式省略单位,默认会使用 px

- 通过JQ设置样式时，可以 传键值对、也可以传对象

- 获取样式需要传递样式名，如果有 - 连接的样式名 则用改为驼峰命名

![image-20221008163941415](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008163941415.png)

![image-20221008164010497](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008164010497.png)

![image-20221008164239864](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008164239864.png)

```js
<body>
    <h3>11-样式操纵</h3>
    <p>css可以获取及设置元素样式,设置的是行内样式</p>
    <!-- 测试用的盒子 -->
    <div class="box"></div>
    <!-- 引入 jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <script>
      // 1. 键值对设置
      $('.box').css('backgroundColor', 'pink')
      $('.box').css('border', '10px solid orange')
      $('.box').css('width', '250px')
      $('.box').css('height', 250)

      // 2. 对象方式设置
      $('.box').css(
          {
        backgroundColor: 'skyblue',
        border: '10px solid yellowgreen',
        width: 100,
        height: 100
      }
      )

      // 3. 样式获取
      let width = $('.box').css('width')
      console.log('width:', width) // 100px
    </script>
  </body>
```

### 属性操纵

- jQuery 中对属性的操作进行封装 , 可以设置、获取和删除属性

![image-20221009091518269](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009091518269.png)

```html
<body>
    <h3>12-属性操纵</h3>
    <p>jQuery 中封装了设置和读取网页元素属性的方法。</p>
    <!-- 测试用标签 -->
    <a href="#">黑马程序员</a>
    <img src="" />
    <!-- 导入 jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <script>
      // 1. 赋值
      $('a').attr('href', 'http://www.itheima.com/')
      $('img').attr('src', 'http://www.itheima.com/images/logo.png')
	// 自定义属性
      $('img').attr('info', '黑马程序员')

      // 2. 取值
      let href = $('a').attr('href')
      console.log('href:', href)
      let info = $('img').attr('info')
      console.log('info:', info)
      // 3. 删除
      $('a').removeAttr('href')
      $('img').removeAttr('src')
      $('img').removeAttr('info')
    </script>
  </body>
```

> 可以添加自定义属性或者删除

#### 操纵表单元素value属性

![image-20221009095924947](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009095924947.png)

```html
 <input class="text" type="text" />
 
     <script>
      // 1. 赋值
      $('.text').val('黑马程序员！')

      // 2. 文本框失去焦点时，取值
      $('.text').blur(function () {
        let value = $(this).val()
        console.log('value:', value)
      })
    </script>
 
```

### 操纵类名

- jQuery 中封装了为网页元素添加、移除、检测、切换类名的方法。

![image-20221009102604552](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009102604552.png)

```html
 
 <!-- 操纵的盒子 -->
    <div class="test"></div>
    <hr />
    <!-- 测试用按钮 -->
    <button class="add">添加类名</button>
    <button class="remove">移除类名</button>
    <button class="has">判断类名</button>
    <button class="toggle">切换类名</button>

<script>
      // 1.  添加类名
      $('.add').click(function () {
        $('.test').addClass('active')
      })

      // 2. 移除类名
      $('.remove').click(function () {
        $('.test').removeClass('active')
      })

      // 3. 判断类名
      $('.has').click(function () {
        let res = $('.test').hasClass('active')
        console.log('res:', res)
      })

      // 4. 切换类名
      $('.toggle').click(function () {
        $('.test').toggleClass('active')
      })
    </script>
```

> 切换类名：有则移除，没有则添加



### 查找元素的方法

- jQuery 中封装了查找元素的方法，可以基于元素的结构关系查找新的元素

![image-20221009100910217](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009100910217.png)

```js
<script>
      // 1. 父元素 parent
      // $('.course')
      //   .parent()
      //   .css('backgroundColor', 'pink')

      // 2. 子元素 children
      $('.course')
        .children()
        .css('backgroundColor', 'skyblue')
      $('.campus')
        .children('.bj')
        .css('backgroundColor', 'pink')

      // 3.  兄弟元素 siblings
      $('.sz')
        .siblings()
        .css('color', 'red')
      $('.sz')
        .siblings('.gz')
        .css('backgroundColor', 'yellowgreen')

      // 4. 后代元素 find
      $('.container')
        .find('h4')
        .css('backgroundColor', 'yellowgreen')

      $('.container')
        .find('li')
        .css('border', '10px solid orange')
    </script>
```

> children() 不传参能拿到所有子元素；siblings() 不传参则会找的除了自己外的所有兄弟元素
>
> `find () 方法必须传参`

### 过滤方法

- jQuery 中封装了过滤方法,对 jQuery 对象中的 dom 元素再次筛选

![image-20221008162437226](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008162437226.png)

```html
 <body>
    <h3>过滤方法</h3>
    <p>对获取到的元素进行过滤,返回的依旧是jQuery对象</p>
    <ul>
      <li>html</li>
      <li>css</li>
      <li>javascript</li>
    </ul>
    <!-- 引入 jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <script>
      // 1. first方法
      $('li')
        .first()
        .css('backgroundColor', 'pink')

      // 2. last方法
      $('li')
        .last()
        .css('backgroundColor', 'yellowgreen')

      // 3. eq方法
      $('li')
        .eq(1)
        .css('backgroundColor', 'skyblue')
    </script>
  </body>
```

### 获取位置

- 通过jQuery直接获取元素的位置
- offset 、position 方法都是返回对象

![image-20221010105314999](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221010105314999.png)

> position 在没有定位的情况下 以html标签作为参照物（距离浏览器左上角的距离）；`position以外边距margin为边界（作为子盒子时）,不计算margin （父级盒子存在外边距时，以盒子边框作为边界，计算到子盒子margin边界的距离）`；
>
> 当前盒子中存在外边距时，offset会把外边距margin计算进去（以子盒子边框作为边界）

获取box盒子 的 offset、position的位置

```js


<body>
    <h3>获取位置</h3>
    <p>
      由于 jQuery
      对获取元素位置进行了封装，使得在不同场景中获取元素位置变的十分方便。
    </p>
    <div class="outer">
      <div class="box"></div>
    </div>
    <button class="offset">测试offset方法</button>
    <button class="position">测试position方法</button>

    <script src="./jquery/jquery-3.5.1.min.js"></script>
    <script>
      // 测试offset方法
      $('.offset').click(function () {
        let offset = $('.box').offset()
        console.log('offset:', offset)
      })
      // 测试position
      $('.position').click(function () {
        let position = $('.box').position()
        console.log('position:', position)
      })
    </script>
```

[网页特效：获取盒子位置](D:\Java code\4. jQuery\day02\01.knowledges\02-获取位置.html)

---

### 获取滚动距离

- 通过jQuery获取元素的滚动距离
- 获取页面滚动距离要使用 ‘html’ 标签

![image-20221010114223956](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221010114223956.png)

```html
 <button class="html-get">获取 页面 滚动距离</button>
    <button class="html-set">设置 页面 滚动距离</button>
    <button class="box-get">获取 box 滚动距离</button>
    <button class="box-set">设置 box 滚动距离</button>
    
     <script>
      // 1.获取 页面 滚动距离
      $('.html-get').click(function () {
        let top = $('html').scrollTop()
        console.log('top:', top)
        let left = $('html').scrollLeft()
        console.log('left:', left)
      })

      // 2.设置 页面 滚动距离
      $('.html-set').click(function () {
        $('html').scrollTop(18)
        $('html').scrollLeft(18)
      })

      // 3.获取 box 滚动距离
      $('.box-get').click(function () {
        let top = $('.box').scrollTop()
        console.log('top:', top)
        let left = $('.box').scrollLeft()
        console.log('left:', left)
      })

      // 4.设置 box 滚动距离
      $('.box-set').click(function () {
        $('.box').scrollTop(66)
        $('.box').scrollLeft(66)
      })
    </script>
```

[网页特效：获取滚动距离](D:\Java code\4. jQuery\day02\01.knowledges\03-滚动距离.html)

---

### 插入、改变节点

- jQuery 中封装了在指定位置动态插入元素节点的方法,可以插入节点或者改变节点位置
- 传入创建的dom元素或者html标签，则会插入新的节点
- `传入现有的dom元素或者jQuery对象，则会改变元素的位置`

![image-20221011173043880](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011173043880.png)

给按钮添加点击事件，并插入新节点或者改变当前节点位置

```html
<script>
      // 1.父元素结尾插入节点
      $('.insert .append').click(function () {
        // 创建dom元素
        // let img = document.createElement('img')
        // img.src = './img/旺财.jpg'
        // // console.log(img)
        // $('.container').append(img)

        // html结构
        $('.container').append('<img src="./img/旺财.jpg" alt="">')
      })

      // 2.父元素开头插入节点
      $('.insert .prepend').click(function () {
        // html结构
        $('.container').prepend('<img src="./img/旺财.jpg" alt="">')
      })

      // 3.兄弟元素前插入节点
      $('.insert .before').click(function () {
        // html结构
        $('.Teemo').before('<img src="./img/旺财.jpg" alt="">')
      })

      // 4.兄弟元素后插入节点
      $('.insert .after').click(function () {
        // html结构
        $('.Teemo').after('<img src="./img/旺财.jpg" alt="">')
      })

      // 5.移动到父元素结尾
      $('.move .append').click(function () {
        // dom元素
        // $('.container').append(document.querySelector('.doge'))
        // jQuery对象
        $('.container').append($('.doge'))
      })
      // 6.移动到父元素开头
      $('.move .prepend').click(function () {
        // jQuery对象
        $('.container').prepend($('.doge'))
      })

      // 7.移动到兄弟元素前面
      $('.move .before').click(function () {
        // jQuery对象
        $('.Teemo').before($('.doge'))
      })

      // 8.移动到兄弟元素后面
      $('.move .after').click(function () {
        // jQuery对象
        $('.Teemo').after($('.doge'))
      })
    </script>
```

[网页特效：JQ插入、改变节点](D:\Java code\4. jQuery\day02\01.knowledges\11-插入节点.html)

---

### 删除节点

- jQuery 中封装了动态删除元素节点的方法

- remove方法删除的是调用方法的元素节点

![image-20221011191828041](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011191828041.png)

```html
 <div class="box">
      <button class="remove">删除自己</button>
      <button class="remove-box">删除父元素</button>
    </div>
<script>
      // 1.删除自己
      $('.remove').click(function () {
        $(this).remove()
      })
      // 2.删除父元素
      $('.remove-box').click(function () {
        $(this)
          .parent()
          .remove()
      })
    </script>
```

[网页特效：删除节点](D:\Java code\4. jQuery\day02\01.knowledges\17-删除节点.html)

---

### 克隆节点

- jQuery 中封装了克隆(复制)，节点的方法

- 方法返回的还是 jQuery 对象  

- 传入 true 事件也会一起克隆

![image-20221023101410421](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221023101410421.png)

克隆前需要选中第一个元素

```html
 <h3>11-克隆</h3>
    <p>
      jQuery 中封装了克隆(复制)，节点的方法
    </p>
    <!-- 测试标签 -->
    <button class="clone">克隆(不带事件)</button>
    <button class="deep-clone">克隆(带事件)</button>
    <div class="box">
      <button>按钮</button>
    </div>
-------------------------------------------------------------------------------
<script>
      // 1. 为box中的按钮绑定事件: 把box的背景色变成黄绿色
      $('.box button').click(function () {
        $(this)
          .parent()
          .css('backgroundColor', 'yellowgreen')
      })

      // 2. 普通克隆
      $('.clone').click(function () {
        let $clone = $('.box')
          .first()
          .clone()
        $('body').append($clone)
      })

      // 3. 和事件一起克隆
      $('.deep-clone').click(function () {
        let $clone = $('.box')
          .first()
          .clone(true)
        $('body').append($clone)
      })
    </script>
```

[网页特效：jq 克隆](D:\Java code\4. jQuery\day03\11-克隆\11-克隆.html)

---

### JQ 工具方法  （了解）

- jQuery 除了封装了大量的 DOM 操作外，还提供了一些工具方法，这些方法通过 $ 或 jQuery 直接调用 
- 逐步被 ES6 及更高级的版本新增特性取代

![image-20221024110120701](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221024110120701.png)

```js
<script>
      let arr = ['北京', '上海', '广州', '深圳']

      // 1. $.each方法 类似于forEach方法
      $.each(arr, function (index, value) {
        console.log('index:', index)
        console.log('value:', value)
      })

      // 2. $.map方法 ,回调函数带有返回值
      let arr2 = $.map(arr, function (value) {
        console.log('value:', value)
        return value + '校区'
      })
      console.log('arr2:', arr2) 
    </script>
```

### JQ基础动画效果

---

#### 1.显示&隐藏动画

- 通过jQuery以动画的方式切换元素的显示&隐藏
- 改变的是元素 display 样式

![image-20221010171601978](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221010171601978.png)

```html
 <button class="show">显示</button>
    <button class="hide">隐藏</button>
    <button class="toggle">显示&隐藏</button>
-------------------------------------------------------------------
<script>
      // 1.show方法
      $('.show').click(function () {
        $('.box').show(1000)
      })
      // 2.hide方法
      $('.hide').click(function () {
        $('.box').hide(1000)
      })
      // 3.toggle方法
      $('.toggle').click(function () {
        $('.box').toggle(3000)
      })
    </script>
```

> 不设置时间则没有动画效果
>
> `toggle 方法是先判断当前元素的状态，如果显示 则点击后隐藏，反之一样`

#### 2.淡入&淡出动画

- 通过jQuery以淡入&淡出的方式切换元素的显示隐藏
- 淡入和淡出 ，改变的是元素透明度 opactity 和 display 样式

![image-20221010172439615](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221010172439615.png)

```html
<button class="fade-in">淡入</button>
    <button class="fade-out">淡出</button>
    <button class="fade-toggle">淡入&淡出</button>
-----------------------------------------------------------------------------
<script>
      // 1.fadeIn 淡入
      $('.fade-in').click(function () {
        $('.box').fadeIn(2000)
      })

      // 2.fadeOut 淡出
      $('.fade-out').click(function () {
        $('.box').fadeOut(2000)
      })

      // 3.fadeToggle 淡入&淡出
      $('.fade-toggle').click(function () {
        $('.box').fadeToggle(2000)
      })
    </script>
```

> `fadeToggle 方法是先判断当前元素的状态，如果显示 则点击后实现淡出效果（先降低透明度，最后设置隐藏），反之一样`

#### 3.展开&收起动画

- 通过jQuery以展开(高度增大-显示)&收起(高度减小-隐藏)的方式切换元素的显示隐藏
- slideDown，恢复盒子原先的垂直方向的高度（包括内外边距）（默认向下展开）

![image-20221011082036553](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011082036553.png)

```js
<script>
      // 1.slideDown展开
      $('.slide-down').click(function () {
        $('.box').slideDown(4000)
      })

      // 2.slideUp收起
      $('.slide-up').click(function () {
        $('.box').slideUp(4000)
      })
      // 3.slideToggle展开&收起
      $('.slide-toggle').click(function () {
        $('.box').slideToggle(1000)
      })
    </script>
```

[网页特效：盒子展开动画](D:\Java code\4. jQuery\day02\01.knowledges\07-展开&收起动画.html)

---

#### 4.动画队列及停止方法

- 通过jQuery为元素设置的多个动画会依次添加到动画队列中,并根据添加的顺序依次播放
- stop （）方法会停止当前动画，但是后添加的动画还是会执行
- `传递一个 true ，在当前动画状态停止`，后面的动画不会执行
- `传递两个个 true ，在当前动画的结束状态停止`，后面的动画不会执行
- `动画方法和stop方法返回的是同一个jQuery对象 可以支持链式编程`

![image-20221011083847978](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011083847978.png)

点击按钮时添加4个动画

```js
<script>
      // 1.添加动画
      $('.add').click(function () {
        $('.box')
          .slideUp(4000)
          .slideDown(4000)
          .hide(4000)
          .show(4000)
      })

      // 2.不传递参数 stop()
      $('.stop').click(function () {
        $('.box').stop()
      })

      // 3.传递1个true stop(true)
      $('.stop2').click(function () {
        $('.box').stop(true)
      })

      // 4.传递2个true stop(true,true)
      $('.stop3').click(function () {
        $('.box').stop(true, true)
      })
    </script>
```

[网页特效：动画队列](D:\Java code\4. jQuery\day02\01.knowledges\08-动画队列及停止方法.html)

---

### JQ高级动画

---

#### 1.自定义动画

-  jQuery提供了animate方法来实现更为复杂的动画效果

![image-20221011091346957](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011091346957.png)

![image-20221011104927532](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011104927532.png)

> `animate 第一个参数需要传递对象`

#### 2.动画的回调函数

- 所有的  jQuery 动画方法都支持传入回调函数, `回调函数写在最后面`
- 回调函数会在动画播放完毕后执行
- `回调函数中的this是执行动画的dom元素`

![image-20221011175953777](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011175953777.png)

```js
<script>
      // 1.简单动画的回调函数
      $('.simple').click(function () {
        $('.box').fadeOut(2000, function () {
          console.log('淡出啦!')
          console.log('this:', this)
        })
      })

      // 2.自定义动画的回调函数,回调函数是动画播放完毕后执行
      $('.animate').click(function () {
        $('.box').animate({ width: 400 }, 2000, function () {
          console.log('变宽啦!')
          console.log('this:', this)
          $(this).css('backgroundColor', 'pink')
        })
      })
    </script>
```

[网页特效：动画的回调函数](D:\Java code\4. jQuery\day02\01.knowledges\12-动画的回调函数.html)

---

#### 3.动画的延迟方法

- jQuery 不仅可以设置动画执行的速度，还能在动画执行前设置一定的延时

![image-20221011180955652](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011180955652.png)

```js
 <script>
      $('.animate').click(function () {
        $('.box')
          .delay(2000)
          .fadeOut()
          .delay(2000)
          .slideDown()
      })
    </script>
```



## jquery插件

---

### 自定义插件

- 插件是 jQuery 提供的扩展机制 , `本质是往 jQuery 原型对象上添加方法`
- `定义插件后，所有 JQ对象都能使用`
- 插件名称可以 理解为方法名
- 导入 jQuery 之后，会多2个全局变量，一个是 $ 一个是 jQuery

![image-20221024104726226](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221024104726226.png)

往JQ的原型对象中添加改变背景色方法，实现功能扩展 

```html
  <h3>15-插件机制</h3>
    <p>
      插件是 jQuery 提供的扩展机制 , 本质是往 jQuery 原型对象上添加方法
    </p>
    <!-- 测试标签 -->
    <div class="box"></div>
    ------------------------------------------------------------------------------
 <script>
      // 1.基本使用
      $.fn.extend({
        sayHello () {
          console.log('吃了没!')
          console.log(this)
        }
      })
      let $box = $('.box')
      console.log('$box:', $box)
      $box.sayHello()
      // 2.修改背景色插件
      $.fn.extend({
        setBgColor (color) {
          this.css('backgroundColor', color)
        }
      })
      $('.box').setBgColor('orange')
      $('p').setBgColor('pink')
      $('h3').setBgColor('yellowgreen')
    </script>
```

[网页特效：添加 jq 插件](D:\Java code\4. jQuery\day03\15-插件机制\15-插件机制.html)

---

###  slick  （ 轮播图插件）

- 下包：把插件下载到本地导包：

- 先导入 jQuery , 再导入插件 , 导入css(需要的话)用包：

- 根据文档(说明书)使用   官方文档:https://github.com/kenwheeler/slick

---

先引入插件所需要的样式表，先导入 jQuery 的 js文件 , 再导入插件的 js 文件

```html
<!-- 引入插件所需要的样式表 -->
  <link rel="stylesheet" href="./assets/slick/slick.css">
  <link rel="stylesheet" href="./assets/slick/slick-theme.css">

 <!-- 引入自己的样式 -->
<link rel="stylesheet" href="">

    <!-- 先导入 jQuery -->
    <script src="./assets/jquery/jquery-3.5.1.min.js"></script>
    <!-- 在 jQuery 之后引入插件 -->
    <script src="./assets/slick/slick.min.js"></script>

```

插件语法 （配置属性可以实行相应的 js功能，标签选择器 则是确定按键的样式和位置）

![image-20221012102028410](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221012102028410.png)

调用插件的初始化方法  slick（），默认样式不符合需求直接添加 CSS 覆盖即可 （通过浏览器的检查元素获得当前样式名）

```html
<body>
    <h3>03-轮播图插件</h3>
    <p>学习使用jQuery的轮播图插件slick</p>
    <!-- 测试用标签 -->
    <div class="slider-container">
      <!-- 轮播图区域 -->
      <div class="slider">
        <div><img src="./images/1.png" alt="" /></div>
        <div><img src="./images/2.png" alt="" /></div>
        <div><img src="./images/3.png" alt="" /></div>
        <div><img src="./images/4.png" alt="" /></div>
        <div><img src="./images/5.png" alt="" /></div>
      </div>
      <!-- 自定义左右箭头 -->
      <div class="control">
        <div class="prev">上一个</div>
        <div class="next">下一个</div>
      </div>
    </div>
    <script src="./jquery/jquery-3.5.1.min.js"></script>
    <script src="./slick/slick.js"></script>
    <script>
      $('.slider').slick({
        // autoplay: true,
        // arrows: false,
         //使用自定义的箭头，值为标签选择器
        prevArrow: '.prev',
          // 显示底部 原点导航
        dots: true,
      })
    </script>
  </body>
```

[网页特效：轮播图插件](D:\Java code\4. jQuery\day03\03-轮播图插件slick\03-轮播图插件.html)

---

### lazyload （ 懒加载插件 ）

- 懒加载：图片用到了再去加载（只加载页面上能看到的图片，可以给图片较多的页面提速），常见于有大量图片的网页，比如电商

- 先导入 jQuery , 再导入插件

- `将图片的src 属性改为  data-original，找到希望懒加载的图片并调用lazyload方法 `$('.lazyload').lazyload()

- 官方文档:https://github.com/tuupola/lazyload/tree/1.x

![image-20221012103910981](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221012103910981.png)

```html
 <body>
    <h3>04-懒加载插件</h3>
    <p>懒加载插件，用到了再去加载</p>
    <!-- 测试标签 -->
    <div class="wall"></div>
    <!-- 图片 -->
    <img class="lazyload" data-original="./images/1.png" alt="" />
    <img class="lazyload" data-original="./images/2.png" alt="" />
    <!-- 先导入jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <!-- 导入lazyload插件 -->
    <script src="./lazyload/jquery.lazyload.js"></script>
    <script>
      $('.lazyload').lazyload()
    </script>
  </body>
```

[网页特效:懒加载插件](D:\Java code\4. jQuery\day03\04-懒加载插件\04-懒加载插件.html)

---

### fullpage   （全屏滚动插件 ）

- 每个区域必须有 section 这个类名
- 调用 fullpage  方法，传入对象并添加相应的属性
- 更多的配置参数可以查阅官方文档:https://github.com/alvarotrigo/fullPage.js/tree/2.9.7

---

要先导入插件样式， 再导入 jq 文件 和 插件的 js文件

```html
  <!-- 导入 fullpage 配套样式 -->
    <link rel="stylesheet" href="./fullpage/jquery.fullpage.css" />

    <!-- 导入 jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <!-- 在 jQuery 之后导入 fullpage 插件 -->
    <script src="./fullpage/jquery.fullpage.js"></script>

```

盒子上必须添加 section 类名

```html
<div id="fullpage">
      <div class="section">第一屏</div>
      <div class="section">第二屏</div>
      <div class="section">第三屏</div>
    </div>

```

常用的配置属性

![image-20221013100636880](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013100636880.png)

```html
 <div id="fullpage">
      <div class="section one">区域1</div>
      <div class="section two">区域2</div>
      <div class="section three">区域3</div>
    </div>
    ------------------------------------------------------------------
 <script>
      $('#fullpage').fullpage({
        navigation: true,
        navigationPosition: 'left',
        // 锚链接 能定位到用户浏览的位置
        anchors: ['one', 'two', 'three'],
        afterLoad(anchor, index) {
          console.log('anchor:', anchor)
          console.log('index:', index) // 拿到的索引从 1开始
        },
      })
    </script>
```

>  afterLoad 回调函数 中得到当前区域 索引 （从1开始）

[网页特效：全屏滚动插件](D:\Java code\4. jQuery\day03\06-fullpage插件\06-fullpage插件.html)

---

### datepicker （日期选择器插件）

- 让用户在不同的浏览器下可以用一致的方式来选择日期
- 更多的配置参数可以查阅官方文档:**https://github.com/fengyuanchen/datepicker/blob/master/README.md**

---

文件导入流程；默认显示的是英文，需要导入 中文语言包

```html
 <!-- 导入日期选择器的样式 -->
    <link rel="stylesheet" href="./datepicker/datepicker.css" />

    <!-- 导入jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <!-- 导入日期选择器插件 -->
    <script src="./datepicker/datepicker.js"></script>
    <!-- 导入语言包 -->
    <script src="./datepicker/i18n/datepicker.zh-CN.js"></script>

```

常用的配置属性

![image-20221013122336148](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013122336148.png)

通常需要搭配文本框使用

```js
<script>
      $('.datepicker').datepicker({
        // 日期语言配置为中文 ,必须导入中文语言包
        language: 'zh-CN',
        autoPick: true,
        autoHide: true,
      })
    </script>
```

[网页特效：日期插件](D:\Java code\4. jQuery\day03\09-日期选择器\09-日期选择器.html)

---

### validate （表单验证插件）

- 验证用户在表单中输入的内容
- 表单需要禁用默认的提交事件，因为提交前需要先进行表单验证

---

导入流程

```js
<!-- 导入jQuery -->
    <script src="./jquery/jquery-3.5.1.js"></script>
    <!-- 导入validate插件 -->
    <script src="./jquery-validate/jquery-validate.js"></script>

```

常用配置属性，需要搭配 input 中的自定义属性使用

| 常用配置    | 含义                                          | 默认值 | 备注         |
| ----------- | --------------------------------------------- | ------ | ------------ |
| onBlur      | 失去焦点时验证                                | false  | true/false   |
| onSubmit    | 提交表单时验证                                | true   | true/false   |
| sendForm    | 是否提交表单                                  | true   | true/false   |
| valid       | 所有表单项验证通过执行的 回调函数             | 无     | this是jQ对象 |
| invalid     | 只要有一个表单项验证不通过时，执行的 回调函数 | 无     | this是jQ对象 |
| description | 错误提示信息                                  | 无     | Object       |

---

调用 validate 方法进行属性配置

![image-20221013124525242](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013124525242.png)

给 input 标签添加 自定义属性 

| 自定义属性       | 含义                   | 备注                      |
| ---------------- | ---------------------- | ------------------------- |
| data-required    | 验证表单项不能为空     | 不需要值                  |
| data-pattern     | 基于正则表达式验证     | 正则表达式                |
| data-describedby | 指定显示错误信息的标签 | 标签的id                  |
| data-description | 指定错误信息的内容     | 和description中的属性对应 |

```html
<input
            type="password"
            name="password"
            data-required
       	   data-pattern=".{6,}"
            data-describedby="password-error"
            data-description="password"
          />
          <span class="error" id="password-error"></span>
---------------------------------------------------------------------------------------------
<script>
 $('form').validate({
        description: {
          password: {
            required: '密码不能为空!',
            pattern: '密码不能少于6位!',
          },
        },
```

> data-description  的值 可以随意定义，作为   description对象中的对象名；`但是对象中的属性名必须与 data-required 、data-pattern 的后缀一致  `:   required: '密码不能为空!',  pattern: '密码不能少于6位!',

使用validate 实现表单验证

```html
 <form action="">
      <ul>
        <li>
          昵称:
          <input
            data-required
            data-describedby="nickname-error"
            data-description="nickname"
            type="text"
            name="nickname"
          />
          <span class="error" id="nickname-error"></span>
        </li>
        <li>
          密码:
          <input
            data-required
            data-pattern=".{6,}"
            data-describedby="password-error"
            data-description="password"
            type="password"
            name="password"
          />
          <span class="error" id="password-error"></span>
        </li>
        <li>
          <label>
            <input
              data-required
              data-describedby="agree-error"
              data-description="agree"
              type="checkbox"
              value="true"
              name="agree"
            />
            同意注册协议
          </label>
          <span class="error" id="agree-error"></span>
        </li>
        <li>
          <button class="btn">提交</button>
        </li>
      </ul>
    </form>
 --------------------------------------------------------------------------
 <script>
      $('form').validate({
        sendForm: false,
        description: {
          password: {
            required: '密码不能为空!',
            pattern: '密码的长度必须大于等于6!'
          },
          nickname: {
            required: '昵称不能为空!'
          },
          agree: {
            required: '必须同意用户协议!'
          }
        },
        valid () {
          console.log('验证成功')
        },
        invalid () {
          console.log('验证失败')
        }
      })
    </script>
```

[网页特效：validate 实现表单验证](D:\Java code\4. jQuery\day03\10-表单校验\10-表单校验.html)

---

## Jquery案例

---

### 计数器

![image-20221008153139616](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221008153139616.png)

```js
 <script>
      // span抽取
      let $span = $('.input-num span')
      // 递减
      // $('.input-num button:first-child')
      $('.input-num button')
        .first()
        .click(function () {
          console.log('递减')
          let num = $span.text()
          if (num == 0) {
            alert('哥们别点啦,到底啦')
            return
          }
          num--
          $span.text(num)
        })
      // 累加
      // $('.input-num button:last-child')
      $('.input-num button')
        .last()
        .click(function () {
          console.log('累加')
          let num = $span.text()
          if (num == 10) {
            alert('哥们别点啦,到头啦')
            return
          }
          num++
          $span.text(num)
        })
    </script>
```

[网页特效：计数器](D:\Java code\4. jQuery\day01\09-计数器\index.html)

---

### 图片切换

![image-20221009093719660](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009093719660.png)

```js
 <script>
      // 箭头缩放，添加鼠标移入移出效果
      $('.center a')
        .mouseenter(function () {
          $(this).css('transform', 'scale(1.1)')
        })
        .mouseleave(function () {
          $(this).css('transform', 'scale(1)')
        })

      // 默认隐藏左侧按钮
      $('.left').css('display', 'none')

      //  图片名称为数字，类似数字下标
      // 右侧按钮
      let index = 1
      $('.right').click(function () {
        index++
        $('.cover').attr('src', `./images/${index}.png`)
        $('.left').css('display', 'block')
        if (index == 5) {
          $(this).css('display', 'none')
        }
      })
      // 左侧按钮
      $('.left').click(function () {
        index--
        $('.cover').attr('src', `./images/${index}.png`)
        $('.right').css('display', 'block')
        if (index == 1) {
          $(this).css('display', 'none')
        }
      })
    </script>
```

[网页特效：JQ 图片切换](D:\Java code\4. jQuery\day01\13-图片切换\index.html)

---

### 输入统计

- 默认把统计字数设置为0，发布按钮设置为禁用状态

- 文本域获取焦点时父元素高亮，失去焦点时移除高亮效果

- 文本域输入文字时，同步获取输入的文字个数并显示出来

- 输入内容为空时禁用发布按钮，不为空时启用发布按钮

- 页面初次加载时，触发input 事件 获得文本框的内容

![image-20221009104444101](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009104444101.png)

```html
 <!-- 字数统计区域 -->
            <p class="words">
              已输入
              <span>5</span>
              字
            </p>
          </div>
          <!-- 输入区域 -->
          <div class="input-box">
            <textarea></textarea>
          </div>

<script>
// 立即执行函数，避免全局变量污染
;(function () {
  // 1. 初始状态，可以直接在标签上添加和修改
  // $('.words span').text(0)
  // $('.publish_btn').addClass('disabled')

  // 2. 高亮效果,给父类添加 active
  $('.input-box textarea').on('focus', function () {
    $(this)
      .parent()
      .addClass('actived')
  })
  $('.input-box textarea').on('blur', function () {
    $(this)
      .parent()
      .removeClass('actived')
  })

  // 3. 字数统计
  $('.input-box textarea').on('input', function () { 

    // 获得字符串长度
    let length = $(this).val().length
    //  显示输入的数字
    $('.words span').text(length)
    if (length === 0) {
      $('.publish_btn').addClass('disabled')
    } else {
      $('.publish_btn').removeClass('disabled')
    }
  })
  // 4. 页面初次加载时，触发input事件
  $('.input-box textarea').trigger('input')
})()

```

### 登录切换

- 点击某种登录方式，切换到对应的登录界面
- 点击右上角图标，根据当前状态在手机登录和安全登录之间切换 ，判断当前图片是否被点击（是否添加了active类）

![image-20221009115414704](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221009115414704.png)

```html
<!-- 切换登录场景 -->
<div class="multi-type">
  <a data-label="#account" class="label active">账号登录</a>
  <a data-label="#secure" class="label">安全登录</a>
  <a data-label="#phone" class="icon"></a>
</div>
<!-- 登录界面 -->
<div class="login-type">
  <!-- 账号登录 -->
  <div class="account" id="account">内容省略</div>
  <!-- 安全登录 -->
  <div class="secure" id="secure">内容省略</div>
  <!-- 手机号登录 -->
  <div class="phone" id="phone">内容省略</div>
</div>
<script>
;(function () {
  // 1. 账号 & 安全切换
  $('.label').click(function () {
    $(this).addClass('active')
    $(this)
      .siblings()
      .removeClass('active')

    //  获取自定义属性，该值为 标签的id
    let id = $(this).attr('data-label')
    console.log('id:', id)
    // 点击页面显示，其他隐藏
    $(id).css('display', 'block')
    $(id)
      .siblings()
      .css('display', 'none')
  })

  // 2.安全 & 手机切换
  $('.icon').click(function () {
      // 判断是否被点击
    let isAcitve = $(this).hasClass('active')
    console.log('isActive:', isAcitve)
      // 为false表示未被点击，添加active类并进行页面切换
    if (isAcitve === false) {
      $(this).addClass('active')
      $(this)
        .siblings()
        .removeClass('active')

      let id = $(this).attr('data-label')
      console.log('id:', id)
      $(id).css('display', 'block')
      $(id)
        .siblings()
        .css('display', 'none')
    } else {
      //  再次点击时，触发安全页面的点击事件，切换到安全页面
      $('.label')
        .last()
        .trigger('click')
    }
  })
})()

```

[网页特效：登陆切换](D:\Java code\4. jQuery\day01\20-登录切换\模板.html)

---

### 腾讯全端

- 面只要滚动为顶部添加高亮效果,在顶部时移除高亮

- 滚动距离超过200显示返回顶部,小于则隐藏.点击让页面滚回顶部

![image-20221010121015571](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221010121015571.png)

> 1.使用window 绑定滚动事件，获得页面滚动距离，滚动时添加高亮
>
> ```js
> 
> // 1. 顶部高亮
> $(window).scroll(function () {
> // console.log('scroll')
> let top = $('html').scrollTop()
> // console.log('top:', top)
> if (top === 0) {
> $('.header').removeClass('scrolled')
> } else {
> $('.header').addClass('scrolled')
> }
> })
> ```
>
> 2.滚动距离大于200时，显示返回按钮，小于则隐藏
>
> - ​	每次展开动画片都先停止当前动画，确保在快速滑动后只保留一个动画
>
> ```js
> let top = $('html').scrollTop()
> if (top > 200) {
> // 显示 无动画
>    // $('.gotop').css('display', 'block')
>    // 显示
>    // $('.gotop').show(1000)
>    // 淡入
>    // $('.gotop').fadeIn(1000)
>    // 展开
>    $('.gotop')
>      .stop()
>      .slideDown(1000)
>    } else {
>    // 隐藏 无动画
>    // $('.gotop').css('display', 'none')
>    // 隐藏
>    // $('.gotop').hide(1000)
>    // 淡出
>    // $('.gotop').fadeOut(1000)
>    // 收起
>    $('.gotop')
>      .stop()
>      .slideUp(1000)
>  }
> ```
>
> 3.点击返回顶部，设置页面滚动距离为 0，使用animate 产生动画效果
>
> ```js
> $('.gotop').click(function () {
> //$('html').scrollTop(0)
>      $('html').animate({
>       scrollTop: 0
> })
> ```
>
> 

[网页特效：腾讯全端](D:\Java code\4. jQuery\day02\02.demos\04-腾讯全端\index.html)

---

### 爱旅行

- 返回顶部：页面滚动距离大于某个值时淡入,小于时淡出,点击时以动画的方式让页面返回顶部
- 意见反馈：点击意见反馈展开反馈窗口,点击关闭按钮收起反馈窗口
- 自动轮播：

![image-20221011111232962](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011111232962.png)

> 1.页面滚动距离大于某个值时淡入,小于时淡出,点击时以动画的方式让页面返回顶部
>
> ```js
>  // 0.默认隐藏返回顶部
>   $('.gotop').hide()
> 
>   // 返回顶部功能
>   // 1.注册滚动事件
>   $(window).scroll(function () {
>     // console.log('scroll')
>     let top = $('html').scrollTop()
>     // console.log('top:', top)
>     if (top > 200) {
>       $('.gotop')
>         .stop()
>         .fadeIn()
>     } else {
>       $('.gotop')
>         .stop()
>         .fadeOut()
>     }
>   })
>   // 2.点击返回顶部
>   $('.gotop').click(function () {
>     $('html').animate({
>       scrollTop: 0
>     })
>   })
> ```
>
> 2.点击意见反馈展开反馈窗口,点击关闭按钮收起反馈窗口
>
> - 反馈窗口默认隐藏
>
> ```html
>  <!-- 意见反馈 -->
>   <div class="suggest">
>     <a href="javascript:;"> <i></i>意见反馈 </a>
>   </div>
>   <!-- 反馈窗口 -->
>   <div class="sugform">
>     <div class="sugtitle">
>       <p>您对<span class="curpage">"当前页面"</span>满意吗?</p>
>       <!-- 关闭按钮 -->
>       <a href="javascript:;" class="close">&nbsp;</a>
>     </div>
>     <div class="check"></div>
>   </div>
> 
> // 意见反馈功能
>   // 3.点击展开
> <script>
>   $('.suggest').click(function () {
>     $('.sugform').slideDown()
>   })
>   // 4.点击收起
>   $('.close').click(function () {
>     $('.sugform').slideUp()
>   })
> ```
>
> 3.内容朝下自动轮播,每次动画结束之后稍作停留,然后继续重复这个过程
>
> - 末尾元素移到顶部,并设置定位为负值	last , prepend , css , outerHeight
>
> - 延迟一会,通过动画将定位变为0	delay , animate 
>
> - 动画播放完毕之后,重复….	动画回调函数 , 抽取为函数
>
> ```html
>   <div class="outer">
>   <div class="wbdesc">
>     <div class="wblist">1</div>
>     <div class="wblist">2</div>
>     <div class="wblist">3</div>
>     <div class="wblist">4</div>
>   </div>
> </div>
> 
> <script>
> // 自动轮播
>   function autoPlay () {
>     //获取最后一个div 将它放在第一位
>     let $last = $('.wblist').last()
>     let $wbdesc = $('.wbdesc')
>     $wbdesc.prepend($last)
>     // 获取盒子的高度包括 内外边距
>     let height = $last.outerHeight(true)
>     console.log(height)
>     // 将父盒子整体向上移动 （必须添加定位属性）
>     $wbdesc.css('top', -height)
>     // 使用animate 改变父盒子定位为0，实现图片向下移动的效果
>     $wbdesc.delay(2000).animate({ top: 0 }, function () {
>       // 动画播放完毕后立即执行回调函数
>       // 回调函数里调用轮播方法，实现循环轮播
>       autoPlay()
>     })
>   }
>   autoPlay()
> ```
>
> 

[网页特效：爱旅行网](D:\Java code\4. jQuery\day02\02.demos\10-爱旅行\index.html)

---

### 记事本

- 在输入内容的情况下,回车新增记事本项,并且以动画的方式添加到页面中,同时清空输入
- 新增和删除记事本项时,更新个数显示

![image-20221011202541044](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221011202541044.png)

> 1.在输入内容的情况下,回车新增记事本项,并且以动画的方式添加到页面中,同时清空输入
>
> - 新增时,判断按键为回车,及输入内容非空；keyup , keyCode , val 
> - 添加记事本项到页面,并设置输入内容；  append
> - 通过展开动画的方式展示元素	display:none , slideDown
> - 清空输入内容	 val
>
> ```html
> <!-- 输入框 -->
> <input id="addTodo" class="new-todo"  />
> <!-- 容器 -->
> <ul class="todo-list" id="todoList">
>   <!-- 记事本项目 -->
>   <li>
>     <div class="view">
>       <label>文本</label>
>       <button class="destroy"></button>
>     </div>
>   </li>
> </ul>
> <!-- 计数区域 -->
> <span class="todo-count">
>   合计:
>   <strong>0</strong>
> </span>
> -------------------------------------------------------------------------------
> <script>
> ;(function () {
>   // 3.删除
>   function count () {
>     // console.log($('#todoList li'))
>     // 合计里  计算有几个li 标签
>     $('.todo-count strong').text($('#todoList li').length)
>   }
>   // 1.新增
>   $('#addTodo').keyup(function (e) {
>     if (e.key === 'Enter') {
>       // 获取输入框中的值
>       let value = $(this).val()
>       if (value !== '') {
>         console.log('输入了内容')
>         // 在父盒子的最后动态添加 html 的li标签，标签设置默认隐藏
>         $('#todoList').append(`
>         <li style="display:none" >
>             <div class="view">
>               <label>${value}</label>
>               <button class="destroy"></button>
>             </div>
>           </li>`)
>           // 给动态添加的标签，添加展开动画，计算合计里的数据
>         $('#todoList li')
>           .last()
>           .slideDown(function () {
>             count()
>           })
>           //清空输入框内容
>         $(this).val('')
>       }
>     }
>   })
> 
> ```
>
> 2.新增和删除记事本项时,更新个数显示
>
> - 为删除按钮绑定点击事件；   on , click
> - 找到祖先元素li标签并播放淡出动画；  parent , fadeOut
> - 动画播放完毕,删除li标签 ，获取li标签的个数并更新个数；    回调函数 , remove，text
>
> ```js
>  // 2.通过事件委托给子标签绑定删除事件
>   $('#todoList').on('click', '.destroy', function () {
>     // 删除 li标签 
>     let $li = $(this)
>       .parent()
>       .parent()
>       // 添加淡出动画，实现删除效果
>     $li.fadeOut(function () {
>       $(this).remove()
>       // $('.todo-count strong').text($('#todoList li').length)
>         // 每次删除重新计数
>       count()
>     })
>   })
> ```
>
> 

[网页特效：记事本](D:\Java code\4. jQuery\day02\02.demos\19-记事本\index.html)

---

### 360动画

- 整合全屏滚动效果，每次切屏完毕播放动画，支持来回滚动

![image-20221013103319902](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013103319902.png)

![image-20221013103405870](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221013103405870.png)

```js
;(function () {
  // 整合全屏滚动效果
  $('#fullpage').fullpage({
    afterLoad(anchor, index) {
      console.log('afterLoad')
      console.log('anchor:', anchor)
      console.log('index:', index)
      $('.section').removeClass('current')
      // 页面加载过快，第一屏没有动画效果
      // 需要开启延迟定时器，时间设为 0.1 秒
      setTimeout(function () {
        $('.section')
          .eq(index - 1)
          .addClass('current')
      }, 100)
    },
  })
})()
```

> 页面加载过快，第一屏没有动画效果 。需要开启延迟定时器，时间设为 0.1 秒

### 人员管理

![image-20221023112058301](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221023112058301.png)

> 1.点击新增按钮时 
>
> - 表单标签
>
> ```html
>  <tr style="display: none;">
>             <td class="td-name">小红</td>
>             <td class="td-mobile">18888881111</td>
>             <td class="td-birth">1990年02月08日</td>
>             <td>
>               <button class="btn edit">编辑</button>
>               <button class="btn del">删除</button>
>             </td>
>           </tr>
> 
> ```
>
> - 需要整合日期插件和表单验证插件 ；进行手机号验证时，需要添加正则表达式 ( data-pattern )`  ^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$`
> - `默认存在一条 tr隐藏，防止用户删除后克隆失败`  <tr style="display: none;">
>
> - 点击提交新增数据到页面上，关闭弹框之后清空内容； let $editTr = undefined  、 let $tr = $(this).parent().parent()、 $editTr = $tr   通过编辑按钮对象找到 tr对象，在赋值为全局变量   ，用于判断当前提交 是新增 还是 编辑， 如果是编辑 则需要将表单中的数据 写入tr中
>
> ```js
>   // 将点击编辑后得到的 tr 当前行标签定义为 全局变量
>   // 用于判断当前提交 是新增 还是 编辑
>   // 如果是编辑 则需要将表单中的数据 写入tr中
>   let $editTr = undefined
> // 1. 点击弹框
>   $('.add').click(function () {
>     $('.dialog-wrap h3').text('新增')
>    // 编辑对象为 underfined 表示用户未点击编辑按钮
>     $editTr = undefined
>     $('.dialog-wrap').fadeIn()
>   })
> 
> // 关闭弹窗时，清空表单的方法
>   function clear() {
>     // 使用淡出动画
>     $('.dialog-wrap').fadeOut(function () {
>       // 表单重置
>       $('.form')[0].reset()
>       $('.form span').text('')
>     })
>   }
>  // 4.点击取消
>   $('.cancel').click(function () {
>     clear()
>   })
> 
>   // 5.点击关闭
>   $('.close').click(function () {
>     clear()
>   })
> 
>  // 3.表单校验
>   $('.form').validate({
>     sendForm: false,
>     description: {
>       nickname: {
>         required: '姓名不能为空!',
>       },
>       mobile: {
>         required: '手机不能为空!',
>         pattern: '手机格式有误!',
>       },
>       birthday: {
>         required: '生日不能为空!',
>       },
>     },
>     valid() {
>       // 表单提交需要判断是 新增还是编辑功能
>       console.log('校验成功')
>         
>       if ($editTr === undefined) {
>         // 克隆标签，返回 jq对象
>         let $tr = $('tbody tr').first().clone()
>         // 表单中取值使用 val 方法
>         let nickname = $('.nickname').val()
>         let mobile = $('.mobile').val()
>         let birthday = $('.birthday').val()
>         // 在td 中填充数据 还用 text 方法
>         $tr.find('.td-name').text(nickname)
>         $tr.find('.td-mobile').text(mobile)
>         $tr.find('.td-birth').text(birthday)
>         $('tbody').append($tr)
>         // 显示 tr ，默认存在一条 tr隐藏，防止用户删除后克隆失败
>         $tr.show()
>         clear()
>       } else {
>         console.log('编辑')
>         let nickname = $('.nickname').val()
>         let mobile = $('.mobile').val()
>         let birthday = $('.birthday').val()
>         $editTr.find('.td-name').text(nickname)
>         $editTr.find('.td-mobile').text(mobile)
>         $editTr.find('.td-birth').text(birthday)
>         clear()
>       }
>     },
>   }
> ```
>
> 2.点击删除，直接删除整行
>
> - 利用事件委托，绑定删除事件，this指向当前点击的按钮  (dom对象)
> - `默认存在一条 tr隐藏，防止用户删除后克隆失败`
>
> ```js
>  // 6.删除
>   $('tbody').on('click', '.del', function () {
>     console.log('this:', this)
>     let $tr = $(this).parent().parent()
>     console.log('$tr:', $tr)
>     $tr.fadeOut(function () {
>       $tr.remove()
>     })
>   })
> ```
>
> 3.通过编辑按钮 点击提交，修改数据并关闭弹框
>
> - 通过事件委托 ，给编辑按钮绑定事件；找到 tr对象并定义为全局变量 （表单提交时需要使用，点击编辑时此时 tr里肯定有数据）
>
> ```js
> // 7. 进入编辑状态，进行数据回写
>   $('tbody').on('click', '.edit', function () {
>     let $tr = $(this).parent().parent()
>     console.log('$tr:', $tr)
>       // 先获取 tr里的数据
>     let name = $tr.find('.td-name').text()
>     let mobile = $tr.find('.td-mobile').text()
>     let birth = $tr.find('.td-birth').text()
>     console.log(name, mobile, birth)
>     $('.dialog-wrap h3').text('编辑')
>       // 填充到表单中 ，数据回写
>     $('.nickname').val(name)
>     $('.mobile').val(mobile)
>     $('.birthday').val(birth)
>     $('.dialog-wrap').fadeIn()
> 
>     // 找到当前点击的tr对象
>     $editTr = $tr
>   })
> ----------------------------------------------------------------------------------------
>   valid() {
>       // 表单提交需要判断是 新增还是编辑功能
>       console.log('校验成功')
>         //  tr 对象为 underfined 表示为点击编辑，执行新增的提交逻辑
>       if ($editTr === undefined) {
>         // 克隆标签，返回 jq对象
>         let $tr = $('tbody tr').first().clone()
>         // 表单中取值使用 val 方法
>         let nickname = $('.nickname').val()
>         let mobile = $('.mobile').val()
>         let birthday = $('.birthday').val()
>         // 在td 中填充数据 还用 text 方法
>         $tr.find('.td-name').text(nickname)
>         $tr.find('.td-mobile').text(mobile)
>         $tr.find('.td-birth').text(birthday)
>         $('tbody').append($tr)
>         // 显示 tr ，默认存在一条 tr隐藏，防止用户删除后克隆失败
>         $tr.show()
>         clear()
>        
>       }
>       // 如果 tr对象 有值 ，则表示执行编辑的提交逻辑
>       else {
>         console.log('编辑')
>           // 获取表单中修改的数据，填充到 tr中
>         let nickname = $('.nickname').val()
>         let mobile = $('.mobile').val()
>         let birthday = $('.birthday').val()
>         $editTr.find('.td-name').text(nickname)
>         $editTr.find('.td-mobile').text(mobile)
>         $editTr.find('.td-birth').text(birthday)
>         clear()
>       }
>     },
> 
> ```
>
> 

[网页特效：人员管理](D:\Java code\4. jQuery\day03\13-manager\示例.html)

---

# 数据可视化

---

## 数据可视化的概念

- 数据可视化主要目的：借助于图形化手段，清晰有效地传达与沟通信息。

-  数据可视化可以把数据从冰冷的数字转换成图形，揭示蕴含在数据中的规律和道理。

- 数据可视化在我们互联网公司中经常用于通用`数据报表，移动端图表，大屏可视化，图编辑等`

![image-20221025104435295](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025104435295.png)

### 数据可视化的场景

![image-20221025104747956](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025104747956.png)

### 常见的数据可视化库

-  D3.js   目前 Web 端评价最高的 Javascript 可视化工具库(入手难)  

- `ECharts.js   百度出品的一个开源 Javascript 数据可视化库  `

-  Highcharts.js  国外的前端数据可视化库，非商用免费，被许多国外大公司所使用 

-  AntV  蚂蚁金服全新一代数据可视化解决方案

---

## 数据可视化项目

![image-20221025110241549](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025110241549.png)

![image-20221025110301997](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025110301997.png)

## ECharts (可视化js 库)

-    ECharts是一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），`底层依赖矢量图形库 ZRender`，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

- 官网地址：[Apache ECharts](https://echarts.apache.org/zh/index.html)

- 图表示例：[Examples - Apache ECharts](https://echarts.apache.org/examples/zh/index.html)

- 官方教程：[五分钟上手ECharts]([Handbook - Apache ECharts](https://echarts.apache.org/handbook/zh/get-started/))

---

### ECharts的基本使用

![image-20221025161107535](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025161107535.png)

自己步骤：

- 下载echarts  [echarts/dist at 5.4.0 · apache/echarts · GitHub](https://github.com/apache/echarts/tree/5.4.0/dist)
- 引入echarts  `dist/echarts.min.js`
- 准备一个具备大小的DOM容器

```html
<div id="main" style="width: 600px;height:400px;"></div>
```

- ###### 初始化echarts实例对象

```js
var myChart = echarts.init(document.getElementById('main'));
```

- 指定配置项和数据(option)

```js
var option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};
```

- 将配置项设置给echarts实例对象

```js
myChart.setOption(option);
```

[网页特效：ECharts 入门示例](D:\Java code\5. 数据可视化\day01\01-ECharts体验.html)

---

### 相关配置项讲解

- `配置项手册`：[Documentation - Apache ECharts](https://echarts.apache.org/zh/option.html#title)

---

- series

  - 系列列表。每个系列通过 `type` 决定自己的图表类型
  - type:  类型 (什么类型的图表)  比如  line 是折线  bar   柱形等
  - name: 系列名称，用于tooltip的显示，legend 的图例筛选 变化
  - stack: 数据堆叠。  如果设置相同值，则会数据堆叠。 
    - 数据堆叠：    第二个数据值=  第一个数据值 +  第二个数据值  ；第三个数据值 =  第二个数据值 +  第三个数据值….  依次叠加。`如果给stack 指定不同值或者去掉这个属性则不会发生数据堆叠`

- xAxis：直角坐标系 grid 中的 x 轴

  -  boundaryGap: 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。

- yAxis：直角坐标系 grid 中的 y 轴

- grid：直角坐标系内绘图网格。 

- title：标题组件

- tooltip：提示框组件

- legend：图例组件

- color：调色盘颜色列表，颜色与图例组件一一对应

  ![image-20221025163404724](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025163404724.png)

演示代码：

![image-20221025170505640](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025170505640.png)

```js
var option = {
            color: ['pink', 'blue', 'green', 'skyblue', 'red'],
            title: {
                text: '折线图'
            },
            tooltip: {
                trigger: 'axis'
            },
            legend: {
                data: ['直播营销', '联盟广告', '视频广告', '直接访问']
            },
            grid: {
                left: '3%',
                right: '3%',
                bottom: '3%',
                // 当刻度标签溢出的时候，grid 区域是否包含坐标轴的刻度标签。如果为true，则显示刻度标签
                // 如果left right等设置为 0% 刻度标签就溢出了，此时决定是否显示刻度标签
                containLabel: true
            },
            toolbox: {
                feature: {
                    saveAsImage: {}
                }
            },
            xAxis: {
                type: 'category',
                // 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。
                boundaryGap: false,
                data: ['星期一', '星期二', '周三', '周四', '周五', '周六', '周日']
            },
            yAxis: {
                type: 'value'
            },
            series: [
                {
                    name: '直播营销',
                    // 图表类型是线形图
                    type: 'line',
                    data: [120, 132, 101, 134, 90, 230, 210]
                },
                {
                    name: '联盟广告',
                    type: 'line',

                    data: [220, 182, 191, 234, 290, 330, 310]
                },
                {
                    name: '视频广告',
                    type: 'line',

                    data: [150, 232, 201, 154, 190, 330, 410]
                },
                {
                    name: '直接访问',
                    type: 'line',

                    data: [320, 332, 301, 334, 390, 330, 320]
                }
            ]
        };
```

## 数据可视化项目适配方案

- [网页特效：数据可视化图表](D:\Java code\5. 数据可视化\day02\charts-project\index.html)

- 设计稿是1920px  

- PC端适配： `宽度在 1024~1920之间页面元素宽高自适应 （大于1920 或者 小于1024时，盒子尺寸固定）`

  1. flexible.js 把屏幕分为 24 等份

  2. cssrem 插件的基准值是  80px   (cssrem 插件 可以将 px单位转为 rem单位)

     插件-配置按钮---配置扩展设置--Root Font Size 里面 设置。 

     但是别忘记重启vscode软件保证生效

  3. 要把屏幕宽度约束在1024~1920之间有适配，实现代码：

![image-20221025203217162](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025203217162.png)

```html
 <style>
        @media screen and (max-width: 1024px) {
            html {
                font-size: 42.66px !important;
            }
        }

        @media screen and (min-width: 1920px) {
            html {
                font-size: 80px !important;
            }
        }

        div {
            width: 2.5rem;
            height: 2.5rem;
            background-color: pink;
        }
    </style>
```

> 只要屏幕小于 1024px 或者大于 1920px 时，设置固定字号值，使的盒子的大小固定

项目准备-保存自动刷新浏览器插件

![image-20221025205058672](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221025205058672.png)

### 项目布局

---

用flex 布局，将屏幕分为3个区域，版心 命名为 viewport

![image-20221026111522431](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221026111522431.png)

![image-20221026111537557](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221026111537557.png)

中间部分 占4 格， 左右部分 占3格； `背景图片 使用 contain 时，会铺满 x 或者 y轴 ，可能会有留白`

```css
.viewport {
  display: flex;
  min-width: 1024px;
  max-width: 1920px;
  margin: 0 auto;
  padding: 1.1rem 0.25rem 0;
  background: url(../images/logo.png) no-repeat 0 0 / contain;
  min-height: 780px;
}
.viewport .column {
  flex: 3;
}
.viewport .column:nth-child(2) {
  flex: 4;
  margin: 0.4rem 0.25rem 0;
}
```

### 公共面板样式开发

---

使用 边框图片 开发公共面板

![image-20221026162408676](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221026162408676.png)

![image-20221026162613673](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221026162613673.png)

使用边框图片时，盒子必须要有边框（ border: 15px solid transparent;）；边框四周不相等时，需要重新设置值，为 计算后的 slice的值   ` 与border-image-slice 的值相等`

```css
panel {
  position: relative;
  border: 15px solid transparent;
  border-width: 0.6375rem 0.475rem 0.25rem 1.65rem; 
  border-image-source: url(../images/border.png);
  border-image-slice: 51 38 20 132;
  margin-bottom: 0.25rem;
}
.inner {
  position: absolute;
  top: -0.6375rem;
  left: -1.65rem;
  right: -0.475rem;
  bottom: -0.25rem;
  background-color: red;
  padding: 0.3rem 0.45rem;
}
```

> border-width  设置的时边框的宽度 ； border-image-width 设置的是边框图片的宽度
>
> 内盒子的显示区域被挤压，需要通过定位实现盒子拉伸 （设置上下左右 四个值），并添加内边距 控制显示内容的范围

### 监控区域(monitor)-布局

---

#### JQ 实现状态栏的切换 、CSS实现 无缝滚动

 ![image-20221027103800546](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221027103800546.png)

状态栏切换时，添加 active 类 ；  eq($(this).index())  通过索引找到 对应状态栏的盒子

```html
 <div class="panel monitor">
<div class="inner">
            <div class="tabs">
              <a href="javascript:;" class="active">故障设备监控</a>
              <a href="javascript:;">异常设备监控</a>
            </div>
            <div class="content" style="display: block;">
              <div class="head">
                <span class="col">故障时间</span>
                <span class="col">设备地址</span>
                <span class="col">异常代码</span>
              </div>
              <div class="marquee-view">
                <div class="marquee">
                  <div class="row">
                    <span class="col">20180701</span>
                    <span class="col">11北京市昌平西路金燕龙写字楼</span>
                    <span class="col">1000001</span>
                    <span class="icon-dot"></span>
                  </div>
       --------------------------------------------------------------------------------------------             
<script>
// 监控区域模块制作
(function() {
  $(".monitor .tabs").on("click", "a", function() {
    $(this)
      .addClass("active")
      // 找到兄弟元素进行移除
      .siblings("a")
      .removeClass("active");

    // console.log($(this).index());
    //   选取对应索引号的content
    $(".monitor .content")
      .eq($(this).index())
      .show()
      // 找到兄弟元素进行隐藏
      .siblings(".content")
      .hide();
  });
```

CSS 实现无缝滚动

 ![image-20221027115509606](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221027115509606.png)

- 先遍历 克隆marquee里面所有的行（row）；通过CSS3动画滚动marquee；鼠标经过marquee 就停止动画

```html
<script>
// 1. 先克隆marquee里面所有的行（row）
  //  each 遍历对象 并进行克隆
  $(".marquee-view .marquee").each(function() {
    // console.log($(this));
    var rows = $(this)
      .children()
      .clone();
    $(this).append(rows);
  });
---------------------------------------------------------------------
 
  /* 通过CSS3动画滚动marquee */
.marquee-view .marquee {
  /* 设置动画 曲线匀速、无限循环*/
  animation: move 15s linear infinite;
}
@keyframes move {
  0% {
  }
  100% {
    /* 单位为% 时，向上移动自身高度的一半*/
    transform: translateY(-50%);
  }
}
/* 3.鼠标经过marquee 就停止动画 */
.marquee-view .marquee:hover {
  animation-play-state: paused;
}   

```

### 点位区域(point)-布局

ECharts图表实现步骤：

- 从官方示例中找到类似图表，适当修改，引入到HTML页面中。
- 按照产品需求，来定制图表。

 ![image-20221027163908317](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221027163908317.png)

```js
option = {
    // 提示框组件
    tooltip: {
      // trigger 触发方式。  非轴图形，使用item的意思是放到数据对应图形上触发提示
      trigger: 'item',
      // 格式化提示内容：
      // a 代表series系列图表名称  
      // b 代表series数据名称 data 里面的name    
      // c 代表series数据值 data 里面的value   
      // d代表  当前数据/总数据的比例
      formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    // 控制图表
    series: [
      {
        // 图表名称
        name: '点位统计',
        // 图表类型
        type: 'pie',
        // 南丁格尔玫瑰图 有两个圆  内圆半径10%  外圆半径70%
        // 饼形图半径。 可以是像素。也可以是百分比（ 基于DOM容器大小）第一项是内半径，第二项是外半径（通过它可以实现饼形图大小）
        radius: ['10%', '70%'],
        // 图表中心位置 left 50%  top 50%  距离图表DOM容器
        center: ['50%', '50%'],
        // radius 半径模式，另外一种是 area 面积模式
        roseType: 'radius',
        // 数据集 value 数据的值 name 数据的名称
        data: [
                {value:10, name:'rose1'},
                {value:5, name:'rose2'},
                {value:15, name:'rose3'},
                {value:25, name:'rose4'},
                {value:20, name:'rose5'},
                {value:35, name:'rose6'},
                {value:30, name:'rose7'},
                {value:40, name:'rose8'}
            ]
        }
    ]
};
```

饼图图形上的文本标签可以控制饼形图的文字的一些样式。   label 对象设置

```js
series: [
      {
        name: "面积模式",
        type: "pie",
        radius: [30, 110],
        center: ["50%", "50%"],
        roseType: "radius",
        // 文本标签控制饼形图文字的相关样式， 注意它是一个对象
        label: {
          fontSize: 10
        },
      }
    ]
  };
```

浏览器缩放的时候，图表跟着自动适配。

```js
// 监听浏览器缩放，图表对象调用缩放resize函数
window.addEventListener("resize", function() {
    myChart.resize();
  });
```

### 销售统计( sales )-布局

series 里面的data 数据决定着折线的显示

当我们点击不同的tab标签， 就让  series 里面的data调用不同的数据即可

 ![image-20221028192948858](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221028192948858.png)

#### html 标签 

---

需要自定义属性 data-type， 实现点击切换状态栏

```html
 <!-- 销售额 -->
        <div class="sales panel">
          <div class="inner">
            <div class="caption">
              <h3>销售额统计</h3>
              <a href="javascript:;" class="active" data-type="year">年</a>
              <a href="javascript:;" data-type="quarter">季</a>
              <a href="javascript:;" data-type="month">月</a>
              <a href="javascript:;" data-type="week">周</a>
            </div>
            <div class="chart">
              <div class="label">单位:万</div>
                <!-- 直线图存放区域-->
              <div class="line"></div>
            </div>
          </div>
        </div>
```

#### js 代码

---

年、季、月和周的数据 

```js
var data = {
    year: [
      [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120],
      [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79]
    ],
    quarter: [
      [23, 75, 12, 97, 21, 67, 98, 21, 43, 64, 76, 38],
      [43, 31, 65, 23, 78, 21, 82, 64, 43, 60, 19, 34]
    ],
    month: [
      [34, 87, 32, 76, 98, 12, 32, 87, 39, 36, 29, 36],
      [56, 43, 98, 21, 56, 87, 43, 12, 43, 54, 12, 98]
    ],
    week: [
      [43, 73, 62, 54, 91, 54, 84, 43, 86, 43, 54, 53],
      [32, 54, 34, 87, 32, 45, 62, 68, 93, 54, 54, 24]
    ]
  };
```

 tab栏的点击切换效果

- 通过事件委托给 a标签添加点击事件，点击后给当前点击的标签添加 active ；拿到当前标签的自定义属性值，通过该值拿到 数据对象中的对应数据 

- 根据拿到的数据重新渲染 series里面的data值    `option.series[0].data`

- **此时要注意点击tab栏后，为了防止自动切换顺序会乱，需要获取当前标签的索引值**

```js
// 4. tab切换效果制作
  // (2) 点击切换效果
 var index = 0;  
$(".sales .caption").on("click", "a", function() {
    // 此时要注意这个索引号的问题，caption 的 jq对象中包含h3 ，所以a标签的索引从 1 开始
    // 通过事件委托获得的索引 要与自动切换tab 获得的 a索引一致，所以索引值需要减一
    index = $(this).index() - 1;
    // 点击当前a 高亮显示 调用active
    $(this)
      .addClass("active")
      .siblings("a")
      .removeClass("active");
    // 拿到当前a 的自定义属性值
    // console.log(this.dataset.type);
    // 根据拿到的值 去找数据
    // console.log(data.year);
    // console.log(data["year"]);
    // console.log(data[this.dataset.type]);
    var arr = data[this.dataset.type];
    // console.log(arr);
    // 根据拿到的数据重新渲染 series里面的data值
    option.series[0].data = arr[0];
    option.series[1].data = arr[1];
    // 重新把配置好的新数据给实例对象
    myChart.setOption(option);
  });
```

tab栏自动切换效果

-  开启定时器每隔1s，自动让a触发点击事件即可，拿到 a标签的 jq对象

- 鼠标经过sales，关闭定时器，离开开启定时器
  - **hover 事件，分为经过和离开，第一个回调函数处理经过事件，第二个处理离开事件**

```js
// 5. tab栏自动切换效果
  //  开启定时器每隔1s，自动让a触发点击事件即可
  var as = $(".sales .caption a");
  var index = 0;

  var timer = setInterval(function() {
    index++;
    if (index >= 4) index = 0;
    as.eq(index).click();
  }, 1000);
  // 鼠标经过sales，关闭定时器，离开开启定时器
  $(".sales").hover(
    function() {
      clearInterval(timer);
    },
    function() {
      timer = setInterval(function() {
        index++;
        if (index >= 4) index = 0;
        as.eq(index).click();
      }, 1000);
    }
  );
```

### 全国热榜模块制作（重要）

---

获得后台数据，并进行页面渲染；需要实现鼠标经过事件，以及自动播放

 ![image-20221030172247561](C:\Users\Savior\AppData\Roaming\Typora\typora-user-images\image-20221030172247561.png)

#### html 标签

---

各省热销、近30日的数据需要 使用模板字符串拼接后进行渲染

```html
   <!-- 全国热榜模块制作 -->
        <div class="top panel">
          <div class="inner">
            <div class="all">
              <h3>全国热榜</h3>
              <ul>
                <li>
                  <i class="icon-cup1" style="color: #d93f36;"></i>
                  可爱多
                </li>
                <li>
                  <i class="icon-cup2" style="color: #68d8fe;"></i>
                  娃哈啥
                </li>
                <li>
                  <i class="icon-cup3" style="color: #4c9bfd;"></i>
                  喜之郎
                </li>
              </ul>
            </div>
            <div class="province">
              <h3>各省热销 <i class="date">// 近30日 //</i></h3>
              <div class="data">
                <ul class="sup">
                  <!-- <li>
                    <span>北京</span>
                    <span>25,179 <s class="icon-up"></s></span>
                  </li>
                  <li>
                    <span>河北</span>
                    <span>23,252 <s class="icon-down"></s></span>
                  </li> -->
                </ul>
                <ul class="sub">
                  <!-- <li><span></span><span> <s class="icon-up"></s></span></li> -->
                </ul>
              </div>
            </div>
          </div>
        </div>
        
```

#### JS 代码

---

##### 1.全国热榜模块的数据

```js
 var hotData = [
    {
      city: "北京", // 城市
      sales: "25, 179", // 销售额
      flag: true, //  上升还是下降
      brands: [
        //  品牌种类数据
        { name: "可爱多", num: "9,086", flag: true },
        { name: "娃哈哈", num: "8,341", flag: true },
        { name: "喜之郎", num: "7,407", flag: false },
        { name: "八喜", num: "6,080", flag: false },
        { name: "小洋人", num: "6,724", flag: false },
        { name: "好多鱼", num: "2,170", flag: true }
      ]
    },
    {
      city: "河北",
      sales: "23,252",
      flag: false,
      brands: [
        { name: "可爱多", num: "3,457", flag: false },
        { name: "娃哈哈", num: "2,124", flag: true },
        { name: "喜之郎", num: "8,907", flag: false },
        { name: "八喜", num: "6,080", flag: true },
        { name: "小洋人", num: "1,724", flag: false },
        { name: "好多鱼", num: "1,170", flag: false }
      ]
    },
    {
      city: "上海",
      sales: "20,760",
      flag: true,
      brands: [
        { name: "可爱多", num: "2,345", flag: true },
        { name: "娃哈哈", num: "7,109", flag: true },
        { name: "喜之郎", num: "3,701", flag: false },
        { name: "八喜", num: "6,080", flag: false },
        { name: "小洋人", num: "2,724", flag: false },
        { name: "好多鱼", num: "2,998", flag: true }
      ]
    },
    {
      city: "江苏",
      sales: "23,252",
      flag: false,
      brands: [
        { name: "可爱多", num: "2,156", flag: false },
        { name: "娃哈哈", num: "2,456", flag: true },
        { name: "喜之郎", num: "9,737", flag: true },
        { name: "八喜", num: "2,080", flag: true },
        { name: "小洋人", num: "8,724", flag: true },
        { name: "好多鱼", num: "1,770", flag: false }
      ]
    },
    {
      city: "山东",
      sales: "20,760",
      flag: true,
      brands: [
        { name: "可爱多", num: "9,567", flag: true },
        { name: "娃哈哈", num: "2,345", flag: false },
        { name: "喜之郎", num: "9,037", flag: false },
        { name: "八喜", num: "1,080", flag: true },
        { name: "小洋人", num: "4,724", flag: false },
        { name: "好多鱼", num: "9,999", flag: true }
      ]
    }
  ];
```

##### 2.根据数据渲染各省热销 sup 模块内容

- each 方法遍历对象，使用模板字符串 拼接标签
- item.flag ? "icon-up" : "icon-down"  使用三元运算符 ，当 取得true时 获得上升的 icon图表，false时取得下降的icon图表
- html (supHTML)  渲染标签

```js
 //  遍历 hotData对象
  var supHTML = "";
  $.each(hotData, function(index, item) {
    // console.log(item);
    supHTML += `<li><span>${item.city}</span><span> ${item.sales} <s class=
    ${item.flag ? "icon-up" : "icon-down"}></s></span></li>`;
  });
  // 把生成的5个小li字符串给 sub dom盒子
  $(".sup").html(supHTML);
```

##### 3.当鼠标经过当前的小li要高亮显示，并将对应的品牌对象进行渲染

-   index = $(this).index();  `鼠标经过获得当前小li的索引 ，给index 重新赋值，保证自动轮播的顺序不会乱 `
- 默认把第一个小li处于鼠标经过状态

```js
$(".sup").html(supHTML);
  // 3. 当鼠标进入 tab 的时候
  // 鼠标经过当前的小li要高亮显示
  $(".province .sup").on("mouseenter", "li", function() {
    // 鼠标经过获得当前小li的索引  
    index = $(this).index();
    render($(this));
  });

// 声明一个函数 里面设置sup当前小li高亮还有 对应的品牌对象渲染
// 将 li的对象作为参数传递
function render(currentEle) {
    currentEle
      .addClass("active")
      .siblings()
      .removeClass();
    
    // 拿到当前城市的品牌对象，开始遍历品牌数组
    var subHTML = "";
    // li的索引 与数组数据中的索引对应
    $.each(hotData[currentEle.index()].brands, function(index, item) {
      // 是对应城市的每一个品牌对象
      // console.log(item);
      subHTML += `<li><span>${item.name}</span><span> ${item.num}<s class=
    ${item.flag ? "icon-up" : "icon-down"}
    ></s></span></li>`;
    });
    // 把生成的6个小li字符串给 sub dom盒子
    $(".sub").html(subHTML);
  }

//默认把第一个小li处于鼠标经过状态
 var lis = $(".province .sup li");
  lis.eq(0).mouseenter();
```

##### 4.开启定时器自动滚动，当鼠标经过时暂停，移出则恢复滚动

- 定时器中不能触发鼠标经过事件，hover 中也存在鼠标经过事件 会冲突

```js
 var index = 0;
  var timer = setInterval(function() {
    index++;
    if (index >= 5) index = 0;
    // lis.eq(index).mouseenter();
    render(lis.eq(index));
  }, 2000);

  $(".province .sup").hover(
    // 鼠标经过事件
    function() {
      clearInterval(timer);
    },
    // 鼠标离开事件
    function() {
      clearInterval(timer);
      timer = setInterval(function() {
        index++;
        if (index >= 5) index = 0;
        // lis.eq(index).mouseenter();
        render(lis.eq(index));
      }, 2000);
    }
  );
```





